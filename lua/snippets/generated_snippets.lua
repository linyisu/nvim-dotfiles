-- Auto-generated LuaSnip snippets
local ls = require("luasnip") -- 引入 LuaSnip
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

return {

-- 00_Common\CompileSettings.h
s("00_common_compilesettings_h", {
	t({
		"// 编译器优化设置",
		"#pragma GCC optimize(\"O3,unroll-loops\")",
		"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
		"",
		"// 类型定义",
		"using ll = long long;",
		"using ull = unsigned long long;",
		"using i128 = __int128;",
		"using ld = long double;",
		"using pii = pair<int, int>;",
		"using pll = pair<ll, ll>;",
		"",
		"// 常用宏定义",
		"#define sz(x) ((int)(x).size())",
		"#define all(x) (x).begin(), (x).end()",
		"#define rall(x) (x).rbegin(), (x).rend()",
		"#define pb push_back",
		"#define eb emplace_back",
		"#define fi first",
		"#define se second",
		"",
		"// 调试宏定义",
		"#ifndef ONLINE_JUDGE",
		"#define dbg(x) cerr << #x << \" = \" << x << '\\n'",
		"#define dbg2(x, y) cerr << #x << \" = \" << x << \", \" << #y << \" = \" << y << '\\n'",
		"#define dbgv(v)                        \\",
		"    cerr << #v << \": \";                \\",
		"    for (auto x : v) cerr << x << ' '; \\",
		"    cerr << '\\n'",
		"#else",
		"#define dbg(x)",
		"#define dbg2(x, y)",
		"#define dbgv(v)",
		"#endif",
		"",
		"// 常用常量",
		"constexpr int INF = 1e9 + 7;",
		"constexpr ll LINF = 1e18 + 7;",
		"constexpr int MOD = 1e9 + 7;",
		"constexpr int MOD2 = 998244353;",
		"constexpr ld EPS = 1e-9;",
		"const ld PI = acos(-1);",
		"",
		"// 方向数组 (上下左右)",
		"constexpr int dx[] = {-1, 1, 0, 0};",
		"constexpr int dy[] = {0, 0, -1, 1};",
		"",
		"// 八方向数组",
		"constexpr int dx8[] = {-1, -1, -1, 0, 0, 1, 1, 1};",
		"constexpr int dy8[] = {-1, 0, 1, -1, 1, -1, 0, 1};",
		"",
		"// 快速幂模板",
		"template <typename T>",
		"T qpow(T a, T b, T mod = MOD) {",
		"    T res = 1;",
		"    a %= mod;",
		"    while (b > 0) {",
		"        if (b & 1) res = res * a % mod;",
		"        a = a * a % mod;",
		"        b >>= 1;",
		"    }",
		"    return res;",
		"}",
		"",
		"// 模运算工具函数",
		"template <typename T>",
		"T add(T a, T b, T mod = MOD) {",
		"    return (a + b) % mod;",
		"}",
		"",
		"template <typename T>",
		"T sub(T a, T b, T mod = MOD) {",
		"    return (a - b + mod) % mod;",
		"}",
		"",
		"template <typename T>",
		"T mul(T a, T b, T mod = MOD) {",
		"    return a * b % mod;",
		"}",
		"",
		"template <typename T>",
		"T inv(T a, T mod = MOD) {",
		"    return qpow(a, mod - 2, mod);",
		"}",
		"",
		"template <typename T>",
		"T div_mod(T a, T b, T mod = MOD) {",
		"    return mul(a, inv(b, mod), mod);",
		"}",
	})
}),

-- 00_Common\Coordinate.h
s("00_common_coordinate_h", {
	t({
		"// 坐标离散化工具类",
		"template <typename T>",
		"struct Coordinate {",
		"    vector<T> vals;",
		"    bool sorted = false;",
		"",
		"    Coordinate() {}",
		"    Coordinate(const vector<T>& v) : vals(v) {}",
		"",
		"    // 添加单个值",
		"    void add(const T& val) {",
		"        vals.push_back(val);",
		"        sorted = false;",
		"    }",
		"",
		"    // 添加多个值",
		"    void add(const vector<T>& v) {",
		"        for (const auto& val : v) vals.push_back(val);",
		"        sorted = false;",
		"    }",
		"",
		"    // 构建离散化数组(去重排序)",
		"    void build() {",
		"        sort(vals.begin(), vals.end());",
		"        vals.erase(unique(vals.begin(), vals.end()), vals.end());",
		"        sorted = true;",
		"    }",
		"",
		"    // 获取值在离散化数组中的位置",
		"    int get(const T& val) {",
		"        if (!sorted) build();",
		"        return lower_bound(vals.begin(), vals.end(), val) - vals.begin();",
		"    }",
		"",
		"    // 根据位置获取值",
		"    T operator[](int idx) {",
		"        if (!sorted) build();",
		"        return vals[idx];",
		"    }",
		"",
		"    // 获取离散化后的数组大小",
		"    int size() {",
		"        if (!sorted) build();",
		"        return vals.size();",
		"    }",
		"",
		"    // 查找值在离散化数组中的位置，不存在返回-1",
		"    int find(const T& val) {",
		"        if (!sorted) build();",
		"        auto it = lower_bound(vals.begin(), vals.end(), val);",
		"        if (it != vals.end() && *it == val) { return it - vals.begin(); }",
		"        return -1;",
		"    }",
		"",
		"    // 获取第一个大于等于val的位置",
		"    int lower(const T& val) {",
		"        if (!sorted) build();",
		"        return lower_bound(vals.begin(), vals.end(), val) - vals.begin();",
		"    }",
		"",
		"    // 获取第一个大于val的位置",
		"    int upper(const T& val) {",
		"        if (!sorted) build();",
		"        return upper_bound(vals.begin(), vals.end(), val) - vals.begin();",
		"    }",
		"};",
		"",
		"// 二维坐标离散化",
		"template <typename T>",
		"struct Coordinate2D {",
		"    Coordinate<T> x_coord, y_coord;",
		"",
		"    // 添加单个点",
		"    void add(const T& x, const T& y) {",
		"        x_coord.add(x);",
		"        y_coord.add(y);",
		"    }",
		"",
		"    // 添加多个点",
		"    void add(const vector<pair<T, T>>& points) {",
		"        for (const auto& [x, y] : points) { add(x, y); }",
		"    }",
		"",
		"    // 构建离散化数组",
		"    void build() {",
		"        x_coord.build();",
		"        y_coord.build();",
		"    }",
		"",
		"    // 获取点的离散化坐标",
		"    pair<int, int> get(const T& x, const T& y) { return {x_coord.get(x), y_coord.get(y)}; }",
		"",
		"    // 根据离散化坐标获取原坐标",
		"    pair<T, T> operator[](const pair<int, int>& idx) { return {x_coord[idx.first], y_coord[idx.second]}; }",
		"",
		"    // 获取离散化后的二维大小",
		"    pair<int, int> size() { return {x_coord.size(), y_coord.size()}; }",
		"};",
	})
}),

-- 00_Common\FastIO.h
s("00_common_fastio_h", {
	t({
		"// 快速输入输出模板",
		"// 适用于大量数据的读入和输出场景",
		"",
		"// 快速读入函数",
		"template <typename T>",
		"void read(T &x) {",
		"    x = 0;",
		"    char ch = getchar();",
		"    bool neg = false;",
		"",
		"    // 跳过非数字字符",
		"    while (ch < '0' || ch > '9') {",
		"        if (ch == '-') neg = true;",
		"        ch = getchar();",
		"    }",
		"",
		"    // 读取数字",
		"    while (ch >= '0' && ch <= '9') {",
		"        x = x * 10 + (ch - '0');",
		"        ch = getchar();",
		"    }",
		"",
		"    if (neg) x = -x;",
		"}",
		"",
		"// 快速写入函数",
		"template <typename T>",
		"void write(T x) {",
		"    if (x < 0) {",
		"        putchar('-');",
		"        x = -x;",
		"    }",
		"",
		"    if (x > 9) write(x / 10);",
		"    putchar(x % 10 + '0');",
		"}",
		"",
		"// 快速读入多个变量的宏定义",
		"#define read2(a, b) \\",
		"    read(a);        \\",
		"    read(b)",
		"#define read3(a, b, c) \\",
		"    read(a);           \\",
		"    read(b);           \\",
		"    read(c)",
		"#define read4(a, b, c, d) \\",
		"    read(a);              \\",
		"    read(b);              \\",
		"    read(c);              \\",
		"    read(d)",
		"",
		"// 输出换行",
		"inline void writeln() { putchar('\\n'); }",
		"",
		"// 输出带换行的数字",
		"template <typename T>",
		"void writeln(T x) {",
		"    write(x);",
		"    putchar('\\n');",
		"}",
		"",
		"// 输出空格分隔的数字",
		"template <typename T>",
		"void writesp(T x) {",
		"    write(x);",
		"    putchar(' ');",
		"}",
	})
}),

-- 00_Common\ModularArithmetic.h
s("00_common_modulararithmetic_h", {
	t({
		"using ll = long long;",
		"",
		"// 模运算工具类",
		"template <int MOD>",
		"struct ModInt {",
		"    int val;",
		"",
		"    ModInt() : val(0) {}",
		"    ModInt(int x) : val(norm(x)) {}",
		"    ModInt(ll x) : val(norm(x % MOD)) {}",
		"",
		"    // 数值规范化",
		"    int norm(ll x) {",
		"        if (x < 0) x += (-x + MOD - 1) / MOD * MOD;",
		"        if (x >= MOD) x %= MOD;",
		"        return x;",
		"    }",
		"",
		"    // 运算符重载",
		"    ModInt operator-() const { return ModInt(norm(MOD - val)); }",
		"    ModInt operator+(const ModInt& x) const { return ModInt(norm(val + x.val)); }",
		"    ModInt operator-(const ModInt& x) const { return ModInt(norm(val - x.val)); }",
		"    ModInt operator*(const ModInt& x) const { return ModInt(1LL * val * x.val); }",
		"    ModInt operator/(const ModInt& x) const { return *this * x.inv(); }",
		"",
		"    ModInt& operator+=(const ModInt& x) { return *this = *this + x; }",
		"    ModInt& operator-=(const ModInt& x) { return *this = *this - x; }",
		"    ModInt& operator*=(const ModInt& x) { return *this = *this * x; }",
		"    ModInt& operator/=(const ModInt& x) { return *this = *this / x; }",
		"",
		"    bool operator==(const ModInt& x) const { return val == x.val; }",
		"    bool operator!=(const ModInt& x) const { return val != x.val; }",
		"",
		"    // 快速幂",
		"    ModInt pow(ll n) const {",
		"        ModInt res = 1, a = *this;",
		"        while (n > 0) {",
		"            if (n & 1) res *= a;",
		"            a *= a;",
		"            n >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    // 模逆元(要求MOD为质数)",
		"    ModInt inv() const { return pow(MOD - 2); }",
		"",
		"    // 输入输出流重载",
		"    friend ostream& operator<<(ostream& os, const ModInt& x) { return os << x.val; }",
		"    friend istream& operator>>(istream& is, ModInt& x) {",
		"        int v;",
		"        is >> v;",
		"        x = ModInt(v);",
		"        return is;",
		"    }",
		"};",
		"",
		"using mint = ModInt<1000000007>;",
		"using mint2 = ModInt<998244353>;",
		"",
		"// 普通模运算函数",
		"template <typename T>",
		"T add_mod(T a, T b, T mod) {",
		"    return (a + b) % mod;",
		"}",
		"",
		"template <typename T>",
		"T sub_mod(T a, T b, T mod) {",
		"    return (a - b + mod) % mod;",
		"}",
		"",
		"template <typename T>",
		"T mul_mod(T a, T b, T mod) {",
		"    return a % mod * (b % mod) % mod;",
		"}",
		"",
		"template <typename T>",
		"T pow_mod(T a, T b, T mod) {",
		"    T res = 1;",
		"    a %= mod;",
		"    while (b > 0) {",
		"        if (b & 1) res = mul_mod(res, a, mod);",
		"        a = mul_mod(a, a, mod);",
		"        b >>= 1;",
		"    }",
		"    return res;",
		"}",
		"",
		"template <typename T>",
		"T inv_mod(T a, T mod) {",
		"    return pow_mod(a, mod - 2, mod);",
		"}",
		"",
		"// 扩展欧几里得算法求逆元",
		"template <typename T>",
		"T exgcd(T a, T b, T& x, T& y) {",
		"    if (b == 0) {",
		"        x = 1, y = 0;",
		"        return a;",
		"    }",
		"    T d = exgcd(b, a % b, y, x);",
		"    y -= a / b * x;",
		"    return d;",
		"}",
		"",
		"template <typename T>",
		"T inv_exgcd(T a, T mod) {",
		"    T x, y;",
		"    T d = exgcd(a, mod, x, y);",
		"    if (d != 1) return -1;  // 无逆元",
		"    return (x % mod + mod) % mod;",
		"}",
	})
}),

-- 00_Common\Random.h
s("00_common_random_h", {
	t({
		"// 随机数生成器",
		"struct Random {",
		"    mt19937 rng;",
		"",
		"    Random() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}",
		"    Random(uint32_t seed) : rng(seed) {}",
		"",
		"    // 生成 [l, r] 范围内的整数",
		"    int randint(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }",
		"",
		"    // 生成 [l, r] 范围内的长整数",
		"    long long randll(long long l, long long r) { return uniform_int_distribution<long long>(l, r)(rng); }",
		"",
		"    // 生成 [0, 1) 范围内的实数",
		"    double randdouble() { return uniform_real_distribution<double>(0.0, 1.0)(rng); }",
		"",
		"    // 生成 [l, r) 范围内的实数",
		"    double randdouble(double l, double r) { return uniform_real_distribution<double>(l, r)(rng); }",
		"",
		"    // 以概率p返回true，否则返回false",
		"    bool randbool(double p = 0.5) { return bernoulli_distribution(p)(rng); }",
		"",
		"    // 随机打乱数组",
		"    template <typename T>",
		"    void shuffle(vector<T>& v) {",
		"        shuffle(v.begin(), v.end(), rng);",
		"    }",
		"",
		"    // 从数组中随机选择k个元素",
		"    template <typename T>",
		"    vector<T> sample(const vector<T>& v, int k) {",
		"        vector<int> indices(v.size());",
		"        iota(indices.begin(), indices.end(), 0);",
		"        shuffle(indices);",
		"",
		"        vector<T> result;",
		"        for (int i = 0; i < min(k, (int)v.size()); i++) { result.push_back(v[indices[i]]); }",
		"        return result;",
		"    }",
		"",
		"    // 生成随机字符串",
		"    string randstring(int len, const string& chars = \"abcdefghijklmnopqrstuvwxyz\") {",
		"        string result;",
		"        for (int i = 0; i < len; i++) { result += chars[randint(0, chars.size() - 1)]; }",
		"        return result;",
		"    }",
		"",
		"    // 生成随机排列",
		"    vector<int> randperm(int n) {",
		"        vector<int> perm(n);",
		"        iota(perm.begin(), perm.end(), 0);",
		"        shuffle(perm);",
		"        return perm;",
		"    }",
		"",
		"    // 生成随机树",
		"    vector<pair<int, int>> randtree(int n) {",
		"        vector<pair<int, int>> edges;",
		"        vector<int> parent(n);",
		"        parent[0] = -1;",
		"",
		"        for (int i = 1; i < n; i++) {",
		"            parent[i] = randint(0, i - 1);",
		"            edges.push_back({parent[i], i});",
		"        }",
		"",
		"        return edges;",
		"    }",
		"",
		"    // 生成随机图",
		"    vector<pair<int, int>> randgraph(int n, int m) {",
		"        set<pair<int, int>> edge_set;",
		"        vector<pair<int, int>> edges;",
		"",
		"        while (edges.size() < m) {",
		"            int u = randint(0, n - 1);",
		"            int v = randint(0, n - 1);",
		"            if (u != v && edge_set.find({min(u, v), max(u, v)}) == edge_set.end()) {",
		"                edge_set.insert({min(u, v), max(u, v)});",
		"                edges.push_back({u, v});",
		"            }",
		"        }",
		"",
		"        return edges;",
		"    }",
		"};",
		"",
		"// 全局随机数生成器",
		"Random rnd;",
	})
}),

-- 00_Common\Timing.h
s("00_common_timing_h", {
	t({
		"// 计时器类",
		"struct Timer {",
		"    chrono::high_resolution_clock::time_point start_time;",
		"",
		"    Timer() { start(); }",
		"",
		"    void start() { start_time = chrono::high_resolution_clock::now(); }",
		"",
		"    // 获取经过的时间(秒)",
		"    double elapsed() const {",
		"        auto end_time = chrono::high_resolution_clock::now();",
		"        return chrono::duration<double>(end_time - start_time).count();",
		"    }",
		"",
		"    // 获取经过的时间(毫秒)",
		"    long long elapsed_ms() const {",
		"        auto end_time = chrono::high_resolution_clock::now();",
		"        return chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();",
		"    }",
		"",
		"    // 获取经过的时间(微秒)",
		"    long long elapsed_us() const {",
		"        auto end_time = chrono::high_resolution_clock::now();",
		"        return chrono::duration_cast<chrono::microseconds>(end_time - start_time).count();",
		"    }",
		"",
		"    // 获取经过的时间(纳秒)",
		"    long long elapsed_ns() const {",
		"        auto end_time = chrono::high_resolution_clock::now();",
		"        return chrono::duration_cast<chrono::nanoseconds>(end_time - start_time).count();",
		"    }",
		"",
		"    // 打印经过的时间(秒)",
		"    void print_elapsed(const string& msg = \"\") const {",
		"        if (!msg.empty()) cout << msg << \": \";",
		"        cout << elapsed() << \"s\" << endl;",
		"    }",
		"",
		"    // 打印经过的时间(毫秒)",
		"    void print_elapsed_ms(const string& msg = \"\") const {",
		"        if (!msg.empty()) cout << msg << \": \";",
		"        cout << elapsed_ms() << \"ms\" << endl;",
		"    }",
		"};",
		"",
		"// 计时函数执行时间",
		"template <typename Func>",
		"double time_func(Func&& func) {",
		"    Timer timer;",
		"    func();",
		"    return timer.elapsed();",
		"}",
		"",
		"template <typename Func>",
		"pair<double, decltype(Func())> time_func_with_result(Func&& func) {",
		"    Timer timer;",
		"    auto result = func();",
		"    return {timer.elapsed(), result};",
		"}",
		"",
		"// 自动计时RAII类",
		"struct AutoTimer {",
		"    Timer timer;",
		"    string name;",
		"",
		"    AutoTimer(const string& n = \"\") : name(n) {}",
		"",
		"    ~AutoTimer() {",
		"        if (name.empty()) {",
		"            cout << \"Elapsed: \" << timer.elapsed() << \"s\" << endl;",
		"        } else {",
		"            cout << name << \": \" << timer.elapsed() << \"s\" << endl;",
		"        }",
		"    }",
		"};",
		"",
		"// 性能测试",
		"template <typename Func>",
		"void benchmark(Func&& func, int iterations = 1000, const string& name = \"\") {",
		"    vector<double> times;",
		"    times.reserve(iterations);",
		"",
		"    for (int i = 0; i < iterations; i++) {",
		"        Timer timer;",
		"        func();",
		"        times.push_back(timer.elapsed());",
		"    }",
		"",
		"    sort(times.begin(), times.end());",
		"",
		"    double sum = accumulate(times.begin(), times.end(), 0.0);",
		"    double avg = sum / iterations;",
		"    double median = times[iterations / 2];",
		"    double min_time = times[0];",
		"    double max_time = times[iterations - 1];",
		"",
		"    if (!name.empty()) cout << name << \" \";",
		"    cout << \"Benchmark Results:\" << endl;",
		"    cout << \"  Iterations: \" << iterations << endl;",
		"    cout << \"  Average: \" << avg << \"s\" << endl;",
		"    cout << \"  Median: \" << median << \"s\" << endl;",
		"    cout << \"  Min: \" << min_time << \"s\" << endl;",
		"    cout << \"  Max: \" << max_time << \"s\" << endl;",
		"}",
		"",
		"// 代码块计时宏",
		"#define TIME_BLOCK(name) AutoTimer _timer(name)",
	})
}),

-- 00_Common\i128.h
s("00_common_i128_h", {
	t({
		"using i128 = __int128;",
		"",
		"// 128位整数输出",
		"ostream& operator<<(ostream& os, i128 n) {",
		"    if (n == 0) return os << 0;",
		"    if (n < 0) {",
		"        os << '-';",
		"        n = -n;",
		"    }",
		"    string s;",
		"    while (n > 0) {",
		"        s += char('0' + n % 10);",
		"        n /= 10;",
		"    }",
		"    reverse(s.begin(), s.end());",
		"    return os << s;",
		"}",
		"",
		"// 128位整数输入",
		"istream& operator>>(istream& is, i128& n) {",
		"    string s;",
		"    is >> s;",
		"    n = 0;",
		"    bool neg = false;",
		"    int start = 0;",
		"    if (s[0] == '-') {",
		"        neg = true;",
		"        start = 1;",
		"    }",
		"    for (int i = start; i < s.size(); i++) { n = n * 10 + (s[i] - '0'); }",
		"    if (neg) n = -n;",
		"    return is;",
		"}",
		"",
		"// 字符串转128位整数",
		"i128 toi128(const string& s) {",
		"    i128 n = 0;",
		"    bool neg = false;",
		"    int start = 0;",
		"    if (s[0] == '-') {",
		"        neg = true;",
		"        start = 1;",
		"    }",
		"    for (int i = start; i < s.size(); i++) { n = n * 10 + (s[i] - '0'); }",
		"    if (neg) n = -n;",
		"    return n;",
		"}",
		"",
		"// 128位整数开方",
		"i128 sqrti128(i128 n) {",
		"    if (n < 0) return -1;",
		"    i128 lo = 0, hi = 2e18;",
		"    while (lo < hi) {",
		"        i128 mid = (lo + hi + 1) / 2;",
		"        if (mid <= n / mid) {",
		"            lo = mid;",
		"        } else {",
		"            hi = mid - 1;",
		"        }",
		"    }",
		"    return lo;",
		"}",
		"",
		"// 128位整数最大公约数",
		"i128 gcd(i128 a, i128 b) { return b ? gcd(b, a % b) : a; }",
		"",
		"// 128位整数最小公倍数",
		"i128 lcm(i128 a, i128 b) { return a / gcd(a, b) * b; }",
		"",
		"// 128位整数快速幂",
		"i128 qpow(i128 a, i128 b) {",
		"    i128 res = 1;",
		"    while (b > 0) {",
		"        if (b & 1) res *= a;",
		"        a *= a;",
		"        b >>= 1;",
		"    }",
		"    return res;",
		"}",
		"",
		"// 128位整数模快速幂",
		"i128 qpow(i128 a, i128 b, i128 mod) {",
		"    i128 res = 1;",
		"    a %= mod;",
		"    while (b > 0) {",
		"        if (b & 1) res = res * a % mod;",
		"        a = a * a % mod;",
		"        b >>= 1;",
		"    }",
		"    return res;",
		"}",
	})
}),

-- 01_Data_Structures\Advanced\KDTree.h
s("01_data_structures_advanced_kdtree_h", {
	t({
		"// K-D树模板，支持K维空间的最近邻查询和范围查询",
		"template <int K>",
		"struct KDTree {",
		"    // K维点结构",
		"    struct Point {",
		"        int dim[K];  // K维坐标",
		"        int id;      // 点的标识符",
		"",
		"        Point() : id(-1) { memset(dim, 0, sizeof(dim)); }",
		"",
		"        Point(const vector<int>& coords, int _id = -1) : id(_id) {",
		"            for (int i = 0; i < K; i++) { dim[i] = coords[i]; }",
		"        }",
		"    };",
		"",
		"    // K-D树节点结构",
		"    struct Node {",
		"        Point pt;                        // 节点存储的点",
		"        int left, right;                 // 左右子树索引",
		"        int min_coord[K], max_coord[K];  // 子树边界范围",
		"",
		"        Node() : left(-1), right(-1) {}",
		"    };",
		"",
		"    vector<Node> tree;   // 树节点数组",
		"    int root, node_cnt;  // 根节点索引和节点计数",
		"",
		"    KDTree() : root(-1), node_cnt(0) {}",
		"",
		"    // 构建K-D树",
		"    int build(vector<Point>& points, int l, int r, int depth = 0) {",
		"        if (l > r) return -1;",
		"",
		"        int cur = node_cnt++;",
		"        tree.resize(node_cnt);",
		"",
		"        // 选择当前层的分割维度",
		"        int dim = depth % K;",
		"",
		"        // 按当前维度排序并选择中位数",
		"        nth_element(points.begin() + l,",
		"                    points.begin() + (l + r) / 2,",
		"                    points.begin() + r + 1,",
		"                    [dim](const Point& a, const Point& b) { return a.dim[dim] < b.dim[dim]; });",
		"",
		"        int mid = (l + r) / 2;",
		"        tree[cur].pt = points[mid];",
		"",
		"        // 初始化当前节点的边界范围",
		"        for (int i = 0; i < K; i++) { tree[cur].min_coord[i] = tree[cur].max_coord[i] = points[mid].dim[i]; }",
		"",
		"        // 递归构建左右子树",
		"        tree[cur].left = build(points, l, mid - 1, depth + 1);",
		"        tree[cur].right = build(points, mid + 1, r, depth + 1);",
		"",
		"        // 更新边界范围",
		"        if (tree[cur].left != -1) {",
		"            for (int i = 0; i < K; i++) {",
		"                tree[cur].min_coord[i] = min(tree[cur].min_coord[i], tree[tree[cur].left].min_coord[i]);",
		"                tree[cur].max_coord[i] = max(tree[cur].max_coord[i], tree[tree[cur].left].max_coord[i]);",
		"            }",
		"        }",
		"        if (tree[cur].right != -1) {",
		"            for (int i = 0; i < K; i++) {",
		"                tree[cur].min_coord[i] = min(tree[cur].min_coord[i], tree[tree[cur].right].min_coord[i]);",
		"                tree[cur].max_coord[i] = max(tree[cur].max_coord[i], tree[tree[cur].right].max_coord[i]);",
		"            }",
		"        }",
		"",
		"        return cur;",
		"    }",
		"",
		"    // 计算两点间欧几里得距离",
		"    double distance(const Point& a, const Point& b) {",
		"        double sum = 0;",
		"        for (int i = 0; i < K; i++) { sum += (a.dim[i] - b.dim[i]) * (a.dim[i] - b.dim[i]); }",
		"        return sqrt(sum);",
		"    }",
		"",
		"    // 计算点到矩形区域的最小距离",
		"    double min_distance_to_rect(const Point& pt, int node) {",
		"        double sum = 0;",
		"        for (int i = 0; i < K; i++) {",
		"            if (pt.dim[i] < tree[node].min_coord[i]) {",
		"                sum += (tree[node].min_coord[i] - pt.dim[i]) * (tree[node].min_coord[i] - pt.dim[i]);",
		"            } else if (pt.dim[i] > tree[node].max_coord[i]) {",
		"                sum += (pt.dim[i] - tree[node].max_coord[i]) * (pt.dim[i] - tree[node].max_coord[i]);",
		"            }",
		"        }",
		"        return sqrt(sum);",
		"    }",
		"",
		"    // 最近邻查询的递归函数",
		"    void nearest_neighbor(int node, const Point& target, Point& best, double& best_dist) {",
		"        if (node == -1) return;",
		"",
		"        // 检查当前节点是否更近",
		"        double curr_dist = distance(tree[node].pt, target);",
		"        if (curr_dist < best_dist) {",
		"            best_dist = curr_dist;",
		"            best = tree[node].pt;",
		"        }",
		"",
		"        // 计算当前节点的深度(分割维度)",
		"        int depth = 0;",
		"        int cur = root;",
		"        while (cur != node) {",
		"            if (target.dim[depth % K] < tree[cur].pt.dim[depth % K]) {",
		"                cur = tree[cur].left;",
		"            } else {",
		"                cur = tree[cur].right;",
		"            }",
		"            depth++;",
		"        }",
		"",
		"        int split_dim = depth % K;",
		"        int first, second;",
		"",
		"        // 根据分割维度确定搜索顺序",
		"        if (target.dim[split_dim] < tree[node].pt.dim[split_dim]) {",
		"            first = tree[node].left;",
		"            second = tree[node].right;",
		"        } else {",
		"            first = tree[node].right;",
		"            second = tree[node].left;",
		"        }",
		"",
		"        // 优先搜索可能包含最近点的子树",
		"        nearest_neighbor(first, target, best, best_dist);",
		"",
		"        // 如果另一个子树可能包含更近的点，则继续搜索",
		"        if (second != -1 && min_distance_to_rect(target, second) < best_dist) {",
		"            nearest_neighbor(second, target, best, best_dist);",
		"        }",
		"    }",
		"",
		"    // 查找最近邻点",
		"    Point find_nearest(const Point& target) {",
		"        Point best;",
		"        double best_dist = 1e18;",
		"        nearest_neighbor(root, target, best, best_dist);",
		"        return best;",
		"    }",
		"",
		"    // 范围查询的递归函数",
		"    void range_query(int node, const vector<int>& min_range, const vector<int>& max_range, vector<Point>& result) {",
		"        if (node == -1) return;",
		"",
		"        // 检查当前节点是否在查询范围内",
		"        bool in_range = true;",
		"        for (int i = 0; i < K; i++) {",
		"            if (tree[node].pt.dim[i] < min_range[i] || tree[node].pt.dim[i] > max_range[i]) {",
		"                in_range = false;",
		"                break;",
		"            }",
		"        }",
		"        if (in_range) { result.push_back(tree[node].pt); }",
		"",
		"        // 检查左右子树是否与查询范围相交",
		"        bool left_possible = true, right_possible = true;",
		"        for (int i = 0; i < K; i++) {",
		"            if (tree[node].left != -1) {",
		"                if (tree[tree[node].left].max_coord[i] < min_range[i] ||",
		"                    tree[tree[node].left].min_coord[i] > max_range[i]) {",
		"                    left_possible = false;",
		"                }",
		"            }",
		"            if (tree[node].right != -1) {",
		"                if (tree[tree[node].right].max_coord[i] < min_range[i] ||",
		"                    tree[tree[node].right].min_coord[i] > max_range[i]) {",
		"                    right_possible = false;",
		"                }",
		"            }",
		"        }",
		"",
		"        // 递归搜索可能相交的子树",
		"        if (left_possible) range_query(tree[node].left, min_range, max_range, result);",
		"        if (right_possible) range_query(tree[node].right, min_range, max_range, result);",
		"    }",
		"",
		"    // 范围查询",
		"    vector<Point> range_search(const vector<int>& min_range, const vector<int>& max_range) {",
		"        vector<Point> result;",
		"        range_query(root, min_range, max_range, result);",
		"        return result;",
		"    }",
		"",
		"    // 构建K-D树的公共接口",
		"    void build(vector<Point> points) {",
		"        tree.clear();",
		"        node_cnt = 0;",
		"        if (!points.empty()) { root = build(points, 0, points.size() - 1); }",
		"    }",
		"};",
	})
}),

-- 01_Data_Structures\Advanced\ODT.h
s("01_data_structures_advanced_odt_h", {
	t({
		"// 颜色段树(ODT/珂朵莉树)，用于处理区间赋值、区间加、区间第k小等操作",
		"struct ODT {",
		"    // 节点结构，表示一个颜色段[l, r]，值为val",
		"    struct Node {",
		"        int l, r;               // 区间左右端点",
		"        mutable long long val;  // 区间的值(mutable允许在set中修改)",
		"",
		"        Node(int l, int r, long long val) : l(l), r(r), val(val) {}",
		"",
		"        // 按左端点排序",
		"        bool operator<(const Node& o) const { return l < o.l; }",
		"    };",
		"",
		"    set<Node> tree;  // 用set维护所有颜色段",
		"",
		"    ODT() {}",
		"",
		"    // 分裂操作：在位置pos处分裂区间，返回[pos, r]区间的迭代器",
		"    set<Node>::iterator split(int pos) {",
		"        auto it = tree.lower_bound(Node(pos, -1, -1));",
		"        if (it != tree.end() && it->l == pos) { return it; }",
		"",
		"        --it;  // 找到包含pos的区间",
		"        int l = it->l, r = it->r;",
		"        long long val = it->val;",
		"        tree.erase(it);",
		"",
		"        // 分裂成[l, pos-1]和[pos, r]两个区间",
		"        tree.insert(Node(l, pos - 1, val));",
		"        return tree.insert(Node(pos, r, val)).first;",
		"    }",
		"",
		"    // 区间赋值：将[l, r]区间的值都设为val",
		"    void assign(int l, int r, long long val) {",
		"        auto itr = split(r + 1), itl = split(l);",
		"        tree.erase(itl, itr);          // 删除[l, r]范围内的所有区间",
		"        tree.insert(Node(l, r, val));  // 插入新的统一区间",
		"    }",
		"",
		"    // 区间加法：将[l, r]区间的值都加上val",
		"    void add(int l, int r, long long val) {",
		"        auto itr = split(r + 1), itl = split(l);",
		"        for (; itl != itr; ++itl) { itl->val += val; }",
		"    }",
		"",
		"    // 查询[l, r]区间第k小的值",
		"    long long kth(int l, int r, int k) {",
		"        auto itr = split(r + 1), itl = split(l);",
		"        vector<pair<long long, int>> vp;  // {值, 长度}",
		"",
		"        for (; itl != itr; ++itl) { vp.push_back({itl->val, itl->r - itl->l + 1}); }",
		"",
		"        sort(vp.begin(), vp.end());",
		"        for (auto& p : vp) {",
		"            k -= p.second;",
		"            if (k <= 0) return p.first;",
		"        }",
		"        return -1;  // 不存在第k小",
		"    }",
		"",
		"    // 计算[l, r]区间内sum(val^x) mod y",
		"    long long sum_pow(int l, int r, long long x, long long y) {",
		"        auto itr = split(r + 1), itl = split(l);",
		"        long long res = 0;",
		"        for (; itl != itr; ++itl) { res = (res + (long long)(itl->r - itl->l + 1) * pow_mod(itl->val, x, y)) % y; }",
		"        return res;",
		"    }",
		"",
		"    // 快速幂取模",
		"    long long pow_mod(long long a, long long b, long long mod) {",
		"        long long res = 1;",
		"        a %= mod;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % mod;",
		"            a = a * a % mod;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    // 插入新区间(初始化时使用)",
		"    void insert(int l, int r, long long val) { tree.insert(Node(l, r, val)); }",
		"",
		"    // 调试输出所有区间",
		"    void print() {",
		"        for (auto& node : tree) { cout << \"[\" << node.l << \", \" << node.r << \"] = \" << node.val << \"\\n\"; }",
		"    }",
		"};",
		"// odt.add(l, r, val);     // 区间加法",
		"// long long kth_val = odt.kth(l, r, k);  // 区间第k小",
	})
}),

-- 01_Data_Structures\Hashing\StringHash.h
s("01_data_structures_hashing_stringhash_h", {
	t({
		"using ll = long long;",
		"using ull = unsigned long long;",
		"",
		"/**",
		" * 字符串哈希模板",
		" * 功能特性:",
		" * - 双哈希防止冲突",
		" * - 正向和反向哈希计算",
		" * - 回文检测和分析",
		" * - 周期计算",
		" * 时间复杂度: O(n) 预处理, O(1) 查询",
		" */",
		"",
		"namespace StringHashing {",
		"",
		"namespace Detail {",
		"mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
		"",
		"// 生成随机哈希基数",
		"ull generate_base() {",
		"    uniform_int_distribution<ull> distrib(257, ULLONG_MAX);",
		"    ull base = distrib(rng);",
		"    return base | 1;  // 确保为奇数",
		"}",
		"}  // namespace Detail",
		"",
		"struct Hasher {",
		"    int n;               // 字符串长度",
		"    string str;          // 原始字符串",
		"    ull P1, P2;          // 两个哈希基数",
		"    vector<ull> p1, p2;  // 基数的幂次",
		"    vector<ull> f1, f2;  // 正向哈希值",
		"    vector<ull> b1, b2;  // 反向哈希值",
		"",
		"    Hasher(const string& s) : n(s.size()), str(s) {",
		"        // 生成两个不同的随机基数",
		"        P1 = Detail::generate_base();",
		"        P2 = Detail::generate_base();",
		"        while (P2 == P1) P2 = Detail::generate_base();",
		"",
		"        // 初始化向量",
		"        p1.resize(n + 1);",
		"        p2.resize(n + 1);",
		"        f1.resize(n + 1, 0);",
		"        f2.resize(n + 1, 0);",
		"        b1.resize(n + 1, 0);",
		"        b2.resize(n + 1, 0);",
		"",
		"        // 预计算基数的幂次",
		"        p1[0] = p2[0] = 1;",
		"        for (int i = 0; i < n; ++i) {",
		"            p1[i + 1] = p1[i] * P1;",
		"            p2[i + 1] = p2[i] * P2;",
		"        }",
		"",
		"        // 计算正向哈希值",
		"        for (int i = 0; i < n; ++i) {",
		"            ull val = (unsigned char)s[i];",
		"            f1[i + 1] = f1[i] * P1 + val;",
		"            f2[i + 1] = f2[i] * P2 + val;",
		"        }",
		"",
		"        // 计算反向哈希值",
		"        for (int i = 0; i < n; ++i) {",
		"            ull val = (unsigned char)s[n - 1 - i];",
		"            b1[i + 1] = b1[i] * P1 + val;",
		"            b2[i + 1] = b2[i] * P2 + val;",
		"        }",
		"    }",
		"",
		"    // 获取子串 s[l...r] 的正向哈希值 (0索引, 包含边界)",
		"    pair<ull, ull> get_forward_hash(int l, int r) const {",
		"        if (l > r || l < 0 || r >= n) return {0, 0};",
		"        ull val1 = f1[r + 1] - f1[l] * p1[r - l + 1];",
		"        ull val2 = f2[r + 1] - f2[l] * p2[r - l + 1];",
		"        return {val1, val2};",
		"    }",
		"",
		"    // 获取子串 s[l...r] 的反向哈希值 (0索引, 包含边界)",
		"    pair<ull, ull> get_backward_hash(int l, int r) const {",
		"        if (l > r || l < 0 || r >= n) return {0, 0};",
		"        int rev_l = n - 1 - r;",
		"        int rev_r = n - 1 - l;",
		"        ull val1 = b1[rev_r + 1] - b1[rev_l] * p1[r - l + 1];",
		"        ull val2 = b2[rev_r + 1] - b2[rev_l] * p2[r - l + 1];",
		"        return {val1, val2};",
		"    }",
		"",
		"    // 检查子串 s[l...r] 是否为回文",
		"    bool is_palindrome(int l, int r) const {",
		"        if (l > r) return true;",
		"        if (l < 0 || r >= n) return false;",
		"        return get_forward_hash(l, r) == get_backward_hash(l, r);",
		"    }",
		"",
		"    // 找到以 center_idx 为中心的最长奇数长度回文的半径",
		"    int get_odd_palindrome_radius(int center_idx) const {",
		"        int low = 0, high = min(center_idx, n - 1 - center_idx);",
		"        int ans = 0;",
		"        while (low <= high) {",
		"            int mid = low + (high - low) / 2;",
		"            if (is_palindrome(center_idx - mid, center_idx + mid)) {",
		"                ans = mid;",
		"                low = mid + 1;",
		"            } else {",
		"                high = mid - 1;",
		"            }",
		"        }",
		"        return ans;",
		"    }",
		"",
		"    // 找到以 left_center_idx 和 left_center_idx+1 之间为中心的最长偶数长度回文的半径",
		"    int get_even_palindrome_radius(int left_center_idx) const {",
		"        if (left_center_idx + 1 >= n) return 0;",
		"        int low = 1, high = min(left_center_idx + 1, n - (left_center_idx + 1));",
		"        int ans = 0;",
		"        while (low <= high) {",
		"            int mid = low + (high - low) / 2;",
		"            if (is_palindrome(left_center_idx - mid + 1, left_center_idx + mid)) {",
		"                ans = mid;",
		"                low = mid + 1;",
		"            } else {",
		"                high = mid - 1;",
		"            }",
		"        }",
		"        return ans;",
		"    }",
		"",
		"    // 找到最长回文子串，返回 {长度, 起始索引}",
		"    pair<int, int> get_longest_palindrome() const {",
		"        if (n == 0) return {0, 0};",
		"        int max_len = 1, start_pos = 0;",
		"",
		"        // 检查奇数长度回文",
		"        for (int i = 0; i < n; ++i) {",
		"            int radius = get_odd_palindrome_radius(i);",
		"            int len = 2 * radius + 1;",
		"            if (len > max_len) {",
		"                max_len = len;",
		"                start_pos = i - radius;",
		"            }",
		"        }",
		"",
		"        // 检查偶数长度回文",
		"        for (int i = 0; i < n - 1; ++i) {",
		"            int radius = get_even_palindrome_radius(i);",
		"            int len = 2 * radius;",
		"            if (len > max_len) {",
		"                max_len = len;",
		"                start_pos = i - radius + 1;",
		"            }",
		"        }",
		"",
		"        return {max_len, start_pos};",
		"    }",
		"};",
		"",
		"}  // namespace StringHashing",
		"",
		"// 计算回文子串的总数",
		"ll count_palindromic_substrings(const string& s) {",
		"    if (s.empty()) return 0;",
		"",
		"    StringHashing::Hasher hasher(s);",
		"    ll count = 0;",
		"",
		"    // 计算奇数长度回文",
		"    for (int i = 0; i < hasher.n; ++i) {",
		"        int radius = hasher.get_odd_palindrome_radius(i);",
		"        count += (radius + 1);",
		"    }",
		"",
		"    // 计算偶数长度回文",
		"    for (int i = 0; i < hasher.n - 1; ++i) {",
		"        int radius = hasher.get_even_palindrome_radius(i);",
		"        count += radius;",
		"    }",
		"",
		"    return count;",
		"}",
		"",
		"// 找到字符串的最小周期",
		"int minimal_period(const string& s) {",
		"    if (s.empty()) return 0;",
		"",
		"    StringHashing::Hasher hasher(s);",
		"    int n = hasher.n;",
		"",
		"    for (int period = 1; period < n; ++period) {",
		"        if (hasher.get_forward_hash(0, n - 1 - period) == hasher.get_forward_hash(period, n - 1)) { return period; }",
		"    }",
		"",
		"    return n;  // 字符串没有小于自身的周期",
		"}",
	})
}),

-- 01_Data_Structures\Linear\Deque.h
s("01_data_structures_linear_deque_h", {
	t({
		"/**",
		" * 双端队列数据结构模板",
		" * 功能：",
		" * - 基础双端队列操作封装",
		" * - 滑动窗口最小值/最大值",
		" * - 单调队列应用",
		" * 时间复杂度：所有操作均摊O(1)",
		" */",
		"",
		"// 基础双端队列应用封装",
		"template <typename T>",
		"struct DequeApp {",
		"    deque<T> dq;",
		"",
		"    // 基础操作",
		"    void push_front(const T& val) { dq.push_front(val); }",
		"    void push_back(const T& val) { dq.push_back(val); }",
		"    void pop_front() {",
		"        if (!dq.empty()) dq.pop_front();",
		"    }",
		"    void pop_back() {",
		"        if (!dq.empty()) dq.pop_back();",
		"    }",
		"",
		"    T front() const { return dq.front(); }",
		"    T back() const { return dq.back(); }",
		"    T operator[](int idx) const { return dq[idx]; }",
		"",
		"    int size() const { return dq.size(); }",
		"    bool empty() const { return dq.empty(); }",
		"    void clear() { dq.clear(); }",
		"",
		"    // 维护固定大小的滑动窗口",
		"    void maintain_window(int window_size) {",
		"        while (dq.size() > window_size) { dq.pop_front(); }",
		"    }",
		"",
		"    // 获取极值（假设队列维护了有序性）",
		"    T get_min() const { return dq.front(); }",
		"    T get_max() const { return dq.back(); }",
		"};",
		"",
		"// 使用单调队列的滑动窗口最小值",
		"template <typename T>",
		"struct SlidingWindowMin {",
		"    deque<pair<T, int>> dq;  // (值, 索引)",
		"    int window_size;",
		"",
		"    SlidingWindowMin(int ws) : window_size(ws) {}",
		"",
		"    void push(const T& val, int idx) {",
		"        // 移除窗口外的元素",
		"        while (!dq.empty() && dq.front().second <= idx - window_size) { dq.pop_front(); }",
		"",
		"        // 维护单调性（递增序列）",
		"        while (!dq.empty() && dq.back().first >= val) { dq.pop_back(); }",
		"",
		"        dq.push_back({val, idx});",
		"    }",
		"",
		"    T get_min() const { return dq.empty() ? T{} : dq.front().first; }",
		"",
		"    bool empty() const { return dq.empty(); }",
		"    void clear() { dq.clear(); }",
		"};",
		"",
		"// 使用单调队列的滑动窗口最大值",
		"template <typename T>",
		"struct SlidingWindowMax {",
		"    deque<pair<T, int>> dq;  // (值, 索引)",
		"    int window_size;",
		"",
		"    SlidingWindowMax(int ws) : window_size(ws) {}",
		"",
		"    void push(const T& val, int idx) {",
		"        // 移除窗口外的元素",
		"        while (!dq.empty() && dq.front().second <= idx - window_size) { dq.pop_front(); }",
		"",
		"        // 维护单调性（递减序列）",
		"        while (!dq.empty() && dq.back().first <= val) { dq.pop_back(); }",
		"",
		"        dq.push_back({val, idx});",
		"    }",
		"",
		"    T get_max() const { return dq.empty() ? T{} : dq.front().first; }",
		"",
		"    bool empty() const { return dq.empty(); }",
		"    void clear() { dq.clear(); }",
		"};",
	})
}),

-- 01_Data_Structures\Linear\MonotonicQueue.h
s("01_data_structures_linear_monotonicqueue_h", {
	t({
		"/**",
		" * 单调队列模板",
		" * 功能特性:",
		" * - 维护单调性质（递增/递减）",
		" * - 滑动窗口最小值/最大值查询",
		" * - 高效的窗口操作",
		" * 时间复杂度: 所有操作均摊 O(1)",
		" */",
		"",
		"template <typename T>",
		"struct MonotonicQueue {",
		"    deque<pair<T, int>> dq;  // (值, 索引)",
		"",
		"    // 维护滑动窗口最小值的单调队列",
		"    void push_min(const T& val, int idx) {",
		"        // 移除 >= 当前值的元素以维护递增顺序",
		"        while (!dq.empty() && dq.back().first >= val) { dq.pop_back(); }",
		"        dq.push_back({val, idx});",
		"    }",
		"",
		"    // 维护滑动窗口最大值的单调队列",
		"    void push_max(const T& val, int idx) {",
		"        // 移除 <= 当前值的元素以维护递减顺序",
		"        while (!dq.empty() && dq.back().first <= val) { dq.pop_back(); }",
		"        dq.push_back({val, idx});",
		"    }",
		"",
		"    // 移除窗口外的过期元素",
		"    void pop_expired(int left_bound) {",
		"        while (!dq.empty() && dq.front().second < left_bound) { dq.pop_front(); }",
		"    }",
		"",
		"    // 获取当前窗口的极值",
		"    T front_value() const { return dq.empty() ? T{} : dq.front().first; }",
		"",
		"    // 获取极值对应的索引",
		"    int front_index() const { return dq.empty() ? -1 : dq.front().second; }",
		"",
		"    // 检查队列是否为空",
		"    bool empty() const { return dq.empty(); }",
		"",
		"    // 清空队列",
		"    void clear() { dq.clear(); }",
		"};",
		"",
		"// 解决滑动窗口最小值问题",
		"template <typename T>",
		"vector<T> sliding_window_minimum(const vector<T>& arr, int k) {",
		"    vector<T> result;",
		"    MonotonicQueue<T> mq;",
		"",
		"    for (int i = 0; i < arr.size(); i++) {",
		"        mq.push_min(arr[i], i);     // 添加当前元素到单调队列",
		"        mq.pop_expired(i - k + 1);  // 移除窗口外的元素",
		"",
		"        if (i >= k - 1) {  // 当窗口大小达到k时开始记录结果",
		"            result.push_back(mq.front_value());",
		"        }",
		"    }",
		"    return result;",
		"}",
		"",
		"// 解决滑动窗口最大值问题",
		"template <typename T>",
		"vector<T> sliding_window_maximum(const vector<T>& arr, int k) {",
		"    vector<T> result;",
		"    MonotonicQueue<T> mq;",
		"",
		"    for (int i = 0; i < arr.size(); i++) {",
		"        mq.push_max(arr[i], i);     // 添加当前元素到单调队列",
		"        mq.pop_expired(i - k + 1);  // 移除窗口外的元素",
		"",
		"        if (i >= k - 1) {  // 当窗口大小达到k时开始记录结果",
		"            result.push_back(mq.front_value());",
		"        }",
		"    }",
		"    return result;",
		"}",
		"",
		"// 使用单调栈求直方图中的最大矩形面积",
		"long long largest_rectangle_histogram(const vector<int>& heights) {",
		"    vector<int> h = heights;",
		"    h.push_back(0);  // 添加哨兵元素，确保所有柱子都被处理",
		"",
		"    deque<int> stk;  // 单调栈（存储递增高度的索引）",
		"    long long max_area = 0;",
		"",
		"    for (int i = 0; i < h.size(); i++) {",
		"        // 当前高度小于栈顶高度时，计算以栈顶为高的矩形面积",
		"        while (!stk.empty() && h[stk.back()] > h[i]) {",
		"            int height = h[stk.back()];  // 矩形的高度",
		"            stk.pop_back();",
		"            // 计算矩形的宽度：右边界到左边界的距离",
		"            int width = stk.empty() ? i : i - stk.back() - 1;",
		"            max_area = max(max_area, (long long)height * width);",
		"        }",
		"        stk.push_back(i);  // 将当前索引入栈",
		"    }",
		"",
		"    return max_area;",
		"}",
	})
}),

-- 01_Data_Structures\Linear\SparseTable.h
s("01_data_structures_linear_sparsetable_h", {
	t({
		"/**",
		" * 稀疏表模板",
		" * 功能特性:",
		" * - 区间最小值/最大值查询 (RMQ)",
		" * - 区间最大公约数/最小公倍数查询",
		" * - 支持幂等操作",
		" * 时间复杂度: O(n log n) 预处理, O(1) 查询",
		" */",
		"",
		"template <typename T>",
		"struct SparseTable {",
		"    vector<vector<T>> st;  // 稀疏表，st[k][i] 表示从位置 i 开始长度为 2^k 的区间的值",
		"    vector<int> lg;        // 预计算的对数值，lg[i] = floor(log2(i))",
		"    int n;                 // 数组长度",
		"    function<T(T, T)> op;  // 操作函数（必须是幂等且结合的）",
		"",
		"    SparseTable() {}",
		"",
		"    // op 应该是幂等结合操作（如 min, max, gcd, lcm）",
		"    SparseTable(const vector<T>& arr, function<T(T, T)> operation) : n(arr.size()), op(operation) { build(arr); }",
		"",
		"    void build(const vector<T>& arr) {",
		"        // 预计算对数值",
		"        lg.resize(n + 1);",
		"        lg[1] = 0;",
		"        for (int i = 2; i <= n; i++) { lg[i] = lg[i / 2] + 1; }",
		"",
		"        int max_log = lg[n] + 1;",
		"        st.assign(max_log, vector<T>(n));",
		"",
		"        // 初始化第一层（长度为1的区间）",
		"        for (int i = 0; i < n; i++) { st[0][i] = arr[i]; }",
		"",
		"        // 构建稀疏表",
		"        for (int k = 1; k < max_log; k++) {",
		"            for (int i = 0; i + (1 << k) <= n; i++) {",
		"                // st[k][i] = op(前半段, 后半段)",
		"                st[k][i] = op(st[k - 1][i], st[k - 1][i + (1 << (k - 1))]);",
		"            }",
		"        }",
		"    }",
		"",
		"    // 查询区间 [l, r] (0索引，包含边界)",
		"    T query(int l, int r) {",
		"        if (l > r) return T{};",
		"        int k = lg[r - l + 1];  // 找到最大的 k 使得 2^k <= 区间长度",
		"        // 利用幂等性质：区间可以用两个重叠的子区间覆盖",
		"        return op(st[k][l], st[k][r - (1 << k) + 1]);",
		"    }",
		"};",
		"",
		"// 区间最小值查询的特化版本",
		"template <typename T>",
		"struct RMQ {",
		"    SparseTable<T> st;",
		"",
		"    RMQ(const vector<T>& arr) {",
		"        st = SparseTable<T>(arr, [](T a, T b) { return min(a, b); });",
		"    }",
		"",
		"    T query_min(int l, int r) { return st.query(l, r); }",
		"};",
		"",
		"// 区间最大值查询的特化版本",
		"template <typename T>",
		"struct RMaxQ {",
		"    SparseTable<T> st;",
		"",
		"    RMaxQ(const vector<T>& arr) {",
		"        st = SparseTable<T>(arr, [](T a, T b) { return max(a, b); });",
		"    }",
		"",
		"    T query_max(int l, int r) { return st.query(l, r); }",
		"};",
		"",
		"// 区间最大公约数查询的特化版本",
		"struct RGCDQ {",
		"    SparseTable<long long> st;",
		"",
		"    RGCDQ(const vector<long long>& arr) {",
		"        st = SparseTable<long long>(arr, [](long long a, long long b) { return gcd(a, b); });",
		"    }",
		"",
		"    long long query_gcd(int l, int r) { return st.query(l, r); }",
		"};",
		"",
		"// 区间最小公倍数查询的特化版本（注意溢出问题）",
		"struct RLCMQ {",
		"    SparseTable<long long> st;",
		"",
		"    RLCMQ(const vector<long long>& arr) {",
		"        st = SparseTable<long long>(arr, [](long long a, long long b) {",
		"            return (a / gcd(a, b)) * b;  // 先除后乘避免溢出",
		"        });",
		"    }",
		"",
		"    long long query_lcm(int l, int r) { return st.query(l, r); }",
		"};",
	})
}),

-- 01_Data_Structures\Linear\Stack.h
s("01_data_structures_linear_stack_h", {
	t({
		"/**",
		" * 基于栈的算法模板",
		" * 功能特性:",
		" * - 单调栈应用",
		" * - 寻找下一个更大/更小元素",
		" * - 直方图中的最大矩形",
		" * - 有效括号问题",
		" * 时间复杂度: 大多数操作 O(n)",
		" */",
		"",
		"template <typename T>",
		"struct MonotonicStack {",
		"    stack<pair<T, int>> st;  // (值, 索引)",
		"",
		"    // 寻找每个位置的下一个更大元素",
		"    vector<int> next_greater(const vector<T>& arr) {",
		"        vector<int> result(arr.size(), -1);",
		"        stack<int> st;",
		"",
		"        for (int i = 0; i < arr.size(); i++) {",
		"            while (!st.empty() && arr[st.top()] < arr[i]) {",
		"                result[st.top()] = i;",
		"                st.pop();",
		"            }",
		"            st.push(i);",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 寻找每个位置的下一个更小元素",
		"    vector<int> next_smaller(const vector<T>& arr) {",
		"        vector<int> result(arr.size(), -1);",
		"        stack<int> st;",
		"",
		"        for (int i = 0; i < arr.size(); i++) {",
		"            while (!st.empty() && arr[st.top()] > arr[i]) {",
		"                result[st.top()] = i;",
		"                st.pop();",
		"            }",
		"            st.push(i);",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 寻找每个位置的前一个更大元素",
		"    vector<int> prev_greater(const vector<T>& arr) {",
		"        vector<int> result(arr.size(), -1);",
		"        stack<int> st;",
		"",
		"        for (int i = 0; i < arr.size(); i++) {",
		"            while (!st.empty() && arr[st.top()] <= arr[i]) { st.pop(); }",
		"            if (!st.empty()) { result[i] = st.top(); }",
		"            st.push(i);",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 寻找每个位置的前一个更小元素",
		"    vector<int> prev_smaller(const vector<T>& arr) {",
		"        vector<int> result(arr.size(), -1);",
		"        stack<int> st;",
		"",
		"        for (int i = 0; i < arr.size(); i++) {",
		"            while (!st.empty() && arr[st.top()] >= arr[i]) { st.pop(); }",
		"            if (!st.empty()) { result[i] = st.top(); }",
		"            st.push(i);",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
		"",
		"// 计算直方图中的最大矩形面积",
		"long long largest_rectangle_histogram(const vector<int>& heights) {",
		"    vector<int> h = heights;",
		"    h.push_back(0);  // 添加哨兵元素",
		"",
		"    stack<int> st;  // 单调递增栈",
		"    long long max_area = 0;",
		"",
		"    for (int i = 0; i < h.size(); i++) {",
		"        while (!st.empty() && h[st.top()] > h[i]) {",
		"            int height = h[st.top()];  // 当前矩形的高度",
		"            st.pop();",
		"            // 计算宽度：左右边界之间的距离",
		"            int width = st.empty() ? i : i - st.top() - 1;",
		"            max_area = max(max_area, (long long)height * width);",
		"        }",
		"        st.push(i);",
		"    }",
		"",
		"    return max_area;",
		"}",
		"",
		"// 检查括号字符串是否有效",
		"bool is_valid_parentheses(const string& s) {",
		"    stack<char> st;",
		"",
		"    for (char c : s) {",
		"        if (c == '(' || c == '[' || c == '{') {",
		"            st.push(c);  // 左括号入栈",
		"        } else if (c == ')' || c == ']' || c == '}') {",
		"            if (st.empty()) return false;  // 没有匹配的左括号",
		"",
		"            char top = st.top();",
		"            st.pop();",
		"",
		"            // 检查括号是否匹配",
		"            if ((c == ')' && top != '(') || (c == ']' && top != '[') || (c == '}' && top != '{')) { return false; }",
		"        }",
		"    }",
		"",
		"    return st.empty();  // 所有括号都已匹配",
		"}",
		"",
		"// 寻找二进制矩阵中矩形的最大面积",
		"long long max_rectangle_in_matrix(const vector<vector<int>>& matrix) {",
		"    if (matrix.empty() || matrix[0].empty()) return 0;",
		"",
		"    int rows = matrix.size();",
		"    int cols = matrix[0].size();",
		"    vector<int> heights(cols, 0);  // 每列的连续1的高度",
		"    long long max_area = 0;",
		"",
		"    for (int i = 0; i < rows; i++) {",
		"        for (int j = 0; j < cols; j++) {",
		"            // 更新每列的高度",
		"            heights[j] = matrix[i][j] == 0 ? 0 : heights[j] + 1;",
		"        }",
		"        // 计算当前行为底边的最大矩形面积",
		"        max_area = max(max_area, largest_rectangle_histogram(heights));",
		"    }",
		"",
		"    return max_area;",
		"}",
		"",
		"// 计算所有子数组最小值的和",
		"long long sum_subarray_minimums(const vector<int>& arr) {",
		"    const int MOD = 1e9 + 7;",
		"    int n = arr.size();",
		"",
		"    MonotonicStack<int> ms;",
		"    vector<int> prev_smaller = ms.prev_smaller(arr);  // 前一个更小元素的位置",
		"    vector<int> next_smaller = ms.next_smaller(arr);  // 下一个更小元素的位置",
		"",
		"    long long result = 0;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        // 计算以arr[i]为最小值的子数组数量",
		"        int left = prev_smaller[i] == -1 ? i + 1 : i - prev_smaller[i];   // 左边界数量",
		"        int right = next_smaller[i] == -1 ? n - i : next_smaller[i] - i;  // 右边界数量",
		"",
		"        // 贡献 = 元素值 × 包含该元素的子数组数量",
		"        result = (result + (long long)arr[i] * left * right) % MOD;",
		"    }",
		"",
		"    return result;",
		"}",
	})
}),

-- 01_Data_Structures\Trees\AVL.h
s("01_data_structures_trees_avl_h", {
	t({
		"/**",
		" * AVL平衡二叉搜索树",
		" * 功能：",
		" * - 支持插入、删除、查找操作",
		" * - 自动维护树的平衡性（高度差不超过1）",
		" * - 支持排名查询、第k小元素查询",
		" * - 支持前驱、后继查询",
		" * 时间复杂度：所有操作均为 O(log n)",
		" * 空间复杂度：O(n)",
		" */",
		"",
		"template <typename T>",
		"struct AVLTree {",
		"    struct Node {",
		"        T key;        // 节点值",
		"        int height;   // 高度",
		"        int cnt;      // 重复值的数量",
		"        int size;     // 子树大小",
		"        Node* left;   // 左子树",
		"        Node* right;  // 右子树",
		"",
		"        Node(T k) : key(k), height(1), cnt(1), size(1), left(nullptr), right(nullptr) {}",
		"    };",
		"",
		"    Node* root;",
		"",
		"    AVLTree() : root(nullptr) {}",
		"",
		"    // 获取节点高度",
		"    int get_height(Node* node) { return node ? node->height : 0; }",
		"",
		"    // 获取子树大小",
		"    int get_size(Node* node) { return node ? node->size : 0; }",
		"",
		"    // 获取平衡因子",
		"    int get_balance(Node* node) { return node ? get_height(node->left) - get_height(node->right) : 0; }",
		"",
		"    // 更新节点信息",
		"    void update(Node* node) {",
		"        if (!node) return;",
		"        node->height = max(get_height(node->left), get_height(node->right)) + 1;",
		"        node->size = get_size(node->left) + get_size(node->right) + node->cnt;",
		"    }",
		"",
		"    // 右旋转",
		"    Node* right_rotate(Node* y) {",
		"        Node* x = y->left;",
		"        Node* T2 = x->right;",
		"",
		"        x->right = y;",
		"        y->left = T2;",
		"",
		"        update(y);",
		"        update(x);",
		"",
		"        return x;",
		"    }",
		"",
		"    // 左旋转",
		"    Node* left_rotate(Node* x) {",
		"        Node* y = x->right;",
		"        Node* T2 = y->left;",
		"",
		"        y->left = x;",
		"        x->right = T2;",
		"",
		"        update(x);",
		"        update(y);",
		"",
		"        return y;",
		"    }",
		"",
		"    // 插入节点",
		"    Node* insert(Node* node, T key) {",
		"        // 1. 执行标准BST插入",
		"        if (!node) return new Node(key);",
		"",
		"        if (key < node->key) {",
		"            node->left = insert(node->left, key);",
		"        } else if (key > node->key) {",
		"            node->right = insert(node->right, key);",
		"        } else {",
		"            // 相同值，增加计数",
		"            node->cnt++;",
		"            update(node);",
		"            return node;",
		"        }",
		"",
		"        // 2. 更新节点信息",
		"        update(node);",
		"",
		"        // 3. 获取平衡因子",
		"        int balance = get_balance(node);",
		"",
		"        // 4. 如果不平衡，则旋转调整",
		"        // Left Left Case",
		"        if (balance > 1 && key < node->left->key) { return right_rotate(node); }",
		"",
		"        // Right Right Case",
		"        if (balance < -1 && key > node->right->key) { return left_rotate(node); }",
		"",
		"        // Left Right Case",
		"        if (balance > 1 && key > node->left->key) {",
		"            node->left = left_rotate(node->left);",
		"            return right_rotate(node);",
		"        }",
		"",
		"        // Right Left Case",
		"        if (balance < -1 && key < node->right->key) {",
		"            node->right = right_rotate(node->right);",
		"            return left_rotate(node);",
		"        }",
		"",
		"        return node;",
		"    }",
		"",
		"    // 找到最小值节点",
		"    Node* find_min(Node* node) {",
		"        while (node->left) node = node->left;",
		"        return node;",
		"    }",
		"",
		"    // 删除节点",
		"    Node* remove(Node* node, T key) {",
		"        if (!node) return node;",
		"",
		"        if (key < node->key) {",
		"            node->left = remove(node->left, key);",
		"        } else if (key > node->key) {",
		"            node->right = remove(node->right, key);",
		"        } else {",
		"            // 找到要删除的节点",
		"            if (node->cnt > 1) {",
		"                node->cnt--;",
		"                update(node);",
		"                return node;",
		"            }",
		"",
		"            if (!node->left || !node->right) {",
		"                Node* temp = node->left ? node->left : node->right;",
		"                if (!temp) {",
		"                    temp = node;",
		"                    node = nullptr;",
		"                } else {",
		"                    *node = *temp;",
		"                }",
		"                delete temp;",
		"            } else {",
		"                Node* temp = find_min(node->right);",
		"                node->key = temp->key;",
		"                node->cnt = temp->cnt;",
		"                temp->cnt = 1;  // 避免重复删除",
		"                node->right = remove(node->right, temp->key);",
		"            }",
		"        }",
		"",
		"        if (!node) return node;",
		"",
		"        update(node);",
		"",
		"        int balance = get_balance(node);",
		"",
		"        // Left Left Case",
		"        if (balance > 1 && get_balance(node->left) >= 0) { return right_rotate(node); }",
		"",
		"        // Left Right Case",
		"        if (balance > 1 && get_balance(node->left) < 0) {",
		"            node->left = left_rotate(node->left);",
		"            return right_rotate(node);",
		"        }",
		"",
		"        // Right Right Case",
		"        if (balance < -1 && get_balance(node->right) <= 0) { return left_rotate(node); }",
		"",
		"        // Right Left Case",
		"        if (balance < -1 && get_balance(node->right) > 0) {",
		"            node->right = right_rotate(node->right);",
		"            return left_rotate(node);",
		"        }",
		"",
		"        return node;",
		"    }",
		"",
		"    // 查找节点",
		"    bool find(Node* node, T key) {",
		"        if (!node) return false;",
		"        if (key == node->key) return true;",
		"        if (key < node->key) return find(node->left, key);",
		"        return find(node->right, key);",
		"    }",
		"",
		"    // 查找第k小的元素（1-indexed）",
		"    T kth_element(Node* node, int k) {",
		"        if (!node) return T{};",
		"",
		"        int left_size = get_size(node->left);",
		"        if (k <= left_size) {",
		"            return kth_element(node->left, k);",
		"        } else if (k <= left_size + node->cnt) {",
		"            return node->key;",
		"        } else {",
		"            return kth_element(node->right, k - left_size - node->cnt);",
		"        }",
		"    }",
		"",
		"    // 查找元素的排名（从1开始）",
		"    int get_rank(Node* node, T key) {",
		"        if (!node) return 1;",
		"",
		"        if (key < node->key) {",
		"            return get_rank(node->left, key);",
		"        } else if (key == node->key) {",
		"            return get_size(node->left) + 1;",
		"        } else {",
		"            return get_size(node->left) + node->cnt + get_rank(node->right, key);",
		"        }",
		"    }",
		"",
		"    // 查找前驱（小于key的最大元素）",
		"    T predecessor(Node* node, T key) {",
		"        T result = T{};",
		"        bool found = false;",
		"",
		"        while (node) {",
		"            if (node->key < key) {",
		"                if (!found || node->key > result) {",
		"                    result = node->key;",
		"                    found = true;",
		"                }",
		"                node = node->right;",
		"            } else {",
		"                node = node->left;",
		"            }",
		"        }",
		"",
		"        return found ? result : T{};",
		"    }",
		"",
		"    // 查找后继（大于key的最小元素）",
		"    T successor(Node* node, T key) {",
		"        T result = T{};",
		"        bool found = false;",
		"",
		"        while (node) {",
		"            if (node->key > key) {",
		"                if (!found || node->key < result) {",
		"                    result = node->key;",
		"                    found = true;",
		"                }",
		"                node = node->left;",
		"            } else {",
		"                node = node->right;",
		"            }",
		"        }",
		"",
		"        return found ? result : T{};",
		"    }",
		"",
		"    // 公共接口",
		"    void insert(T key) { root = insert(root, key); }",
		"    void remove(T key) { root = remove(root, key); }",
		"    bool find(T key) { return find(root, key); }",
		"    T kth_element(int k) { return kth_element(root, k); }",
		"    int get_rank(T key) { return get_rank(root, key); }",
		"    T predecessor(T key) { return predecessor(root, key); }",
		"    T successor(T key) { return successor(root, key); }",
		"    int size() { return get_size(root); }",
		"    bool empty() { return root == nullptr; }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\FHQ_Treap.h
s("01_data_structures_trees_fhq_treap_h", {
	t({
		"/**",
		" * FHQ Treap（非旋转Treap）",
		" * 功能：",
		" * - 支持插入、删除、查找操作",
		" * - 支持split和merge操作",
		" * - 支持区间翻转、区间查询等操作",
		" * - 支持排名查询、第k小元素查询",
		" * 时间复杂度：期望 O(log n)",
		" * 空间复杂度：O(n)",
		" */",
		"",
		"template <typename T>",
		"struct FHQTreap {",
		"    struct Node {",
		"        T val;         // 节点值",
		"        int priority;  // 随机优先级",
		"        int size;      // 子树大小",
		"        Node* left;    // 左子树",
		"        Node* right;   // 右子树",
		"",
		"        Node(T v) : val(v), priority(rand()), size(1), left(nullptr), right(nullptr) {}",
		"    };",
		"",
		"    Node* root;",
		"    mt19937 rng;",
		"",
		"    FHQTreap() : root(nullptr), rng(random_device{}()) {}",
		"",
		"    // 更新节点大小",
		"    void update(Node* node) {",
		"        if (!node) return;",
		"        node->size = 1;",
		"        if (node->left) node->size += node->left->size;",
		"        if (node->right) node->size += node->right->size;",
		"    }",
		"",
		"    // 获取子树大小",
		"    int get_size(Node* node) { return node ? node->size : 0; }",
		"",
		"    // 按值分裂：将树分为 ≤val 和 >val 两部分",
		"    pair<Node*, Node*> split_by_value(Node* node, T val) {",
		"        if (!node) return {nullptr, nullptr};",
		"",
		"        if (node->val <= val) {",
		"            auto [left, right] = split_by_value(node->right, val);",
		"            node->right = left;",
		"            update(node);",
		"            return {node, right};",
		"        } else {",
		"            auto [left, right] = split_by_value(node->left, val);",
		"            node->left = right;",
		"            update(node);",
		"            return {left, node};",
		"        }",
		"    }",
		"",
		"    // 按大小分裂：将前k个节点分出来",
		"    pair<Node*, Node*> split_by_size(Node* node, int k) {",
		"        if (!node) return {nullptr, nullptr};",
		"",
		"        int left_size = get_size(node->left);",
		"        if (left_size >= k) {",
		"            auto [left, right] = split_by_size(node->left, k);",
		"            node->left = right;",
		"            update(node);",
		"            return {left, node};",
		"        } else {",
		"            auto [left, right] = split_by_size(node->right, k - left_size - 1);",
		"            node->right = left;",
		"            update(node);",
		"            return {node, right};",
		"        }",
		"    }",
		"",
		"    // 合并两棵树（保证left中所有值 ≤ right中所有值）",
		"    Node* merge(Node* left, Node* right) {",
		"        if (!left) return right;",
		"        if (!right) return left;",
		"",
		"        if (left->priority < right->priority) {",
		"            right->left = merge(left, right->left);",
		"            update(right);",
		"            return right;",
		"        } else {",
		"            left->right = merge(left->right, right);",
		"            update(left);",
		"            return left;",
		"        }",
		"    }",
		"",
		"    // 插入值",
		"    void insert(T val) {",
		"        auto [left, right] = split_by_value(root, val);",
		"        auto [left2, right2] = split_by_value(left, val - 1);",
		"",
		"        Node* new_node = new Node(val);",
		"        if (right2) {",
		"            // 如果已存在相同值，这里可以选择忽略或增加计数",
		"            left = merge(left2, right2);",
		"        } else {",
		"            left = merge(left2, new_node);",
		"        }",
		"        root = merge(left, right);",
		"    }",
		"",
		"    // 删除值",
		"    void erase(T val) {",
		"        auto [left, right] = split_by_value(root, val);",
		"        auto [left2, right2] = split_by_value(left, val - 1);",
		"",
		"        // right2就是要删除的节点",
		"        if (right2) {",
		"            delete right2;",
		"            right2 = nullptr;",
		"        }",
		"",
		"        left = merge(left2, right2);",
		"        root = merge(left, right);",
		"    }",
		"",
		"    // 查找值的排名（从1开始）",
		"    int get_rank(T val) {",
		"        auto [left, right] = split_by_value(root, val - 1);",
		"        int rank = get_size(left) + 1;",
		"        root = merge(left, right);",
		"        return rank;",
		"    }",
		"",
		"    // 查找第k小的值（从1开始）",
		"    T kth_element(int k) { return kth_element_helper(root, k); }",
		"",
		"   private:",
		"    T kth_element_helper(Node* node, int k) {",
		"        if (!node) return T{};",
		"",
		"        int left_size = get_size(node->left);",
		"        if (k <= left_size) {",
		"            return kth_element_helper(node->left, k);",
		"        } else if (k == left_size + 1) {",
		"            return node->val;",
		"        } else {",
		"            return kth_element_helper(node->right, k - left_size - 1);",
		"        }",
		"    }",
		"",
		"   public:",
		"    // 查找前驱（小于val的最大值）",
		"    T predecessor(T val) {",
		"        auto [left, right] = split_by_value(root, val - 1);",
		"        T result = T{};",
		"        bool found = false;",
		"",
		"        if (left) {",
		"            result = find_max(left);",
		"            found = true;",
		"        }",
		"",
		"        root = merge(left, right);",
		"        return found ? result : T{};",
		"    }",
		"",
		"    // 查找后继（大于val的最小值）",
		"    T successor(T val) {",
		"        auto [left, right] = split_by_value(root, val);",
		"        T result = T{};",
		"        bool found = false;",
		"",
		"        if (right) {",
		"            result = find_min(right);",
		"            found = true;",
		"        }",
		"",
		"        root = merge(left, right);",
		"        return found ? result : T{};",
		"    }",
		"",
		"   private:",
		"    T find_min(Node* node) {",
		"        while (node->left) node = node->left;",
		"        return node->val;",
		"    }",
		"",
		"    T find_max(Node* node) {",
		"        while (node->right) node = node->right;",
		"        return node->val;",
		"    }",
		"",
		"   public:",
		"    // 检查是否包含某个值",
		"    bool contains(T val) {",
		"        auto [left, right] = split_by_value(root, val);",
		"        auto [left2, right2] = split_by_value(left, val - 1);",
		"",
		"        bool found = (right2 != nullptr);",
		"",
		"        left = merge(left2, right2);",
		"        root = merge(left, right);",
		"        return found;",
		"    }",
		"",
		"    // 获取树的大小",
		"    int size() { return get_size(root); }",
		"",
		"    // 检查树是否为空",
		"    bool empty() { return root == nullptr; }",
		"",
		"    // 清空树",
		"    void clear() {",
		"        clear_helper(root);",
		"        root = nullptr;",
		"    }",
		"",
		"   private:",
		"    void clear_helper(Node* node) {",
		"        if (!node) return;",
		"        clear_helper(node->left);",
		"        clear_helper(node->right);",
		"        delete node;",
		"    }",
		"};",
		"",
		"// 支持区间操作的FHQ Treap（用于序列操作）",
		"template <typename T>",
		"struct SequenceFHQTreap {",
		"    struct Node {",
		"        T val;",
		"        int priority;",
		"        int size;",
		"        bool reversed;  // 翻转标记",
		"        Node* left;",
		"        Node* right;",
		"",
		"        Node(T v) : val(v), priority(rand()), size(1), reversed(false), left(nullptr), right(nullptr) {}",
		"    };",
		"",
		"    Node* root;",
		"    mt19937 rng;",
		"",
		"    SequenceFHQTreap() : root(nullptr), rng(random_device{}()) {}",
		"",
		"    void push_down(Node* node) {",
		"        if (!node || !node->reversed) return;",
		"",
		"        swap(node->left, node->right);",
		"        if (node->left) node->left->reversed ^= true;",
		"        if (node->right) node->right->reversed ^= true;",
		"        node->reversed = false;",
		"    }",
		"",
		"    void update(Node* node) {",
		"        if (!node) return;",
		"        node->size = 1;",
		"        if (node->left) node->size += node->left->size;",
		"        if (node->right) node->size += node->right->size;",
		"    }",
		"",
		"    int get_size(Node* node) { return node ? node->size : 0; }",
		"",
		"    // 按位置分裂",
		"    pair<Node*, Node*> split(Node* node, int pos) {",
		"        if (!node) return {nullptr, nullptr};",
		"",
		"        push_down(node);",
		"        int left_size = get_size(node->left);",
		"",
		"        if (pos <= left_size) {",
		"            auto [left, right] = split(node->left, pos);",
		"            node->left = right;",
		"            update(node);",
		"            return {left, node};",
		"        } else {",
		"            auto [left, right] = split(node->right, pos - left_size - 1);",
		"            node->right = left;",
		"            update(node);",
		"            return {node, right};",
		"        }",
		"    }",
		"",
		"    Node* merge(Node* left, Node* right) {",
		"        if (!left) return right;",
		"        if (!right) return left;",
		"",
		"        if (left->priority < right->priority) {",
		"            push_down(right);",
		"            right->left = merge(left, right->left);",
		"            update(right);",
		"            return right;",
		"        } else {",
		"            push_down(left);",
		"            left->right = merge(left->right, right);",
		"            update(left);",
		"            return left;",
		"        }",
		"    }",
		"",
		"    // 在位置pos插入值val",
		"    void insert(int pos, T val) {",
		"        auto [left, right] = split(root, pos);",
		"        Node* new_node = new Node(val);",
		"        root = merge(merge(left, new_node), right);",
		"    }",
		"",
		"    // 删除位置pos的元素",
		"    void erase(int pos) {",
		"        auto [left, right] = split(root, pos - 1);",
		"        auto [mid, right2] = split(right, 1);",
		"        if (mid) delete mid;",
		"        root = merge(left, right2);",
		"    }",
		"",
		"    // 翻转区间[l, r]",
		"    void reverse(int l, int r) {",
		"        auto [left, right] = split(root, l - 1);",
		"        auto [mid, right2] = split(right, r - l + 1);",
		"        if (mid) mid->reversed ^= true;",
		"        root = merge(left, merge(mid, right2));",
		"    }",
		"",
		"    // 获取位置pos的值",
		"    T get(int pos) { return get_helper(root, pos); }",
		"",
		"   private:",
		"    T get_helper(Node* node, int pos) {",
		"        if (!node) return T{};",
		"",
		"        push_down(node);",
		"        int left_size = get_size(node->left);",
		"",
		"        if (pos <= left_size) {",
		"            return get_helper(node->left, pos);",
		"        } else if (pos == left_size + 1) {",
		"            return node->val;",
		"        } else {",
		"            return get_helper(node->right, pos - left_size - 1);",
		"        }",
		"    }",
		"",
		"   public:",
		"    int size() { return get_size(root); }",
		"    bool empty() { return root == nullptr; }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\FenwickTree.h
s("01_data_structures_trees_fenwicktree_h", {
	t({
		"/**",
		" * 树状数组模板（Fenwick Tree / Binary Indexed Tree）",
		" * 功能：",
		" * - 单点更新，区间查询",
		" * - 支持前缀和查询和区间和查询",
		" * - 二分查找第k小元素",
		" * 时间复杂度：O(log n) 更新和查询",
		" */",
		"",
		"template <typename T>",
		"struct FenwickTree {",
		"    vector<T> tree;",
		"    int n;",
		"",
		"    FenwickTree(int size) : n(size) { tree.assign(n + 1, T{}); }",
		"",
		"    FenwickTree(const vector<T>& arr) : n(arr.size()) {",
		"        tree.assign(n + 1, T{});",
		"        for (int i = 0; i < n; i++) { update(i + 1, arr[i]); }",
		"    }",
		"",
		"    // 单点更新：将位置pos的值增加delta",
		"    void update(int pos, T delta) {",
		"        for (; pos <= n; pos += pos & (-pos)) { tree[pos] += delta; }",
		"    }",
		"",
		"    // 前缀和查询：查询[1, pos]的和",
		"    T query(int pos) {",
		"        T sum = T{};",
		"        for (; pos > 0; pos -= pos & (-pos)) { sum += tree[pos]; }",
		"        return sum;",
		"    }",
		"",
		"    // 区间和查询：查询[l, r]的和",
		"    T range_query(int l, int r) {",
		"        if (l > r) return T{};",
		"        return query(r) - query(l - 1);",
		"    }",
		"",
		"    // 单点查询",
		"    T point_query(int pos) { return range_query(pos, pos); }",
		"",
		"    // 二分查找：找到第一个前缀和 >= target 的位置",
		"    int lower_bound(T target) {",
		"        int pos = 0;",
		"        for (int k = __builtin_clz(1) - __builtin_clz(n); k >= 0; k--) {",
		"            int next_pos = pos + (1 << k);",
		"            if (next_pos <= n && tree[next_pos] < target) {",
		"                target -= tree[next_pos];",
		"                pos = next_pos;",
		"            }",
		"        }",
		"        return pos + 1;",
		"    }",
		"",
		"    // 清空树状数组",
		"    void clear() { fill(tree.begin(), tree.end(), T{}); }",
		"};",
		"",
		"// 差分树状数组：支持区间更新，单点查询",
		"template <typename T>",
		"struct DiffFenwickTree {",
		"    FenwickTree<T> ft;",
		"",
		"    DiffFenwickTree(int size) : ft(size) {}",
		"",
		"    // 区间更新：将区间[l, r]的所有值增加delta",
		"    void range_update(int l, int r, T delta) {",
		"        ft.update(l, delta);",
		"        if (r + 1 <= ft.n) { ft.update(r + 1, -delta); }",
		"    }",
		"",
		"    // 单点查询：查询位置pos的值",
		"    T point_query(int pos) { return ft.query(pos); }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\FenwickTree2D.h
s("01_data_structures_trees_fenwicktree2d_h", {
	t({
		"/**",
		" * 二维树状数组（二维Fenwick Tree/Binary Indexed Tree）",
		" * 功能：",
		" * - 支持二维数组的单点更新和区间查询",
		" * - 支持矩形区域的前缀和计算",
		" * - 支持矩形区域的范围更新（差分数组实现）",
		" * 时间复杂度：更新和查询均为 O(log n * log m)",
		" * 空间复杂度：O(n * m)",
		" */",
		"",
		"// 基础二维树状数组",
		"template <typename T>",
		"struct FenwickTree2D {",
		"    vector<vector<T>> tree;",
		"    int n, m;",
		"",
		"    // 构造函数：初始化 n×m 的二维树状数组",
		"    FenwickTree2D(int rows, int cols) : n(rows), m(cols) { tree.assign(n + 1, vector<T>(m + 1, 0)); }",
		"",
		"    // 构造函数：从二维数组初始化",
		"    FenwickTree2D(const vector<vector<T>>& matrix) : n(matrix.size()), m(matrix[0].size()) {",
		"        tree.assign(n + 1, vector<T>(m + 1, 0));",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) { update(i + 1, j + 1, matrix[i][j]); }",
		"        }",
		"    }",
		"",
		"    // 单点更新：将 (x, y) 位置的值增加 delta",
		"    void update(int x, int y, T delta) {",
		"        for (int i = x; i <= n; i += lowbit(i)) {",
		"            for (int j = y; j <= m; j += lowbit(j)) { tree[i][j] += delta; }",
		"        }",
		"    }",
		"",
		"    // 前缀和查询：查询从 (1,1) 到 (x,y) 的矩形和",
		"    T query(int x, int y) {",
		"        T sum = 0;",
		"        for (int i = x; i > 0; i -= lowbit(i)) {",
		"            for (int j = y; j > 0; j -= lowbit(j)) { sum += tree[i][j]; }",
		"        }",
		"        return sum;",
		"    }",
		"",
		"    // 矩形区域查询：查询从 (x1,y1) 到 (x2,y2) 的矩形和",
		"    T range_query(int x1, int y1, int x2, int y2) {",
		"        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);",
		"    }",
		"",
		"    // 单点查询：查询 (x, y) 位置的值",
		"    T point_query(int x, int y) { return range_query(x, y, x, y); }",
		"",
		"   private:",
		"    int lowbit(int x) { return x & (-x); }",
		"};",
		"",
		"// 支持矩形区域更新的二维树状数组（基于差分数组）",
		"template <typename T>",
		"struct RangeUpdate2D {",
		"    FenwickTree2D<T> diff;",
		"    int n, m;",
		"",
		"    RangeUpdate2D(int rows, int cols) : diff(rows, cols), n(rows), m(cols) {}",
		"",
		"    // 矩形区域更新：将 (x1,y1) 到 (x2,y2) 的矩形区域都增加 delta",
		"    void range_update(int x1, int y1, int x2, int y2, T delta) {",
		"        diff.update(x1, y1, delta);",
		"        diff.update(x1, y2 + 1, -delta);",
		"        diff.update(x2 + 1, y1, -delta);",
		"        diff.update(x2 + 1, y2 + 1, delta);",
		"    }",
		"",
		"    // 单点查询：查询 (x, y) 位置的实际值",
		"    T point_query(int x, int y) { return diff.query(x, y); }",
		"};",
		"",
		"// 二维区间更新区间查询（需要四个差分数组）",
		"template <typename T>",
		"struct RangeUpdateRangeQuery2D {",
		"    FenwickTree2D<T> d1, d2, d3, d4;  // 四个差分数组",
		"    int n, m;",
		"",
		"    RangeUpdateRangeQuery2D(int rows, int cols)",
		"        : d1(rows, cols), d2(rows, cols), d3(rows, cols), d4(rows, cols), n(rows), m(cols) {}",
		"",
		"    // 矩形区域更新",
		"    void range_update(int x1, int y1, int x2, int y2, T delta) {",
		"        update_helper(x1, y1, delta);",
		"        update_helper(x1, y2 + 1, -delta);",
		"        update_helper(x2 + 1, y1, -delta);",
		"        update_helper(x2 + 1, y2 + 1, delta);",
		"    }",
		"",
		"    // 矩形区域查询",
		"    T range_query(int x1, int y1, int x2, int y2) {",
		"        return query_helper(x2, y2) - query_helper(x1 - 1, y2) - query_helper(x2, y1 - 1) +",
		"               query_helper(x1 - 1, y1 - 1);",
		"    }",
		"",
		"    // 单点查询",
		"    T point_query(int x, int y) { return range_query(x, y, x, y); }",
		"",
		"   private:",
		"    void update_helper(int x, int y, T delta) {",
		"        if (x <= 0 || y <= 0 || x > n || y > m) return;",
		"        d1.update(x, y, delta);",
		"        d2.update(x, y, delta * x);",
		"        d3.update(x, y, delta * y);",
		"        d4.update(x, y, delta * x * y);",
		"    }",
		"",
		"    T query_helper(int x, int y) {",
		"        if (x <= 0 || y <= 0) return 0;",
		"        return (x + 1) * (y + 1) * d1.query(x, y) - (y + 1) * d2.query(x, y) - (x + 1) * d3.query(x, y) +",
		"               d4.query(x, y);",
		"    }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\LinkCutTree.h
s("01_data_structures_trees_linkcuttree_h", {
	t({
		"/**",
		" * Link-Cut Tree（动态树）",
		" * 功能：",
		" * - 支持动态连边和断边操作",
		" * - 支持路径查询和路径修改",
		" * - 支持树根变更（makeroot）",
		" * - 支持连通性查询",
		" * 时间复杂度：均摊 O(log n)",
		" * 空间复杂度：O(n)",
		" *",
		" * 应用场景：",
		" * - 动态连通性问题",
		" * - 动态最小生成树",
		" * - 树上路径查询",
		" */",
		"",
		"template <typename T>",
		"struct LinkCutTree {",
		"    struct Node {",
		"        int ch[2];     // 左右儿子",
		"        int father;    // 父节点",
		"        T val;         // 节点值",
		"        T sum;         // 子树和",
		"        bool reverse;  // 翻转标记",
		"",
		"        Node() : father(0), val(T{}), sum(T{}), reverse(false) { ch[0] = ch[1] = 0; }",
		"    };",
		"",
		"    vector<Node> tree;",
		"    int n;",
		"",
		"    LinkCutTree(int size) : n(size) { tree.resize(size + 1); }",
		"",
		"    // 更新节点信息",
		"    void push_up(int x) {",
		"        if (!x) return;",
		"        tree[x].sum = tree[tree[x].ch[0]].sum + tree[x].val + tree[tree[x].ch[1]].sum;",
		"    }",
		"",
		"    // 下传标记",
		"    void push_down(int x) {",
		"        if (!x || !tree[x].reverse) return;",
		"",
		"        // 交换左右儿子",
		"        swap(tree[x].ch[0], tree[x].ch[1]);",
		"",
		"        // 下传翻转标记",
		"        if (tree[x].ch[0]) tree[tree[x].ch[0]].reverse = !tree[tree[x].ch[0]].reverse;",
		"        if (tree[x].ch[1]) tree[tree[x].ch[1]].reverse = !tree[tree[x].ch[1]].reverse;",
		"",
		"        tree[x].reverse = false;",
		"    }",
		"",
		"    // 判断x是否为splay的根",
		"    bool is_root(int x) {",
		"        int fa = tree[x].father;",
		"        return tree[fa].ch[0] != x && tree[fa].ch[1] != x;",
		"    }",
		"",
		"    // 获取x是父节点的哪个儿子",
		"    int get_relation(int x) { return tree[tree[x].father].ch[1] == x; }",
		"",
		"    // 旋转操作",
		"    void rotate(int x) {",
		"        int y = tree[x].father;",
		"        int z = tree[y].father;",
		"        int k = get_relation(x);",
		"",
		"        if (!is_root(y)) { tree[z].ch[get_relation(y)] = x; }",
		"        tree[x].father = z;",
		"",
		"        tree[y].ch[k] = tree[x].ch[k ^ 1];",
		"        if (tree[x].ch[k ^ 1]) { tree[tree[x].ch[k ^ 1]].father = y; }",
		"",
		"        tree[x].ch[k ^ 1] = y;",
		"        tree[y].father = x;",
		"",
		"        push_up(y);",
		"        push_up(x);",
		"    }",
		"",
		"    // Splay操作",
		"    void splay(int x) {",
		"        stack<int> stk;",
		"        int cur = x;",
		"",
		"        // 找到splay的根，同时记录路径",
		"        while (!is_root(cur)) {",
		"            stk.push(cur);",
		"            cur = tree[cur].father;",
		"        }",
		"        stk.push(cur);",
		"",
		"        // 从根开始下传标记",
		"        while (!stk.empty()) {",
		"            push_down(stk.top());",
		"            stk.pop();",
		"        }",
		"",
		"        // 进行splay",
		"        while (!is_root(x)) {",
		"            int y = tree[x].father;",
		"            if (!is_root(y)) {",
		"                if (get_relation(x) == get_relation(y)) {",
		"                    rotate(y);",
		"                } else {",
		"                    rotate(x);",
		"                }",
		"            }",
		"            rotate(x);",
		"        }",
		"    }",
		"",
		"    // 访问操作：将从根到x的路径变成一条preferred path",
		"    void access(int x) {",
		"        int last = 0;",
		"        while (x) {",
		"            splay(x);",
		"            tree[x].ch[1] = last;",
		"            push_up(x);",
		"            last = x;",
		"            x = tree[x].father;",
		"        }",
		"    }",
		"",
		"    // 换根操作：将x变成树的根",
		"    void make_root(int x) {",
		"        access(x);",
		"        splay(x);",
		"        tree[x].reverse = !tree[x].reverse;",
		"    }",
		"",
		"    // 查找x所在树的根",
		"    int find_root(int x) {",
		"        access(x);",
		"        splay(x);",
		"",
		"        // 一直往左走找到根",
		"        while (tree[x].ch[0]) {",
		"            push_down(x);",
		"            x = tree[x].ch[0];",
		"        }",
		"        splay(x);",
		"        return x;",
		"    }",
		"",
		"    // 连边操作：连接x和y",
		"    void link(int x, int y) {",
		"        make_root(x);",
		"        tree[x].father = y;",
		"    }",
		"",
		"    // 断边操作：断开x和y之间的边",
		"    void cut(int x, int y) {",
		"        make_root(x);",
		"        access(y);",
		"        splay(y);",
		"",
		"        // 此时x应该是y的左儿子且x没有右儿子",
		"        if (tree[y].ch[0] == x && !tree[x].ch[1]) {",
		"            tree[y].ch[0] = 0;",
		"            tree[x].father = 0;",
		"            push_up(y);",
		"        }",
		"    }",
		"",
		"    // 判断x和y是否连通",
		"    bool connected(int x, int y) {",
		"        if (x == y) return true;",
		"        return find_root(x) == find_root(y);",
		"    }",
		"",
		"    // 设置节点x的值",
		"    void set_val(int x, T val) {",
		"        splay(x);",
		"        tree[x].val = val;",
		"        push_up(x);",
		"    }",
		"",
		"    // 获取节点x的值",
		"    T get_val(int x) {",
		"        splay(x);",
		"        return tree[x].val;",
		"    }",
		"",
		"    // 查询x到y路径上的和",
		"    T query_path(int x, int y) {",
		"        make_root(x);",
		"        access(y);",
		"        splay(y);",
		"        return tree[y].sum;",
		"    }",
		"",
		"    // 修改x到y路径上所有节点的值（加上delta）",
		"    void modify_path(int x, int y, T delta) {",
		"        make_root(x);",
		"        access(y);",
		"        splay(y);",
		"        // 这里需要根据具体需求实现路径修改",
		"        // 通常需要添加懒惰标记",
		"    }",
		"",
		"    // 查询x所在子树的大小",
		"    int subtree_size(int x) {",
		"        splay(x);",
		"        return tree[tree[x].ch[0]].sum + 1;  // 假设sum维护的是子树大小",
		"    }",
		"};",
		"",
		"// 简化版本的Link-Cut Tree（只支持连通性查询）",
		"struct SimpleLCT {",
		"    vector<int> ch[2];",
		"    vector<int> father;",
		"    vector<bool> reverse;",
		"    int n;",
		"",
		"    SimpleLCT(int size) : n(size) {",
		"        ch[0].resize(size + 1);",
		"        ch[1].resize(size + 1);",
		"        father.resize(size + 1);",
		"        reverse.resize(size + 1);",
		"",
		"        for (int i = 0; i <= size; i++) {",
		"            ch[0][i] = ch[1][i] = father[i] = 0;",
		"            reverse[i] = false;",
		"        }",
		"    }",
		"",
		"    bool is_root(int x) { return ch[0][father[x]] != x && ch[1][father[x]] != x; }",
		"",
		"    void push_down(int x) {",
		"        if (reverse[x]) {",
		"            swap(ch[0][x], ch[1][x]);",
		"            if (ch[0][x]) reverse[ch[0][x]] = !reverse[ch[0][x]];",
		"            if (ch[1][x]) reverse[ch[1][x]] = !reverse[ch[1][x]];",
		"            reverse[x] = false;",
		"        }",
		"    }",
		"",
		"    void splay(int x) {",
		"        stack<int> stk;",
		"        int cur = x;",
		"",
		"        while (!is_root(cur)) {",
		"            stk.push(cur);",
		"            cur = father[cur];",
		"        }",
		"        stk.push(cur);",
		"",
		"        while (!stk.empty()) {",
		"            push_down(stk.top());",
		"            stk.pop();",
		"        }",
		"",
		"        while (!is_root(x)) {",
		"            int y = father[x];",
		"            if (!is_root(y)) {",
		"                if ((ch[1][father[y]] == y) == (ch[1][y] == x)) {",
		"                    rotate(y);",
		"                } else {",
		"                    rotate(x);",
		"                }",
		"            }",
		"            rotate(x);",
		"        }",
		"    }",
		"",
		"    void rotate(int x) {",
		"        int y = father[x];",
		"        int z = father[y];",
		"        int k = ch[1][y] == x;",
		"",
		"        if (!is_root(y)) { ch[ch[1][z] == y][z] = x; }",
		"        father[x] = z;",
		"",
		"        ch[k][y] = ch[k ^ 1][x];",
		"        father[ch[k ^ 1][x]] = y;",
		"",
		"        ch[k ^ 1][x] = y;",
		"        father[y] = x;",
		"    }",
		"",
		"    void access(int x) {",
		"        int last = 0;",
		"        while (x) {",
		"            splay(x);",
		"            ch[1][x] = last;",
		"            last = x;",
		"            x = father[x];",
		"        }",
		"    }",
		"",
		"    void make_root(int x) {",
		"        access(x);",
		"        splay(x);",
		"        reverse[x] = !reverse[x];",
		"    }",
		"",
		"    int find_root(int x) {",
		"        access(x);",
		"        splay(x);",
		"        while (ch[0][x]) {",
		"            push_down(x);",
		"            x = ch[0][x];",
		"        }",
		"        splay(x);",
		"        return x;",
		"    }",
		"",
		"    void link(int x, int y) {",
		"        make_root(x);",
		"        father[x] = y;",
		"    }",
		"",
		"    void cut(int x, int y) {",
		"        make_root(x);",
		"        access(y);",
		"        splay(y);",
		"        if (ch[0][y] == x && !ch[1][x]) { ch[0][y] = father[x] = 0; }",
		"    }",
		"",
		"    bool connected(int x, int y) {",
		"        if (x == y) return true;",
		"        return find_root(x) == find_root(y);",
		"    }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\PersistentSegTree.h
s("01_data_structures_trees_persistentsegtree_h", {
	t({
		"/**",
		" * 可持久化线段树（主席树）",
		" * 功能：",
		" * - 支持历史版本的查询和修改",
		" * - 支持区间第k小查询",
		" * - 支持可持久化数组操作",
		" * - 支持版本回滚",
		" * 时间复杂度：查询和修改均为 O(log n)",
		" * 空间复杂度：每次修改增加 O(log n) 个节点",
		" *",
		" * 应用场景：",
		" * - 区间第k小问题",
		" * - 可持久化数据结构",
		" * - 函数式编程中的不可变数据结构",
		" */",
		"",
		"template <typename T>",
		"struct PersistentSegmentTree {",
		"    struct Node {",
		"        T val;            // 节点值",
		"        int left, right;  // 左右子树编号",
		"",
		"        Node() : val(T{}), left(0), right(0) {}",
		"        Node(T v) : val(v), left(0), right(0) {}",
		"        Node(T v, int l, int r) : val(v), left(l), right(r) {}",
		"    };",
		"",
		"    vector<Node> tree;  // 节点池",
		"    vector<int> roots;  // 每个版本的根节点",
		"    int n;              // 数组大小",
		"    int node_count;     // 当前节点数量",
		"",
		"    PersistentSegmentTree(int size) : n(size), node_count(0) {",
		"        tree.resize(size * 40);  // 预分配足够的节点",
		"        roots.push_back(build(1, n));",
		"    }",
		"",
		"    PersistentSegmentTree(const vector<T>& arr) : n(arr.size()), node_count(0) {",
		"        tree.resize(n * 40);",
		"        roots.push_back(build(arr, 1, n));",
		"    }",
		"",
		"    // 构建初始线段树",
		"    int build(int l, int r) {",
		"        int cur = ++node_count;",
		"        if (l == r) {",
		"            tree[cur] = Node(T{});",
		"            return cur;",
		"        }",
		"",
		"        int mid = (l + r) / 2;",
		"        tree[cur].left = build(l, mid);",
		"        tree[cur].right = build(mid + 1, r);",
		"        tree[cur].val = tree[tree[cur].left].val + tree[tree[cur].right].val;",
		"        return cur;",
		"    }",
		"",
		"    // 从数组构建初始线段树",
		"    int build(const vector<T>& arr, int l, int r) {",
		"        int cur = ++node_count;",
		"        if (l == r) {",
		"            tree[cur] = Node(arr[l - 1]);  // 数组是0-indexed",
		"            return cur;",
		"        }",
		"",
		"        int mid = (l + r) / 2;",
		"        tree[cur].left = build(arr, l, mid);",
		"        tree[cur].right = build(arr, mid + 1, r);",
		"        tree[cur].val = tree[tree[cur].left].val + tree[tree[cur].right].val;",
		"        return cur;",
		"    }",
		"",
		"    // 单点更新，返回新的根节点",
		"    int update(int prev_root, int l, int r, int pos, T val) {",
		"        int cur = ++node_count;",
		"        tree[cur] = tree[prev_root];  // 复制前一个版本的节点",
		"",
		"        if (l == r) {",
		"            tree[cur].val = val;",
		"            return cur;",
		"        }",
		"",
		"        int mid = (l + r) / 2;",
		"        if (pos <= mid) {",
		"            tree[cur].left = update(tree[prev_root].left, l, mid, pos, val);",
		"        } else {",
		"            tree[cur].right = update(tree[prev_root].right, mid + 1, r, pos, val);",
		"        }",
		"",
		"        tree[cur].val = tree[tree[cur].left].val + tree[tree[cur].right].val;",
		"        return cur;",
		"    }",
		"",
		"    // 区间查询",
		"    T query(int root, int l, int r, int ql, int qr) {",
		"        if (ql > r || qr < l) return T{};",
		"        if (ql <= l && r <= qr) return tree[root].val;",
		"",
		"        int mid = (l + r) / 2;",
		"        return query(tree[root].left, l, mid, ql, qr) + query(tree[root].right, mid + 1, r, ql, qr);",
		"    }",
		"",
		"    // 单点查询",
		"    T query_point(int root, int l, int r, int pos) {",
		"        if (l == r) return tree[root].val;",
		"",
		"        int mid = (l + r) / 2;",
		"        if (pos <= mid) {",
		"            return query_point(tree[root].left, l, mid, pos);",
		"        } else {",
		"            return query_point(tree[root].right, mid + 1, r, pos);",
		"        }",
		"    }",
		"",
		"    // 公共接口",
		"",
		"    // 创建新版本：在指定版本基础上修改位置pos的值为val",
		"    int new_version(int version, int pos, T val) {",
		"        int new_root = update(roots[version], 1, n, pos, val);",
		"        roots.push_back(new_root);",
		"        return roots.size() - 1;",
		"    }",
		"",
		"    // 查询指定版本的区间和",
		"    T query(int version, int l, int r) { return query(roots[version], 1, n, l, r); }",
		"",
		"    // 查询指定版本的单点值",
		"    T query(int version, int pos) { return query_point(roots[version], 1, n, pos); }",
		"",
		"    // 获取版本数量",
		"    int version_count() { return roots.size(); }",
		"};",
		"",
		"// 可持久化线段树用于区间第k小查询",
		"struct PersistentKthQuery {",
		"    struct Node {",
		"        int cnt;          // 当前区间内的数字个数",
		"        int left, right;  // 左右子树",
		"",
		"        Node() : cnt(0), left(0), right(0) {}",
		"        Node(int c) : cnt(c), left(0), right(0) {}",
		"    };",
		"",
		"    vector<Node> tree;",
		"    vector<int> roots;",
		"    vector<int> sorted_vals;  // 离散化后的值",
		"    int n, node_count;",
		"",
		"    PersistentKthQuery(vector<int>& arr) : n(arr.size()), node_count(0) {",
		"        // 离散化",
		"        sorted_vals = arr;",
		"        sort(sorted_vals.begin(), sorted_vals.end());",
		"        sorted_vals.erase(unique(sorted_vals.begin(), sorted_vals.end()), sorted_vals.end());",
		"",
		"        tree.resize(n * 40);",
		"        roots.resize(n + 1);",
		"",
		"        // 构建可持久化线段树",
		"        roots[0] = build(0, sorted_vals.size() - 1);",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            int pos = lower_bound(sorted_vals.begin(), sorted_vals.end(), arr[i]) - sorted_vals.begin();",
		"            roots[i + 1] = update(roots[i], 0, sorted_vals.size() - 1, pos);",
		"        }",
		"    }",
		"",
		"    int build(int l, int r) {",
		"        int cur = ++node_count;",
		"        if (l == r) {",
		"            tree[cur] = Node(0);",
		"            return cur;",
		"        }",
		"",
		"        int mid = (l + r) / 2;",
		"        tree[cur].left = build(l, mid);",
		"        tree[cur].right = build(mid + 1, r);",
		"        return cur;",
		"    }",
		"",
		"    int update(int prev, int l, int r, int pos) {",
		"        int cur = ++node_count;",
		"        tree[cur] = tree[prev];",
		"        tree[cur].cnt++;",
		"",
		"        if (l == r) return cur;",
		"",
		"        int mid = (l + r) / 2;",
		"        if (pos <= mid) {",
		"            tree[cur].left = update(tree[prev].left, l, mid, pos);",
		"        } else {",
		"            tree[cur].right = update(tree[prev].right, mid + 1, r, pos);",
		"        }",
		"        return cur;",
		"    }",
		"",
		"    int query_kth(int left_root, int right_root, int l, int r, int k) {",
		"        if (l == r) return sorted_vals[l];",
		"",
		"        int mid = (l + r) / 2;",
		"        int left_cnt = tree[tree[right_root].left].cnt - tree[tree[left_root].left].cnt;",
		"",
		"        if (k <= left_cnt) {",
		"            return query_kth(tree[left_root].left, tree[right_root].left, l, mid, k);",
		"        } else {",
		"            return query_kth(tree[left_root].right, tree[right_root].right, mid + 1, r, k - left_cnt);",
		"        }",
		"    }",
		"",
		"    // 查询区间[l,r]中第k小的数（1-indexed）",
		"    int kth_element(int l, int r, int k) { return query_kth(roots[l - 1], roots[r], 0, sorted_vals.size() - 1, k); }",
		"",
		"    // 查询区间[l,r]中小于等于val的数的个数",
		"    int count_leq(int l, int r, int val) {",
		"        int pos = upper_bound(sorted_vals.begin(), sorted_vals.end(), val) - sorted_vals.begin() - 1;",
		"        if (pos < 0) return 0;",
		"        return count_leq_helper(roots[l - 1], roots[r], 0, sorted_vals.size() - 1, pos);",
		"    }",
		"",
		"   private:",
		"    int count_leq_helper(int left_root, int right_root, int l, int r, int pos) {",
		"        if (pos < l) return 0;",
		"        if (pos >= r) return tree[right_root].cnt - tree[left_root].cnt;",
		"",
		"        int mid = (l + r) / 2;",
		"        return count_leq_helper(tree[left_root].left, tree[right_root].left, l, mid, pos) +",
		"               count_leq_helper(tree[left_root].right, tree[right_root].right, mid + 1, r, pos);",
		"    }",
		"};",
		"",
		"// 可持久化数组（支持历史版本访问）",
		"template <typename T>",
		"struct PersistentArray {",
		"    PersistentSegmentTree<T> pst;",
		"",
		"    PersistentArray(int size) : pst(size) {}",
		"    PersistentArray(const vector<T>& arr) : pst(arr) {}",
		"",
		"    // 修改位置pos的值为val，返回新版本号",
		"    int set(int version, int pos, T val) { return pst.new_version(version, pos, val); }",
		"",
		"    // 获取指定版本位置pos的值",
		"    T get(int version, int pos) { return pst.query(version, pos); }",
		"",
		"    // 获取当前版本数",
		"    int versions() { return pst.version_count(); }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\SegmentTree.h
s("01_data_structures_trees_segmenttree_h", {
	t({
		"/**",
		" * 线段树模板",
		" * 功能：",
		" * - 区间更新，区间查询",
		" * - 支持延迟标记（懒惰传播）",
		" * - 可扩展的信息和标记结构",
		" * 时间复杂度：O(log n) 更新和查询",
		" */",
		"",
		"template <typename T, class Info, class Laz>",
		"struct SegTree ",
		"{",
		"    int n;",
		"    vector<T> arr;",
		"    vector<Laz> laz;",
		"    vector<Info> info;",
		"",
		"    SegTree() : n(0) {}",
		"    SegTree(int n_) : n(n_), arr(n + 5), laz(4 * n), info(4 * n) {}",
		"",
		"    void build() { build(1, n, 1); }",
		"",
		"    void build(int l, int r, int u) ",
		"    {",
		"        if (l == r) ",
		"        {",
		"            info[u] = Info(arr[l]);",
		"            return;",
		"        }",
		"",
		"        int mid = (l + r) >> 1;",
		"        build(l, mid, u << 1);",
		"        build(mid + 1, r, u << 1 | 1);",
		"        push_up(u);",
		"    }",
		"",
		"    void apply(int u, Laz tag, int len) ",
		"    {",
		"        laz[u].apply(tag);",
		"        info[u].apply(tag, len);",
		"    }",
		"",
		"    void push_up(int u) { info[u] = info[u << 1] + info[u << 1 | 1]; }",
		"",
		"    void push_down(int u, int llen, int rlen) ",
		"    {",
		"        apply(u << 1, laz[u], llen);",
		"        apply(u << 1 | 1, laz[u], rlen);",
		"        laz[u] = Laz();",
		"    }",
		"",
		"    void modify(int l, int r, Laz tag) { modify(l, r, tag, 1, n, 1); }",
		"",
		"    void modify(int jobl, int jobr, Laz tag, int l, int r, int u) ",
		"    {",
		"        if (jobl <= l && jobr >= r) ",
		"        {",
		"            apply(u, tag, r - l + 1);",
		"            return;",
		"        }",
		"",
		"        int mid = (l + r) >> 1;",
		"        push_down(u, mid - l + 1, r - mid);",
		"        if (jobl <= mid) modify(jobl, jobr, tag, l, mid, u << 1);",
		"        if (jobr > mid) modify(jobl, jobr, tag, mid + 1, r, u << 1 | 1);",
		"        push_up(u);",
		"    }",
		"",
		"    Info query(int l, int r) { return query(l, r, 1, n, 1); }",
		"",
		"    Info query(int jobl, int jobr, int l, int r, int u) ",
		"    {",
		"        if (jobl <= l && jobr >= r) return info[u];",
		"",
		"        int mid = (l + r) >> 1;",
		"        push_down(u, mid - l + 1, r - mid);",
		"        if (jobl <= mid && jobr > mid) return query(jobl, jobr, l, mid, u << 1) + query(jobl, jobr, mid + 1, r, u << 1 | 1);",
		"        else if (jobl <= mid) return query(jobl, jobr, l, mid, u << 1);",
		"        else if (jobr > mid) return query(jobl, jobr, mid + 1, r, u << 1 | 1);",
		"        return Info();",
		"    }",
		"};",
		"",
		"struct Laz ",
		"{",
		"    int add = 0;",
		"    void apply(const Laz &tag) ",
		"    { ",
		"        if (tag.add)",
		"        {",
		"            add += tag.add; ",
		"        }",
		"    }",
		"};",
		"",
		"template <typename T>",
		"struct Info ",
		"{",
		"    int sum = 0;",
		"    Info() {}",
		"    Info(T x) : sum(x) {}",
		"    void apply(const Laz &tag, int len) ",
		"    {",
		"        if (tag.add) ",
		"        {",
		"            sum += tag.add * len;",
		"        }",
		"    }",
		"",
		"    Info operator+(const Info &a) const ",
		"    {",
		"        Info res;",
		"        res.sum = sum + a.sum;",
		"        return res;",
		"    }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\SegmentTree2D.h
s("01_data_structures_trees_segmenttree2d_h", {
	t({
		"/**",
		" * 二维线段树模板",
		" * 功能特性:",
		" * - 支持二维区间查询和单点修改",
		" * - 支持二维区间修改和区间查询（懒惰传播）",
		" * - 可扩展到多种操作类型",
		" * 时间复杂度: O(log n * log m)",
		" * 空间复杂度: O(n * m * log n * log m)",
		" *",
		" * 适用于二维数组的区间操作问题",
		" */",
		"",
		"template <typename T>",
		"struct SegmentTree2D {",
		"    struct Node {",
		"        T val;          // 节点值",
		"        T lazy;         // 懒惰标记",
		"        bool has_lazy;  // 是否有懒惰标记",
		"",
		"        Node() : val(T{}), lazy(T{}), has_lazy(false) {}",
		"        Node(T v) : val(v), lazy(T{}), has_lazy(false) {}",
		"    };",
		"",
		"    int n, m;                   // 矩阵的行数和列数",
		"    vector<vector<Node>> tree;  // 二维线段树",
		"",
		"    // 构造函数：创建空的二维线段树",
		"    SegmentTree2D(int rows, int cols) : n(rows), m(cols) {",
		"        tree.assign(4 * n, vector<Node>(4 * m));",
		"        build(1, 0, n - 1);",
		"    }",
		"",
		"    // 构造函数：从给定矩阵创建二维线段树",
		"    SegmentTree2D(const vector<vector<T>>& matrix) : n(matrix.size()), m(matrix[0].size()) {",
		"        tree.assign(4 * n, vector<Node>(4 * m));",
		"        build(matrix, 1, 0, n - 1);",
		"    }",
		"",
		"    // 从矩阵构建二维线段树",
		"    void build(const vector<vector<T>>& matrix, int vx, int lx, int rx) {",
		"        if (lx == rx) {",
		"            build_y(matrix, vx, 1, 0, m - 1, lx);",
		"        } else {",
		"            int mx = (lx + rx) / 2;",
		"            build(matrix, 2 * vx, lx, mx);",
		"            build(matrix, 2 * vx + 1, mx + 1, rx);",
		"            merge_y(vx, 1, 0, m - 1);",
		"        }",
		"    }",
		"",
		"    // 构建Y维度的线段树",
		"    void build_y(const vector<vector<T>>& matrix, int vx, int vy, int ly, int ry, int x) {",
		"        if (ly == ry) {",
		"            if (vx >= n) {",
		"                tree[vx][vy] = Node(matrix[x][ly]);",
		"            } else {",
		"                tree[vx][vy] = Node(tree[2 * vx][vy].val + tree[2 * vx + 1][vy].val);",
		"            }",
		"        } else {",
		"            int my = (ly + ry) / 2;",
		"            build_y(matrix, vx, 2 * vy, ly, my, x);",
		"            build_y(matrix, vx, 2 * vy + 1, my + 1, ry, x);",
		"            tree[vx][vy] = Node(tree[vx][2 * vy].val + tree[vx][2 * vy + 1].val);",
		"        }",
		"    }",
		"",
		"    // 合并Y维度的节点",
		"    void merge_y(int vx, int vy, int ly, int ry) {",
		"        if (ly == ry) {",
		"            tree[vx][vy] = Node(tree[2 * vx][vy].val + tree[2 * vx + 1][vy].val);",
		"        } else {",
		"            int my = (ly + ry) / 2;",
		"            merge_y(vx, 2 * vy, ly, my);",
		"            merge_y(vx, 2 * vy + 1, my + 1, ry);",
		"            tree[vx][vy] = Node(tree[vx][2 * vy].val + tree[vx][2 * vy + 1].val);",
		"        }",
		"    }",
		"",
		"    // 构建空树",
		"    void build(int vx, int lx, int rx) {",
		"        if (lx == rx) {",
		"            build_y(vx, 1, 0, m - 1);",
		"        } else {",
		"            int mx = (lx + rx) / 2;",
		"            build(2 * vx, lx, mx);",
		"            build(2 * vx + 1, mx + 1, rx);",
		"            merge_y(vx, 1, 0, m - 1);",
		"        }",
		"    }",
		"",
		"    void build_y(int vx, int vy, int ly, int ry) {",
		"        if (ly == ry) {",
		"            if (vx >= n) {",
		"                tree[vx][vy] = Node(T{});",
		"            } else {",
		"                tree[vx][vy] = Node(tree[2 * vx][vy].val + tree[2 * vx + 1][vy].val);",
		"            }",
		"        } else {",
		"            int my = (ly + ry) / 2;",
		"            build_y(vx, 2 * vy, ly, my);",
		"            build_y(vx, 2 * vy + 1, my + 1, ry);",
		"            tree[vx][vy] = Node(tree[vx][2 * vy].val + tree[vx][2 * vy + 1].val);",
		"        }",
		"    }",
		"",
		"    // 单点更新",
		"    void update(int x, int y, T val) { update_x(1, 0, n - 1, x, y, val); }",
		"",
		"    void update_x(int vx, int lx, int rx, int x, int y, T val) {",
		"        if (lx == rx) {",
		"            update_y(vx, 1, 0, m - 1, y, val);",
		"        } else {",
		"            int mx = (lx + rx) / 2;",
		"            if (x <= mx) {",
		"                update_x(2 * vx, lx, mx, x, y, val);",
		"            } else {",
		"                update_x(2 * vx + 1, mx + 1, rx, x, y, val);",
		"            }",
		"            merge_y(vx, 1, 0, m - 1);",
		"        }",
		"    }",
		"",
		"    void update_y(int vx, int vy, int ly, int ry, int y, T val) {",
		"        if (ly == ry) {",
		"            tree[vx][vy] = Node(val);",
		"        } else {",
		"            int my = (ly + ry) / 2;",
		"            if (y <= my) {",
		"                update_y(vx, 2 * vy, ly, my, y, val);",
		"            } else {",
		"                update_y(vx, 2 * vy + 1, my + 1, ry, y, val);",
		"            }",
		"            tree[vx][vy] = Node(tree[vx][2 * vy].val + tree[vx][2 * vy + 1].val);",
		"        }",
		"    }",
		"",
		"    // 区间查询",
		"    T query(int x1, int y1, int x2, int y2) { return query_x(1, 0, n - 1, x1, x2, y1, y2); }",
		"",
		"    T query_x(int vx, int lx, int rx, int x1, int x2, int y1, int y2) {",
		"        if (x1 > rx || x2 < lx) return T{};",
		"        if (x1 <= lx && rx <= x2) { return query_y(vx, 1, 0, m - 1, y1, y2); }",
		"",
		"        int mx = (lx + rx) / 2;",
		"        return query_x(2 * vx, lx, mx, x1, x2, y1, y2) + query_x(2 * vx + 1, mx + 1, rx, x1, x2, y1, y2);",
		"    }",
		"",
		"    T query_y(int vx, int vy, int ly, int ry, int y1, int y2) {",
		"        if (y1 > ry || y2 < ly) return T{};",
		"        if (y1 <= ly && ry <= y2) { return tree[vx][vy].val; }",
		"",
		"        int my = (ly + ry) / 2;",
		"        return query_y(vx, 2 * vy, ly, my, y1, y2) + query_y(vx, 2 * vy + 1, my + 1, ry, y1, y2);",
		"    }",
		"",
		"    // 单点查询",
		"    T query(int x, int y) { return query(x, y, x, y); }",
		"};",
		"",
		"// 支持懒惰传播的二维线段树",
		"template <typename T>",
		"struct SegmentTree2DWithLazy {",
		"    struct Node {",
		"        T val;          // 节点值",
		"        T lazy;         // 懒惰标记",
		"        bool has_lazy;  // 是否有懒惰标记",
		"",
		"        Node() : val(T{}), lazy(T{}), has_lazy(false) {}",
		"        Node(T v) : val(v), lazy(T{}), has_lazy(false) {}",
		"    };",
		"",
		"    int n, m;                   // 矩阵的行数和列数",
		"    vector<vector<Node>> tree;  // 二维线段树",
		"",
		"    SegmentTree2DWithLazy(int rows, int cols) : n(rows), m(cols) {",
		"        tree.assign(4 * n, vector<Node>(4 * m));",
		"        build(1, 0, n - 1);",
		"    }",
		"",
		"    void build(int vx, int lx, int rx) {",
		"        if (lx == rx) {",
		"            build_y(vx, 1, 0, m - 1, lx, rx);",
		"        } else {",
		"            int mx = (lx + rx) / 2;",
		"            build(2 * vx, lx, mx);",
		"            build(2 * vx + 1, mx + 1, rx);",
		"            merge_y(vx, 1, 0, m - 1, lx, rx);",
		"        }",
		"    }",
		"",
		"    void build_y(int vx, int vy, int ly, int ry, int lx, int rx) {",
		"        tree[vx][vy] = Node(T{});",
		"        if (ly != ry) {",
		"            int my = (ly + ry) / 2;",
		"            build_y(vx, 2 * vy, ly, my, lx, rx);",
		"            build_y(vx, 2 * vy + 1, my + 1, ry, lx, rx);",
		"        }",
		"    }",
		"",
		"    void merge_y(int vx, int vy, int ly, int ry, int lx, int rx) {",
		"        if (ly == ry) {",
		"            if (lx == rx) {",
		"                // 叶子节点无需合并",
		"            } else {",
		"                tree[vx][vy].val = tree[2 * vx][vy].val + tree[2 * vx + 1][vy].val;",
		"            }",
		"        } else {",
		"            int my = (ly + ry) / 2;",
		"            merge_y(vx, 2 * vy, ly, my, lx, rx);",
		"            merge_y(vx, 2 * vy + 1, my + 1, ry, lx, rx);",
		"            tree[vx][vy].val = tree[vx][2 * vy].val + tree[vx][2 * vy + 1].val;",
		"        }",
		"    }",
		"",
		"    // Y维度懒惰传播",
		"    void push_down_y(int vx, int vy, int ly, int ry) {",
		"        if (tree[vx][vy].has_lazy) {",
		"            tree[vx][vy].val += tree[vx][vy].lazy * (ry - ly + 1);",
		"            if (ly != ry) {",
		"                tree[vx][2 * vy].lazy += tree[vx][vy].lazy;",
		"                tree[vx][2 * vy].has_lazy = true;",
		"                tree[vx][2 * vy + 1].lazy += tree[vx][vy].lazy;",
		"                tree[vx][2 * vy + 1].has_lazy = true;",
		"            }",
		"            tree[vx][vy].lazy = T{};",
		"            tree[vx][vy].has_lazy = false;",
		"        }",
		"    }",
		"",
		"    // X维度懒惰传播",
		"    void push_down_x(int vx, int lx, int rx) {",
		"        if (lx != rx) {",
		"            // 如果需要X维度的懒惰传播，在此实现",
		"            // 目前的实现主要针对Y维度的区间更新",
		"        }",
		"    }",
		"",
		"    // 区间更新",
		"    void update(int x1, int y1, int x2, int y2, T val) { update_x(1, 0, n - 1, x1, x2, y1, y2, val); }",
		"",
		"    void update_x(int vx, int lx, int rx, int x1, int x2, int y1, int y2, T val) {",
		"        if (x1 > rx || x2 < lx) return;",
		"        if (x1 <= lx && rx <= x2) {",
		"            update_y(vx, 1, 0, m - 1, y1, y2, val, lx, rx);",
		"            return;",
		"        }",
		"",
		"        push_down_x(vx, lx, rx);",
		"        int mx = (lx + rx) / 2;",
		"        update_x(2 * vx, lx, mx, x1, x2, y1, y2, val);",
		"        update_x(2 * vx + 1, mx + 1, rx, x1, x2, y1, y2, val);",
		"        merge_y(vx, 1, 0, m - 1, lx, rx);",
		"    }",
		"",
		"    void update_y(int vx, int vy, int ly, int ry, int y1, int y2, T val, int lx, int rx) {",
		"        if (y1 > ry || y2 < ly) return;",
		"        if (y1 <= ly && ry <= y2) {",
		"            tree[vx][vy].lazy += val;",
		"            tree[vx][vy].has_lazy = true;",
		"            push_down_y(vx, vy, ly, ry);",
		"            return;",
		"        }",
		"",
		"        push_down_y(vx, vy, ly, ry);",
		"        int my = (ly + ry) / 2;",
		"        update_y(vx, 2 * vy, ly, my, y1, y2, val, lx, rx);",
		"        update_y(vx, 2 * vy + 1, my + 1, ry, y1, y2, val, lx, rx);",
		"",
		"        // 更新后重新计算节点值",
		"        push_down_y(vx, 2 * vy, ly, my);",
		"        push_down_y(vx, 2 * vy + 1, my + 1, ry);",
		"        tree[vx][vy].val = tree[vx][2 * vy].val + tree[vx][2 * vy + 1].val;",
		"    }",
		"",
		"    // 区间查询",
		"    T query(int x1, int y1, int x2, int y2) { return query_x(1, 0, n - 1, x1, x2, y1, y2); }",
		"",
		"    T query_x(int vx, int lx, int rx, int x1, int x2, int y1, int y2) {",
		"        if (x1 > rx || x2 < lx) return T{};",
		"        if (x1 <= lx && rx <= x2) { return query_y(vx, 1, 0, m - 1, y1, y2); }",
		"",
		"        push_down_x(vx, lx, rx);",
		"        int mx = (lx + rx) / 2;",
		"        return query_x(2 * vx, lx, mx, x1, x2, y1, y2) + query_x(2 * vx + 1, mx + 1, rx, x1, x2, y1, y2);",
		"    }",
		"",
		"    T query_y(int vx, int vy, int ly, int ry, int y1, int y2) {",
		"        if (y1 > ry || y2 < ly) return T{};",
		"",
		"        push_down_y(vx, vy, ly, ry);",
		"",
		"        if (y1 <= ly && ry <= y2) { return tree[vx][vy].val; }",
		"",
		"        int my = (ly + ry) / 2;",
		"        return query_y(vx, 2 * vy, ly, my, y1, y2) + query_y(vx, 2 * vy + 1, my + 1, ry, y1, y2);",
		"    }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\Splay.h
s("01_data_structures_trees_splay_h", {
	t({
		"/**",
		" * Splay树（伸展树）",
		" * 功能：",
		" * - 支持插入、删除、查找操作",
		" * - 支持区间操作（翻转、查询等）",
		" * - 支持排名查询、第k小元素查询",
		" * - 自适应平衡，常用元素会被调整到根附近",
		" * 时间复杂度：均摊 O(log n)",
		" * 空间复杂度：O(n)",
		" */",
		"",
		"template <typename T>",
		"struct SplayTree {",
		"    struct Node {",
		"        T val;         // 节点值",
		"        int size;      // 子树大小",
		"        int cnt;       // 重复元素个数",
		"        Node* ch[2];   // 左右儿子",
		"        Node* father;  // 父节点",
		"        bool reverse;  // 翻转标记（用于区间操作）",
		"",
		"        Node(T v) : val(v), size(1), cnt(1), father(nullptr), reverse(false) { ch[0] = ch[1] = nullptr; }",
		"    };",
		"",
		"    Node* root;",
		"",
		"    SplayTree() : root(nullptr) {}",
		"",
		"    // 更新节点信息",
		"    void update(Node* x) {",
		"        if (!x) return;",
		"        x->size = x->cnt;",
		"        if (x->ch[0]) x->size += x->ch[0]->size;",
		"        if (x->ch[1]) x->size += x->ch[1]->size;",
		"    }",
		"",
		"    // 下推翻转标记",
		"    void push_down(Node* x) {",
		"        if (!x || !x->reverse) return;",
		"        swap(x->ch[0], x->ch[1]);",
		"        if (x->ch[0]) x->ch[0]->reverse ^= true;",
		"        if (x->ch[1]) x->ch[1]->reverse ^= true;",
		"        x->reverse = false;",
		"    }",
		"",
		"    // 获取x是父节点的哪个儿子（0表示左儿子，1表示右儿子）",
		"    int get_relation(Node* x) { return x->father->ch[1] == x; }",
		"",
		"    // 旋转操作",
		"    void rotate(Node* x) {",
		"        Node* y = x->father;",
		"        Node* z = y->father;",
		"        int k = get_relation(x);",
		"",
		"        // 更新z的儿子指针",
		"        if (z) z->ch[get_relation(y)] = x;",
		"        x->father = z;",
		"",
		"        // 更新y和x的关系",
		"        y->ch[k] = x->ch[k ^ 1];",
		"        if (x->ch[k ^ 1]) x->ch[k ^ 1]->father = y;",
		"",
		"        x->ch[k ^ 1] = y;",
		"        y->father = x;",
		"",
		"        // 更新大小信息",
		"        update(y);",
		"        update(x);",
		"    }",
		"",
		"    // Splay操作：将x旋转到goal的儿子位置",
		"    void splay(Node* x, Node* goal = nullptr) {",
		"        if (!x) return;",
		"",
		"        while (x->father != goal) {",
		"            Node* y = x->father;",
		"            if (y->father != goal) {",
		"                // 双旋转优化",
		"                if (get_relation(x) == get_relation(y)) {",
		"                    rotate(y);",
		"                } else {",
		"                    rotate(x);",
		"                }",
		"            }",
		"            rotate(x);",
		"        }",
		"",
		"        if (!goal) root = x;",
		"    }",
		"",
		"    // 插入值val",
		"    void insert(T val) {",
		"        if (!root) {",
		"            root = new Node(val);",
		"            return;",
		"        }",
		"",
		"        Node* cur = root;",
		"        Node* parent = nullptr;",
		"",
		"        while (cur) {",
		"            parent = cur;",
		"            if (val == cur->val) {",
		"                cur->cnt++;",
		"                update(cur);",
		"                splay(cur);",
		"                return;",
		"            }",
		"            cur = cur->ch[val > cur->val];",
		"        }",
		"",
		"        Node* new_node = new Node(val);",
		"        new_node->father = parent;",
		"        parent->ch[val > parent->val] = new_node;",
		"",
		"        splay(new_node);",
		"    }",
		"",
		"    // 查找值val对应的节点",
		"    Node* find(T val) {",
		"        Node* cur = root;",
		"        while (cur) {",
		"            if (val == cur->val) {",
		"                splay(cur);",
		"                return cur;",
		"            }",
		"            cur = cur->ch[val > cur->val];",
		"        }",
		"        return nullptr;",
		"    }",
		"",
		"    // 查找前驱（小于val的最大值）",
		"    Node* predecessor(T val) {",
		"        Node* cur = root;",
		"        Node* result = nullptr;",
		"",
		"        while (cur) {",
		"            if (cur->val < val) {",
		"                result = cur;",
		"                cur = cur->ch[1];",
		"            } else {",
		"                cur = cur->ch[0];",
		"            }",
		"        }",
		"",
		"        if (result) splay(result);",
		"        return result;",
		"    }",
		"",
		"    // 查找后继（大于val的最小值）",
		"    Node* successor(T val) {",
		"        Node* cur = root;",
		"        Node* result = nullptr;",
		"",
		"        while (cur) {",
		"            if (cur->val > val) {",
		"                result = cur;",
		"                cur = cur->ch[0];",
		"            } else {",
		"                cur = cur->ch[1];",
		"            }",
		"        }",
		"",
		"        if (result) splay(result);",
		"        return result;",
		"    }",
		"",
		"    // 删除值val",
		"    void erase(T val) {",
		"        Node* node = find(val);",
		"        if (!node) return;",
		"",
		"        if (node->cnt > 1) {",
		"            node->cnt--;",
		"            update(node);",
		"            return;",
		"        }",
		"",
		"        if (!node->ch[0] && !node->ch[1]) {",
		"            root = nullptr;",
		"        } else if (!node->ch[0]) {",
		"            root = node->ch[1];",
		"            root->father = nullptr;",
		"        } else if (!node->ch[1]) {",
		"            root = node->ch[0];",
		"            root->father = nullptr;",
		"        } else {",
		"            Node* pred = predecessor(val);",
		"            splay(pred);",
		"            pred->ch[1] = node->ch[1];",
		"            if (node->ch[1]) node->ch[1]->father = pred;",
		"            update(pred);",
		"        }",
		"",
		"        delete node;",
		"    }",
		"",
		"    // 查找第k小的元素（1-indexed）",
		"    T kth_element(int k) {",
		"        Node* cur = root;",
		"",
		"        while (cur) {",
		"            push_down(cur);",
		"            int left_size = cur->ch[0] ? cur->ch[0]->size : 0;",
		"",
		"            if (k <= left_size) {",
		"                cur = cur->ch[0];",
		"            } else if (k <= left_size + cur->cnt) {",
		"                splay(cur);",
		"                return cur->val;",
		"            } else {",
		"                k -= left_size + cur->cnt;",
		"                cur = cur->ch[1];",
		"            }",
		"        }",
		"",
		"        return T{};",
		"    }",
		"",
		"    // 查找val的排名（从1开始）",
		"    int get_rank(T val) {",
		"        Node* cur = root;",
		"        int rank = 1;",
		"",
		"        while (cur) {",
		"            if (val <= cur->val) {",
		"                cur = cur->ch[0];",
		"            } else {",
		"                if (cur->ch[0]) rank += cur->ch[0]->size;",
		"                rank += cur->cnt;",
		"                cur = cur->ch[1];",
		"            }",
		"        }",
		"",
		"        return rank;",
		"    }",
		"",
		"    // 获取树的大小",
		"    int size() { return root ? root->size : 0; }",
		"",
		"    // 检查树是否为空",
		"    bool empty() { return root == nullptr; }",
		"};",
		"",
		"// 支持区间操作的Splay树（用于序列操作）",
		"template <typename T>",
		"struct SequenceSplay {",
		"    struct Node {",
		"        T val;",
		"        int size;",
		"        Node* ch[2];",
		"        Node* father;",
		"        bool reverse;",
		"",
		"        Node(T v) : val(v), size(1), father(nullptr), reverse(false) { ch[0] = ch[1] = nullptr; }",
		"    };",
		"",
		"    Node* root;",
		"",
		"    SequenceSplay() : root(nullptr) {}",
		"",
		"    void update(Node* x) {",
		"        if (!x) return;",
		"        x->size = 1;",
		"        if (x->ch[0]) x->size += x->ch[0]->size;",
		"        if (x->ch[1]) x->size += x->ch[1]->size;",
		"    }",
		"",
		"    void push_down(Node* x) {",
		"        if (!x || !x->reverse) return;",
		"        swap(x->ch[0], x->ch[1]);",
		"        if (x->ch[0]) x->ch[0]->reverse ^= true;",
		"        if (x->ch[1]) x->ch[1]->reverse ^= true;",
		"        x->reverse = false;",
		"    }",
		"",
		"    int get_relation(Node* x) { return x->father && x->father->ch[1] == x; }",
		"",
		"    void rotate(Node* x) {",
		"        Node* y = x->father;",
		"        Node* z = y->father;",
		"        int k = get_relation(x);",
		"",
		"        if (z) z->ch[get_relation(y)] = x;",
		"        x->father = z;",
		"",
		"        y->ch[k] = x->ch[k ^ 1];",
		"        if (x->ch[k ^ 1]) x->ch[k ^ 1]->father = y;",
		"",
		"        x->ch[k ^ 1] = y;",
		"        y->father = x;",
		"",
		"        update(y);",
		"        update(x);",
		"    }",
		"",
		"    void splay(Node* x, Node* goal = nullptr) {",
		"        if (!x) return;",
		"",
		"        while (x->father != goal) {",
		"            Node* y = x->father;",
		"            if (y->father != goal) {",
		"                if (get_relation(x) == get_relation(y)) {",
		"                    rotate(y);",
		"                } else {",
		"                    rotate(x);",
		"                }",
		"            }",
		"            rotate(x);",
		"        }",
		"",
		"        if (!goal) root = x;",
		"    }",
		"",
		"    // 将第k个位置的节点splay到根",
		"    Node* kth_node(int k) {",
		"        Node* cur = root;",
		"",
		"        while (cur) {",
		"            push_down(cur);",
		"            int left_size = cur->ch[0] ? cur->ch[0]->size : 0;",
		"",
		"            if (k <= left_size) {",
		"                cur = cur->ch[0];",
		"            } else if (k == left_size + 1) {",
		"                splay(cur);",
		"                return cur;",
		"            } else {",
		"                k -= left_size + 1;",
		"                cur = cur->ch[1];",
		"            }",
		"        }",
		"",
		"        return nullptr;",
		"    }",
		"",
		"    // 在位置pos插入值val",
		"    void insert(int pos, T val) {",
		"        Node* new_node = new Node(val);",
		"",
		"        if (!root) {",
		"            root = new_node;",
		"            return;",
		"        }",
		"",
		"        if (pos == 1) {",
		"            Node* right = kth_node(1);",
		"            new_node->ch[1] = right;",
		"            right->father = new_node;",
		"            root = new_node;",
		"            update(root);",
		"        } else if (pos == size() + 1) {",
		"            Node* left = kth_node(size());",
		"            new_node->ch[0] = left;",
		"            left->father = new_node;",
		"            root = new_node;",
		"            update(root);",
		"        } else {",
		"            Node* left = kth_node(pos - 1);",
		"            Node* right = kth_node(pos);",
		"            splay(right, left);",
		"",
		"            new_node->father = right;",
		"            right->ch[0] = new_node;",
		"            update(right);",
		"            update(left);",
		"        }",
		"    }",
		"",
		"    // 删除位置pos的元素",
		"    void erase(int pos) {",
		"        if (size() == 1) {",
		"            delete root;",
		"            root = nullptr;",
		"            return;",
		"        }",
		"",
		"        if (pos == 1) {",
		"            Node* right = kth_node(2);",
		"            splay(right);",
		"            if (root->ch[0]) {",
		"                delete root->ch[0];",
		"                root->ch[0] = nullptr;",
		"            }",
		"            update(root);",
		"        } else if (pos == size()) {",
		"            Node* left = kth_node(size() - 1);",
		"            splay(left);",
		"            if (root->ch[1]) {",
		"                delete root->ch[1];",
		"                root->ch[1] = nullptr;",
		"            }",
		"            update(root);",
		"        } else {",
		"            Node* left = kth_node(pos - 1);",
		"            Node* right = kth_node(pos + 1);",
		"            splay(right, left);",
		"",
		"            if (right->ch[0]) {",
		"                delete right->ch[0];",
		"                right->ch[0] = nullptr;",
		"            }",
		"            update(right);",
		"            update(left);",
		"        }",
		"    }",
		"",
		"    // 翻转区间[l, r]",
		"    void reverse(int l, int r) {",
		"        if (l == r) return;",
		"",
		"        Node* left = (l == 1) ? nullptr : kth_node(l - 1);",
		"        Node* right = (r == size()) ? nullptr : kth_node(r + 1);",
		"",
		"        if (!left && !right) {",
		"            root->reverse ^= true;",
		"        } else if (!left) {",
		"            splay(right);",
		"            if (root->ch[0]) root->ch[0]->reverse ^= true;",
		"        } else if (!right) {",
		"            splay(left);",
		"            if (root->ch[1]) root->ch[1]->reverse ^= true;",
		"        } else {",
		"            splay(right, left);",
		"            if (right->ch[0]) right->ch[0]->reverse ^= true;",
		"        }",
		"    }",
		"",
		"    // 获取位置pos的值",
		"    T get(int pos) {",
		"        Node* node = kth_node(pos);",
		"        return node ? node->val : T{};",
		"    }",
		"",
		"    // 设置位置pos的值",
		"    void set(int pos, T val) {",
		"        Node* node = kth_node(pos);",
		"        if (node) node->val = val;",
		"    }",
		"",
		"    int size() { return root ? root->size : 0; }",
		"",
		"    bool empty() { return root == nullptr; }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\SplayTree.h
s("01_data_structures_trees_splaytree_h", {
	t({
		"/**",
		" * 数组实现的Splay树模板",
		" * 功能特性:",
		" * - 支持插入、删除、查找操作",
		" * - 支持排名查询",
		" * - 支持前驱后继查询",
		" * 时间复杂度: 均摊 O(log n)",
		" * 空间复杂度: O(n)",
		" */",
		"",
		"template <typename T>",
		"struct ArraySplayTree {",
		"    struct Node {",
		"        T val;       // 节点值",
		"        int cnt;     // 相同值的数量",
		"        int size;    // 子树大小",
		"        int ch[2];   // 左右子树",
		"        int father;  // 父节点",
		"",
		"        Node() : val(T{}), cnt(0), size(0), father(0) { ch[0] = ch[1] = 0; }",
		"",
		"        Node(T v) : val(v), cnt(1), size(1), father(0) { ch[0] = ch[1] = 0; }",
		"    };",
		"",
		"    vector<Node> tree;",
		"    int root, node_count;",
		"",
		"    ArraySplayTree(int max_size = 100000) : root(0), node_count(0) { tree.resize(max_size + 5); }",
		"",
		"    // 创建新节点",
		"    int new_node(T val) {",
		"        tree[++node_count] = Node(val);",
		"        return node_count;",
		"    }",
		"",
		"    // 更新节点信息",
		"    void update(int x) {",
		"        if (!x) return;",
		"        tree[x].size = tree[tree[x].ch[0]].size + tree[tree[x].ch[1]].size + tree[x].cnt;",
		"    }",
		"",
		"    // 获取x是父节点的哪个儿子",
		"    bool get_relation(int x) { return tree[tree[x].father].ch[1] == x; }",
		"",
		"    // 旋转操作",
		"    void rotate(int x) {",
		"        int y = tree[x].father;",
		"        int z = tree[y].father;",
		"        int k = get_relation(x);",
		"",
		"        // 连接z和x",
		"        tree[z].ch[get_relation(y)] = x;",
		"        tree[x].father = z;",
		"",
		"        // 连接y和x的子树",
		"        tree[y].ch[k] = tree[x].ch[k ^ 1];",
		"        tree[tree[x].ch[k ^ 1]].father = y;",
		"",
		"        tree[x].ch[k ^ 1] = y;",
		"        tree[y].father = x;",
		"",
		"        // 更新节点信息",
		"        update(y);",
		"        update(x);",
		"    }",
		"",
		"    // Splay操作",
		"    void splay(int x, int goal = 0) {",
		"        while (tree[x].father != goal) {",
		"            int y = tree[x].father;",
		"            if (tree[y].father != goal) {",
		"                if (get_relation(x) == get_relation(y)) {",
		"                    rotate(y);",
		"                } else {",
		"                    rotate(x);",
		"                }",
		"            }",
		"            rotate(x);",
		"        }",
		"",
		"        if (!goal) root = x;",
		"    }",
		"",
		"    // 插入值val",
		"    void insert(T val) {",
		"        if (!root) {",
		"            root = new_node(val);",
		"            return;",
		"        }",
		"",
		"        int cur = root, parent = 0;",
		"        while (cur && tree[cur].val != val) {",
		"            parent = cur;",
		"            cur = tree[cur].ch[val > tree[cur].val];",
		"        }",
		"",
		"        if (cur) {",
		"            tree[cur].cnt++;",
		"        } else {",
		"            cur = new_node(val);",
		"            tree[cur].father = parent;",
		"            tree[parent].ch[val > tree[parent].val] = cur;",
		"        }",
		"",
		"        splay(cur);",
		"    }",
		"",
		"    // 查找值val",
		"    int find(T val) {",
		"        int cur = root;",
		"        while (cur && tree[cur].val != val) { cur = tree[cur].ch[val > tree[cur].val]; }",
		"        if (cur) splay(cur);",
		"        return cur;",
		"    }",
		"",
		"    // 寻找前驱",
		"    int predecessor() {",
		"        int cur = tree[root].ch[0];",
		"        if (!cur) return 0;",
		"        while (tree[cur].ch[1]) cur = tree[cur].ch[1];",
		"        return cur;",
		"    }",
		"",
		"    // 寻找后继",
		"    int successor() {",
		"        int cur = tree[root].ch[1];",
		"        if (!cur) return 0;",
		"        while (tree[cur].ch[0]) cur = tree[cur].ch[0];",
		"        return cur;",
		"    }",
		"",
		"    // 删除值val",
		"    void erase(T val) {",
		"        int cur = find(val);",
		"        if (!cur) return;",
		"",
		"        if (tree[cur].cnt > 1) {",
		"            tree[cur].cnt--;",
		"            update(cur);",
		"            return;",
		"        }",
		"",
		"        if (!tree[cur].ch[0] && !tree[cur].ch[1]) {",
		"            root = 0;",
		"            return;",
		"        }",
		"",
		"        if (!tree[cur].ch[0]) {",
		"            root = tree[cur].ch[1];",
		"            tree[root].father = 0;",
		"            return;",
		"        }",
		"",
		"        if (!tree[cur].ch[1]) {",
		"            root = tree[cur].ch[0];",
		"            tree[root].father = 0;",
		"            return;",
		"        }",
		"",
		"        int pred = predecessor();",
		"        splay(pred);",
		"        tree[pred].ch[1] = tree[cur].ch[1];",
		"        tree[tree[cur].ch[1]].father = pred;",
		"        update(pred);",
		"    }",
		"",
		"    // 查找第k小元素",
		"    T kth_element(int k) {",
		"        int cur = root;",
		"        while (cur) {",
		"            int left_size = tree[tree[cur].ch[0]].size;",
		"            if (k <= left_size) {",
		"                cur = tree[cur].ch[0];",
		"            } else if (k <= left_size + tree[cur].cnt) {",
		"                return tree[cur].val;",
		"            } else {",
		"                k -= left_size + tree[cur].cnt;",
		"                cur = tree[cur].ch[1];",
		"            }",
		"        }",
		"        return T{};",
		"    }",
		"",
		"    // 获取val的排名",
		"    int get_rank(T val) {",
		"        int cur = root, rank = 1;",
		"        while (cur) {",
		"            if (val <= tree[cur].val) {",
		"                cur = tree[cur].ch[0];",
		"            } else {",
		"                rank += tree[tree[cur].ch[0]].size + tree[cur].cnt;",
		"                cur = tree[cur].ch[1];",
		"            }",
		"        }",
		"        return rank;",
		"    }",
		"",
		"    // 查找前驱值",
		"    T predecessor_val(T val) {",
		"        int cur = root;",
		"        T result = T{};",
		"        bool found = false;",
		"",
		"        while (cur) {",
		"            if (tree[cur].val < val) {",
		"                if (!found || tree[cur].val > result) {",
		"                    result = tree[cur].val;",
		"                    found = true;",
		"                }",
		"                cur = tree[cur].ch[1];",
		"            } else {",
		"                cur = tree[cur].ch[0];",
		"            }",
		"        }",
		"",
		"        return found ? result : T{};",
		"    }",
		"",
		"    // 查找后继值",
		"    T successor_val(T val) {",
		"        int cur = root;",
		"        T result = T{};",
		"        bool found = false;",
		"",
		"        while (cur) {",
		"            if (tree[cur].val > val) {",
		"                if (!found || tree[cur].val < result) {",
		"                    result = tree[cur].val;",
		"                    found = true;",
		"                }",
		"                cur = tree[cur].ch[0];",
		"            } else {",
		"                cur = tree[cur].ch[1];",
		"            }",
		"        }",
		"",
		"        return found ? result : T{};",
		"    }",
		"",
		"    // 获取树的大小",
		"    int size() { return root ? tree[root].size : 0; }",
		"",
		"    // 检查树是否为空",
		"    bool empty() { return root == 0; }",
		"",
		"    // 清空树",
		"    void clear() { root = node_count = 0; }",
		"",
		"    // 中序遍历（用于调试）",
		"    void inorder(int x, vector<T>& result) {",
		"        if (!x) return;",
		"        inorder(tree[x].ch[0], result);",
		"        for (int i = 0; i < tree[x].cnt; i++) { result.push_back(tree[x].val); }",
		"        inorder(tree[x].ch[1], result);",
		"    }",
		"",
		"    // 获取中序遍历结果",
		"    vector<T> get_sorted() {",
		"        vector<T> result;",
		"        inorder(root, result);",
		"        return result;",
		"    }",
		"",
		"    // 检查值是否存在",
		"    bool contains(T val) { return find(val) != 0; }",
		"",
		"    // 获取最小值",
		"    T min_value() {",
		"        if (!root) return T{};",
		"        int cur = root;",
		"        while (tree[cur].ch[0]) cur = tree[cur].ch[0];",
		"        return tree[cur].val;",
		"    }",
		"",
		"    // 获取最大值",
		"    T max_value() {",
		"        if (!root) return T{};",
		"        int cur = root;",
		"        while (tree[cur].ch[1]) cur = tree[cur].ch[1];",
		"        return tree[cur].val;",
		"    }",
		"};",
	})
}),

-- 01_Data_Structures\Trees\Treap.h
s("01_data_structures_trees_treap_h", {
	t({
		"/**",
		" * 传统Treap（旋转Treap）",
		" * 功能：",
		" * - 支持插入、删除、查找操作",
		" * - 基于随机优先级维持平衡性",
		" * - 支持排名查询、第k小元素查询",
		" * - 支持前驱、后继查询",
		" * 时间复杂度：期望 O(log n)",
		" * 空间复杂度：O(n)",
		" *",
		" * 与FHQ Treap的区别：",
		" * - 使用旋转操作维持堆性质",
		" * - 实现相对简单，但灵活性不如FHQ Treap",
		" */",
		"",
		"template <typename T>",
		"struct Treap {",
		"    struct Node {",
		"        T val;         // 节点值",
		"        int priority;  // 随机优先级",
		"        int size;      // 子树大小",
		"        int cnt;       // 重复元素个数",
		"        Node* left;    // 左子树",
		"        Node* right;   // 右子树",
		"",
		"        Node(T v) : val(v), priority(rand()), size(1), cnt(1), left(nullptr), right(nullptr) {}",
		"    };",
		"",
		"    Node* root;",
		"    mt19937 rng;",
		"",
		"    Treap() : root(nullptr), rng(random_device{}()) { srand(time(nullptr)); }",
		"",
		"    // 更新节点信息",
		"    void update(Node* x) {",
		"        if (!x) return;",
		"        x->size = x->cnt;",
		"        if (x->left) x->size += x->left->size;",
		"        if (x->right) x->size += x->right->size;",
		"    }",
		"",
		"    // 右旋转",
		"    Node* rotate_right(Node* x) {",
		"        Node* y = x->left;",
		"        x->left = y->right;",
		"        y->right = x;",
		"        update(x);",
		"        update(y);",
		"        return y;",
		"    }",
		"",
		"    // 左旋转",
		"    Node* rotate_left(Node* x) {",
		"        Node* y = x->right;",
		"        x->right = y->left;",
		"        y->left = x;",
		"        update(x);",
		"        update(y);",
		"        return y;",
		"    }",
		"",
		"    // 插入操作",
		"    Node* insert(Node* x, T val) {",
		"        if (!x) return new Node(val);",
		"",
		"        if (val == x->val) {",
		"            x->cnt++;",
		"            update(x);",
		"            return x;",
		"        }",
		"",
		"        if (val < x->val) {",
		"            x->left = insert(x->left, val);",
		"            if (x->left->priority > x->priority) { x = rotate_right(x); }",
		"        } else {",
		"            x->right = insert(x->right, val);",
		"            if (x->right->priority > x->priority) { x = rotate_left(x); }",
		"        }",
		"",
		"        update(x);",
		"        return x;",
		"    }",
		"",
		"    // 删除操作",
		"    Node* remove(Node* x, T val) {",
		"        if (!x) return x;",
		"",
		"        if (val < x->val) {",
		"            x->left = remove(x->left, val);",
		"        } else if (val > x->val) {",
		"            x->right = remove(x->right, val);",
		"        } else {",
		"            if (x->cnt > 1) {",
		"                x->cnt--;",
		"                update(x);",
		"                return x;",
		"            }",
		"",
		"            if (!x->left && !x->right) {",
		"                delete x;",
		"                return nullptr;",
		"            } else if (!x->left) {",
		"                Node* temp = x->right;",
		"                delete x;",
		"                return temp;",
		"            } else if (!x->right) {",
		"                Node* temp = x->left;",
		"                delete x;",
		"                return temp;",
		"            } else {",
		"                if (x->left->priority > x->right->priority) {",
		"                    x = rotate_right(x);",
		"                    x->right = remove(x->right, val);",
		"                } else {",
		"                    x = rotate_left(x);",
		"                    x->left = remove(x->left, val);",
		"                }",
		"            }",
		"        }",
		"",
		"        update(x);",
		"        return x;",
		"    }",
		"",
		"    // 查找操作",
		"    bool find(Node* x, T val) {",
		"        if (!x) return false;",
		"        if (val == x->val) return true;",
		"        if (val < x->val) return find(x->left, val);",
		"        return find(x->right, val);",
		"    }",
		"",
		"    // 查找第k小的元素（1-indexed）",
		"    T kth_element(Node* x, int k) {",
		"        if (!x) return T{};",
		"",
		"        int left_size = x->left ? x->left->size : 0;",
		"        if (k <= left_size) {",
		"            return kth_element(x->left, k);",
		"        } else if (k <= left_size + x->cnt) {",
		"            return x->val;",
		"        } else {",
		"            return kth_element(x->right, k - left_size - x->cnt);",
		"        }",
		"    }",
		"",
		"    // 查找元素的排名（从1开始）",
		"    int get_rank(Node* x, T val) {",
		"        if (!x) return 1;",
		"",
		"        if (val < x->val) {",
		"            return get_rank(x->left, val);",
		"        } else if (val == x->val) {",
		"            return (x->left ? x->left->size : 0) + 1;",
		"        } else {",
		"            return (x->left ? x->left->size : 0) + x->cnt + get_rank(x->right, val);",
		"        }",
		"    }",
		"",
		"    // 查找前驱（小于val的最大元素）",
		"    T predecessor(Node* x, T val) {",
		"        if (!x) return T{};",
		"",
		"        if (x->val >= val) {",
		"            return predecessor(x->left, val);",
		"        } else {",
		"            T right_pred = predecessor(x->right, val);",
		"            return (x->right && right_pred != T{}) ? right_pred : x->val;",
		"        }",
		"    }",
		"",
		"    // 查找后继（大于val的最小元素）",
		"    T successor(Node* x, T val) {",
		"        if (!x) return T{};",
		"",
		"        if (x->val <= val) {",
		"            return successor(x->right, val);",
		"        } else {",
		"            T left_succ = successor(x->left, val);",
		"            return (x->left && left_succ != T{}) ? left_succ : x->val;",
		"        }",
		"    }",
		"",
		"    // 公共接口",
		"    void insert(T val) { root = insert(root, val); }",
		"    void remove(T val) { root = remove(root, val); }",
		"    bool find(T val) { return find(root, val); }",
		"    T kth_element(int k) { return kth_element(root, k); }",
		"    int get_rank(T val) { return get_rank(root, val); }",
		"    T predecessor(T val) { return predecessor(root, val); }",
		"    T successor(T val) { return successor(root, val); }",
		"",
		"    int size() { return root ? root->size : 0; }",
		"    bool empty() { return root == nullptr; }",
		"",
		"    // 清空树",
		"    void clear() {",
		"        clear_helper(root);",
		"        root = nullptr;",
		"    }",
		"",
		"   private:",
		"    void clear_helper(Node* x) {",
		"        if (!x) return;",
		"        clear_helper(x->left);",
		"        clear_helper(x->right);",
		"        delete x;",
		"    }",
		"};",
		"",
		"// 数组版Treap实现（内存效率更高）",
		"struct ArrayTreap {",
		"    struct Node {",
		"        int val;          // 节点值",
		"        int priority;     // 随机优先级",
		"        int size;         // 子树大小",
		"        int cnt;          // 重复元素个数",
		"        int left, right;  // 左右子树编号",
		"",
		"        Node() : val(0), priority(0), size(0), cnt(0), left(0), right(0) {}",
		"        Node(int v) : val(v), priority(rand()), size(1), cnt(1), left(0), right(0) {}",
		"    };",
		"",
		"    vector<Node> tree;",
		"    int root, node_count;",
		"",
		"    ArrayTreap(int max_size = 100000) : root(0), node_count(0) {",
		"        tree.resize(max_size + 5);",
		"        srand(time(nullptr));",
		"    }",
		"",
		"    // 创建新节点",
		"    int new_node(int val) {",
		"        tree[++node_count] = Node(val);",
		"        return node_count;",
		"    }",
		"",
		"    // 更新节点信息",
		"    void update(int x) {",
		"        if (!x) return;",
		"        tree[x].size = tree[x].cnt;",
		"        if (tree[x].left) tree[x].size += tree[tree[x].left].size;",
		"        if (tree[x].right) tree[x].size += tree[tree[x].right].size;",
		"    }",
		"",
		"    // 右旋转",
		"    int rotate_right(int x) {",
		"        int y = tree[x].left;",
		"        tree[x].left = tree[y].right;",
		"        tree[y].right = x;",
		"        update(x);",
		"        update(y);",
		"        return y;",
		"    }",
		"",
		"    // 左旋转",
		"    int rotate_left(int x) {",
		"        int y = tree[x].right;",
		"        tree[x].right = tree[y].left;",
		"        tree[y].left = x;",
		"        update(x);",
		"        update(y);",
		"        return y;",
		"    }",
		"",
		"    // 插入操作",
		"    int insert(int x, int val) {",
		"        if (!x) return new_node(val);",
		"",
		"        if (val == tree[x].val) {",
		"            tree[x].cnt++;",
		"            update(x);",
		"            return x;",
		"        }",
		"",
		"        if (val < tree[x].val) {",
		"            tree[x].left = insert(tree[x].left, val);",
		"            if (tree[tree[x].left].priority > tree[x].priority) { x = rotate_right(x); }",
		"        } else {",
		"            tree[x].right = insert(tree[x].right, val);",
		"            if (tree[tree[x].right].priority > tree[x].priority) { x = rotate_left(x); }",
		"        }",
		"",
		"        update(x);",
		"        return x;",
		"    }",
		"",
		"    // 删除操作",
		"    int remove(int x, int val) {",
		"        if (!x) return x;",
		"",
		"        if (val < tree[x].val) {",
		"            tree[x].left = remove(tree[x].left, val);",
		"        } else if (val > tree[x].val) {",
		"            tree[x].right = remove(tree[x].right, val);",
		"        } else {",
		"            if (tree[x].cnt > 1) {",
		"                tree[x].cnt--;",
		"                update(x);",
		"                return x;",
		"            }",
		"",
		"            if (!tree[x].left && !tree[x].right) {",
		"                return 0;",
		"            } else if (!tree[x].left) {",
		"                return tree[x].right;",
		"            } else if (!tree[x].right) {",
		"                return tree[x].left;",
		"            } else {",
		"                if (tree[tree[x].left].priority > tree[tree[x].right].priority) {",
		"                    x = rotate_right(x);",
		"                    tree[x].right = remove(tree[x].right, val);",
		"                } else {",
		"                    x = rotate_left(x);",
		"                    tree[x].left = remove(tree[x].left, val);",
		"                }",
		"            }",
		"        }",
		"",
		"        update(x);",
		"        return x;",
		"    }",
		"",
		"    // 查找第k小的元素",
		"    int kth_element(int x, int k) {",
		"        if (!x) return -1;",
		"",
		"        int left_size = tree[x].left ? tree[tree[x].left].size : 0;",
		"        if (k <= left_size) {",
		"            return kth_element(tree[x].left, k);",
		"        } else if (k <= left_size + tree[x].cnt) {",
		"            return tree[x].val;",
		"        } else {",
		"            return kth_element(tree[x].right, k - left_size - tree[x].cnt);",
		"        }",
		"    }",
		"",
		"    // 查找元素的排名",
		"    int get_rank(int x, int val) {",
		"        if (!x) return 1;",
		"",
		"        if (val < tree[x].val) {",
		"            return get_rank(tree[x].left, val);",
		"        } else if (val == tree[x].val) {",
		"            return (tree[x].left ? tree[tree[x].left].size : 0) + 1;",
		"        } else {",
		"            return (tree[x].left ? tree[tree[x].left].size : 0) + tree[x].cnt + get_rank(tree[x].right, val);",
		"        }",
		"    }",
		"",
		"    // 公共接口",
		"    void insert(int val) { root = insert(root, val); }",
		"    void remove(int val) { root = remove(root, val); }",
		"    int kth_element(int k) { return kth_element(root, k); }",
		"    int get_rank(int val) { return get_rank(root, val); }",
		"",
		"    int size() { return root ? tree[root].size : 0; }",
		"    bool empty() { return root == 0; }",
		"    void clear() { root = node_count = 0; }",
		"};",
	})
}),

-- 01_Data_Structures\Union_Find\BasicDSU.h
s("01_data_structures_union_find_basicdsu_h", {
	t({
		"/**",
		" * 基础并查集模板",
		" * 功能：",
		" * - 路径压缩优化",
		" * - 按大小合并优化",
		" * - 连通分量计数",
		" * 时间复杂度：O(α(n)) 均摊，其中α为反阿克曼函数",
		" */",
		"",
		"struct DSU {",
		"    vector<int> f, siz;  // f[i]: 节点i的父节点，siz[i]: 以i为根的集合大小",
		"    int components;      // 连通分量数量",
		"",
		"    DSU() {}",
		"    DSU(int n) { init(n); }",
		"",
		"    // 初始化n个独立的集合",
		"    void init(int n) {",
		"        f.resize(n + 1);",
		"        iota(f.begin(), f.end(), 0);  // 每个节点的父节点初始化为自己",
		"        siz.assign(n + 1, 1);         // 每个集合大小初始化为1",
		"        components = n;               // 初始有n个连通分量",
		"    }",
		"",
		"    // 查找x所属集合的根节点，使用路径压缩优化",
		"    int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }",
		"",
		"    // 判断x和y是否在同一个集合中",
		"    bool same(int x, int y) { return find(x) == find(y); }",
		"",
		"    // 合并x和y所在的集合，返回是否成功合并",
		"    bool merge(int x, int y) {",
		"        x = find(x), y = find(y);",
		"        if (x == y) return false;  // 已经在同一集合中",
		"",
		"        // 按大小合并：将小集合合并到大集合",
		"        if (siz[x] < siz[y]) swap(x, y);",
		"        f[y] = x;",
		"        siz[x] += siz[y];",
		"        components--;",
		"        return true;",
		"    }",
		"",
		"    // 获取x所在集合的大小",
		"    int size(int x) { return siz[find(x)]; }",
		"",
		"    // 获取连通分量的数量",
		"    int count() { return components; }",
		"};",
	})
}),

-- 01_Data_Structures\Union_Find\PersistentDSU.h
s("01_data_structures_union_find_persistentdsu_h", {
	t({
		"/**",
		" * 可持久化并查集 (Persistent Disjoint Set Union)",
		" * 功能：",
		" * - 支持历史版本查询",
		" * - 支持回滚操作",
		" * - 支持从任意版本创建新分支",
		" * 时间复杂度：O(log n) 每次操作",
		" * 空间复杂度：O(n log n)",
		" */",
		"",
		"struct PersistentDSU {",
		"    struct Node {",
		"        int parent, rank;",
		"        Node* left;",
		"        Node* right;",
		"",
		"        Node(int p = 0, int r = 0) : parent(p), rank(r), left(nullptr), right(nullptr) {}",
		"    };",
		"",
		"    vector<Node*> versions;  // 存储各个版本的根节点",
		"    int n;",
		"",
		"    PersistentDSU(int size) : n(size) {",
		"        // 创建初始版本",
		"        versions.push_back(build(1, n));",
		"    }",
		"",
		"    // 构建线段树",
		"    Node* build(int l, int r) {",
		"        Node* node = new Node();",
		"        if (l == r) {",
		"            node->parent = l;",
		"            node->rank = 0;",
		"            return node;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        node->left = build(l, mid);",
		"        node->right = build(mid + 1, r);",
		"        return node;",
		"    }",
		"",
		"    // 查询父节点",
		"    int find(Node* root, int l, int r, int pos) {",
		"        if (l == r) {",
		"            if (root->parent == pos) return pos;",
		"            return find(versions.back(), 1, n, root->parent);",
		"        }",
		"        int mid = (l + r) / 2;",
		"        if (pos <= mid) return find(root->left, l, mid, pos);",
		"        return find(root->right, mid + 1, r, pos);",
		"    }",
		"",
		"    // 更新节点",
		"    Node* update(Node* root, int l, int r, int pos, int parent, int rank) {",
		"        Node* new_node = new Node();",
		"        if (l == r) {",
		"            new_node->parent = parent;",
		"            new_node->rank = rank;",
		"            return new_node;",
		"        }",
		"        int mid = (l + r) / 2;",
		"        if (pos <= mid) {",
		"            new_node->left = update(root->left, l, mid, pos, parent, rank);",
		"            new_node->right = root->right;",
		"        } else {",
		"            new_node->left = root->left;",
		"            new_node->right = update(root->right, mid + 1, r, pos, parent, rank);",
		"        }",
		"        return new_node;",
		"    }",
		"",
		"    // 合并两个集合，返回新版本号",
		"    int unite(int version, int x, int y) {",
		"        Node* root = versions[version];",
		"        int px = find(root, 1, n, x);",
		"        int py = find(root, 1, n, y);",
		"",
		"        if (px == py) {",
		"            versions.push_back(root);",
		"            return versions.size() - 1;",
		"        }",
		"",
		"        // 按秩合并",
		"        // 这里需要获取秩信息，简化实现",
		"        Node* new_root = update(root, 1, n, px, py, 0);",
		"        versions.push_back(new_root);",
		"        return versions.size() - 1;",
		"    }",
		"",
		"    // 查询两个元素是否连通",
		"    bool connected(int version, int x, int y) {",
		"        Node* root = versions[version];",
		"        return find(root, 1, n, x) == find(root, 1, n, y);",
		"    }",
		"",
		"    // 获取当前版本数",
		"    int get_version_count() { return versions.size(); }",
		"};",
	})
}),

-- 01_Data_Structures\Union_Find\WeightedDSU.h
s("01_data_structures_union_find_weighteddsu_h", {
	t({
		"/**",
		" * 带权并查集模板",
		" * 功能：",
		" * - 维护节点间的权值关系",
		" * - 支持路径压缩和权值更新",
		" * - 检查权值关系的一致性",
		" * 时间复杂度：O(α(n)) 均摊",
		" */",
		"",
		"template <typename T>",
		"struct WeightedDSU {",
		"    vector<int> parent;  // parent[i]: 节点i的父节点",
		"    vector<T> weight;    // weight[i]: 节点i到parent[i]的权值",
		"    int n;",
		"",
		"    WeightedDSU(int size) : n(size) {",
		"        parent.resize(n);",
		"        weight.resize(n, T{});",
		"        iota(parent.begin(), parent.end(), 0);  // 初始化每个节点的父节点为自己",
		"    }",
		"",
		"    // 查找根节点并压缩路径，同时更新权值",
		"    pair<int, T> find(int x) {",
		"        if (parent[x] == x) { return {x, T{}}; }",
		"        auto [root, w] = find(parent[x]);",
		"        weight[x] += w;    // 更新到根节点的权值",
		"        parent[x] = root;  // 路径压缩",
		"        return {root, weight[x]};",
		"    }",
		"",
		"    // 合并两个集合，建立权值关系 weight[y] = weight[x] + w",
		"    bool union_sets(int x, int y, T w) {",
		"        auto [root_x, weight_x] = find(x);",
		"        auto [root_y, weight_y] = find(y);",
		"",
		"        if (root_x == root_y) {",
		"            // 检查权值关系是否一致",
		"            return weight_x + w == weight_y;",
		"        }",
		"",
		"        // 将root_y的父节点设为root_x，并设置权值",
		"        parent[root_y] = root_x;",
		"        weight[root_y] = weight_x + w - weight_y;",
		"        return true;",
		"    }",
		"",
		"    // 获取x到y的权值差，如果不在同一集合返回默认值",
		"    T get_weight(int x, int y) {",
		"        auto [root_x, weight_x] = find(x);",
		"        auto [root_y, weight_y] = find(y);",
		"",
		"        if (root_x != root_y) {",
		"            return T{};  // 不在同一集合中",
		"        }",
		"",
		"        return weight_y - weight_x;",
		"    }",
		"",
		"    // 判断两个节点是否在同一集合中",
		"    bool same(int x, int y) { return find(x).first == find(y).first; }",
		"};",
	})
}),

-- 02_Graph_Theory\Connectivity\TarjanBridge.h
s("02_graph_theory_connectivity_tarjanbridge_h", {
	t({
		"// Tarjan算法求桥",
		"struct TarjanBridge {",
		"    int n, time_stamp;",
		"    vector<vector<pair<int, int>>> graph;  // {邻接点, 边编号}",
		"    vector<int> dfn, low;",
		"    vector<bool> is_bridge;",
		"    vector<pair<int, int>> bridges;",
		"",
		"    TarjanBridge(int sz, int edge_cnt) : n(sz), time_stamp(0) {",
		"        graph.resize(n);",
		"        dfn.resize(n, -1);",
		"        low.resize(n, -1);",
		"        is_bridge.resize(edge_cnt, false);",
		"    }",
		"",
		"    void add_edge(int u, int v, int edge_id) {",
		"        graph[u].push_back({v, edge_id});",
		"        graph[v].push_back({u, edge_id});",
		"    }",
		"",
		"    void tarjan(int u, int parent_edge) {",
		"        dfn[u] = low[u] = time_stamp++;",
		"",
		"        for (auto& edge : graph[u]) {",
		"            int v = edge.first;",
		"            int edge_id = edge.second;",
		"",
		"            if (edge_id == parent_edge) continue;",
		"",
		"            if (dfn[v] == -1) {",
		"                tarjan(v, edge_id);",
		"                low[u] = min(low[u], low[v]);",
		"",
		"                if (low[v] > dfn[u]) {",
		"                    is_bridge[edge_id] = true;",
		"                    bridges.push_back({min(u, v), max(u, v)});",
		"                }",
		"            } else {",
		"                low[u] = min(low[u], dfn[v]);",
		"            }",
		"        }",
		"    }",
		"",
		"    void run() {",
		"        for (int i = 0; i < n; i++) {",
		"            if (dfn[i] == -1) { tarjan(i, -1); }",
		"        }",
		"    }",
		"",
		"    vector<pair<int, int>> get_bridges() { return bridges; }",
		"",
		"    bool is_bridge_edge(int edge_id) { return is_bridge[edge_id]; }",
		"",
		"    // 构建桥连通分量",
		"    vector<int> get_bridge_components() {",
		"        vector<int> comp(n, -1);",
		"        int comp_cnt = 0;",
		"",
		"        function<void(int, int)> dfs = [&](int u, int c) {",
		"            comp[u] = c;",
		"            for (auto& edge : graph[u]) {",
		"                int v = edge.first;",
		"                int edge_id = edge.second;",
		"                if (comp[v] == -1 && !is_bridge[edge_id]) { dfs(v, c); }",
		"            }",
		"        };",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            if (comp[i] == -1) { dfs(i, comp_cnt++); }",
		"        }",
		"",
		"        return comp;",
		"    }",
		"};",
		"",
		"// 使用示例：",
		"// TarjanBridge bridge(n, m);",
		"// bridge.add_edge(u, v, edge_id);",
		"// bridge.run();",
		"// vector<pair<int,int>> bridges = bridge.get_bridges();",
	})
}),

-- 02_Graph_Theory\Connectivity\TarjanCutVertex.h
s("02_graph_theory_connectivity_tarjancutvertex_h", {
	t({
		"// Tarjan算法求割点",
		"struct TarjanCutVertex {",
		"    int n, time_stamp;",
		"    vector<vector<int>> graph;",
		"    vector<int> dfn, low;",
		"    vector<bool> is_cut;",
		"    vector<int> cut_vertices;",
		"",
		"    TarjanCutVertex(int sz) : n(sz), time_stamp(0) {",
		"        graph.resize(n);",
		"        dfn.resize(n, -1);",
		"        low.resize(n, -1);",
		"        is_cut.resize(n, false);",
		"    }",
		"",
		"    void add_edge(int u, int v) {",
		"        graph[u].push_back(v);",
		"        graph[v].push_back(u);",
		"    }",
		"",
		"    void tarjan(int u, int parent) {",
		"        dfn[u] = low[u] = time_stamp++;",
		"        int children = 0;",
		"",
		"        for (int v : graph[u]) {",
		"            if (v == parent) continue;",
		"",
		"            if (dfn[v] == -1) {",
		"                children++;",
		"                tarjan(v, u);",
		"                low[u] = min(low[u], low[v]);",
		"",
		"                // 根节点的判断",
		"                if (parent == -1 && children > 1) { is_cut[u] = true; }",
		"                // 非根节点的判断",
		"                if (parent != -1 && low[v] >= dfn[u]) { is_cut[u] = true; }",
		"            } else {",
		"                low[u] = min(low[u], dfn[v]);",
		"            }",
		"        }",
		"    }",
		"",
		"    void run() {",
		"        for (int i = 0; i < n; i++) {",
		"            if (dfn[i] == -1) { tarjan(i, -1); }",
		"        }",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            if (is_cut[i]) { cut_vertices.push_back(i); }",
		"        }",
		"    }",
		"",
		"    vector<int> get_cut_vertices() { return cut_vertices; }",
		"",
		"    bool is_cut_vertex(int u) { return is_cut[u]; }",
		"",
		"    // 构建点双连通分量",
		"    vector<vector<int>> get_vertex_bcc() {",
		"        vector<vector<int>> bcc;",
		"        vector<int> stk;",
		"",
		"        function<void(int, int)> dfs = [&](int u, int parent) {",
		"            dfn[u] = low[u] = time_stamp++;",
		"            stk.push_back(u);",
		"",
		"            for (int v : graph[u]) {",
		"                if (v == parent) continue;",
		"",
		"                if (dfn[v] == -1) {",
		"                    int stk_size = stk.size();",
		"                    dfs(v, u);",
		"                    low[u] = min(low[u], low[v]);",
		"",
		"                    if (low[v] >= dfn[u]) {",
		"                        vector<int> component;",
		"                        while (stk.size() > stk_size) {",
		"                            component.push_back(stk.back());",
		"                            stk.pop_back();",
		"                        }",
		"                        component.push_back(u);",
		"                        bcc.push_back(component);",
		"                    }",
		"                } else if (dfn[v] < dfn[u]) {",
		"                    low[u] = min(low[u], dfn[v]);",
		"                }",
		"            }",
		"        };",
		"",
		"        // 重置时间戳",
		"        time_stamp = 0;",
		"        fill(dfn.begin(), dfn.end(), -1);",
		"        fill(low.begin(), low.end(), -1);",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            if (dfn[i] == -1) {",
		"                dfs(i, -1);",
		"                if (!stk.empty()) {",
		"                    bcc.push_back(stk);",
		"                    stk.clear();",
		"                }",
		"            }",
		"        }",
		"",
		"        return bcc;",
		"    }",
		"};",
		"",
		"// 使用示例：",
		"// TarjanCutVertex cut(n);",
		"// cut.add_edge(u, v);",
		"// cut.run();",
		"// vector<int> cut_vertices = cut.get_cut_vertices();",
		"// vector<vector<int>> bcc = cut.get_vertex_bcc();",
	})
}),

-- 02_Graph_Theory\Connectivity\TarjanSCC.h
s("02_graph_theory_connectivity_tarjanscc_h", {
	t({
		"// Tarjan算法求强连通分量",
		"struct TarjanSCC {",
		"    int n, scc_cnt, time_stamp;",
		"    vector<vector<int>> graph;",
		"    vector<int> dfn, low, stk, in_stack, scc_id, scc_size;",
		"",
		"    TarjanSCC(int sz) : n(sz), scc_cnt(0), time_stamp(0) {",
		"        graph.resize(n);",
		"        dfn.resize(n, -1);",
		"        low.resize(n, -1);",
		"        in_stack.resize(n, 0);",
		"        scc_id.resize(n, -1);",
		"        scc_size.resize(n, 0);",
		"    }",
		"",
		"    void add_edge(int u, int v) { graph[u].push_back(v); }",
		"",
		"    void tarjan(int u) {",
		"        dfn[u] = low[u] = time_stamp++;",
		"        stk.push_back(u);",
		"        in_stack[u] = 1;",
		"",
		"        for (int v : graph[u]) {",
		"            if (dfn[v] == -1) {",
		"                tarjan(v);",
		"                low[u] = min(low[u], low[v]);",
		"            } else if (in_stack[v]) {",
		"                low[u] = min(low[u], dfn[v]);",
		"            }",
		"        }",
		"",
		"        if (dfn[u] == low[u]) {",
		"            int v;",
		"            do {",
		"                v = stk.back();",
		"                stk.pop_back();",
		"                in_stack[v] = 0;",
		"                scc_id[v] = scc_cnt;",
		"                scc_size[scc_cnt]++;",
		"            } while (v != u);",
		"            scc_cnt++;",
		"        }",
		"    }",
		"",
		"    void run() {",
		"        for (int i = 0; i < n; i++) {",
		"            if (dfn[i] == -1) { tarjan(i); }",
		"        }",
		"        // 重新调整大小",
		"        scc_size.resize(scc_cnt);",
		"    }",
		"",
		"    // 构建缩点后的DAG",
		"    vector<vector<int>> build_dag() {",
		"        vector<vector<int>> dag(scc_cnt);",
		"        vector<set<int>> edge_set(scc_cnt);",
		"",
		"        for (int u = 0; u < n; u++) {",
		"            for (int v : graph[u]) {",
		"                int su = scc_id[u], sv = scc_id[v];",
		"                if (su != sv && edge_set[su].find(sv) == edge_set[su].end()) {",
		"                    dag[su].push_back(sv);",
		"                    edge_set[su].insert(sv);",
		"                }",
		"            }",
		"        }",
		"        return dag;",
		"    }",
		"",
		"    bool is_strongly_connected() { return scc_cnt == 1; }",
		"",
		"    int get_scc_count() { return scc_cnt; }",
		"    int get_scc_id(int u) { return scc_id[u]; }",
		"    int get_scc_size(int scc) { return scc_size[scc]; }",
		"};",
		"",
		"// 使用示例：",
		"// TarjanSCC scc(n);",
		"// scc.add_edge(u, v);",
		"// scc.run();",
		"// vector<vector<int>> dag = scc.build_dag();",
	})
}),

-- 02_Graph_Theory\Matching\BipartiteMatching.h
s("02_graph_theory_matching_bipartitematching_h", {
	t({
		"// 二分图匹配模板",
		"",
		"// 匈牙利算法 - 最大匹配",
		"// 时间复杂度: O(V * E)",
		"struct Hungarian {",
		"    vector<vector<int>> g;",
		"    vector<int> match;",
		"    vector<bool> used;",
		"    int n, m;  // 左部n个点，右部m个点",
		"",
		"    Hungarian(int n, int m) : n(n), m(m), g(n), match(m, -1), used(n) {}",
		"",
		"    void addEdge(int u, int v) { g[u].push_back(v); }",
		"",
		"    bool dfs(int v) {",
		"        if (used[v]) return false;",
		"        used[v] = true;",
		"",
		"        for (int to : g[v]) {",
		"            if (match[to] == -1 || dfs(match[to])) {",
		"                match[to] = v;",
		"                return true;",
		"            }",
		"        }",
		"        return false;",
		"    }",
		"",
		"    int maxMatching() {",
		"        int result = 0;",
		"        for (int v = 0; v < n; v++) {",
		"            fill(used.begin(), used.end(), false);",
		"            if (dfs(v)) result++;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 获取匹配",
		"    vector<pair<int, int>> getMatching() {",
		"        vector<pair<int, int>> result;",
		"        for (int i = 0; i < m; i++) {",
		"            if (match[i] != -1) { result.emplace_back(match[i], i); }",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// Kuhn-Munkres算法 - 最大权匹配/最小权匹配",
		"// 时间复杂度: O(V^3)",
		"struct KuhnMunkres {",
		"    vector<vector<int>> cost;",
		"    vector<int> lx, ly, match;",
		"    vector<bool> visx, visy;",
		"    int n, slack;",
		"",
		"    KuhnMunkres(int n) : n(n), cost(n, vector<int>(n, 0)), lx(n), ly(n), match(n, -1), visx(n), visy(n) {}",
		"",
		"    void setCost(int u, int v, int w) { cost[u][v] = w; }",
		"",
		"    bool dfs(int u) {",
		"        visx[u] = true;",
		"        for (int v = 0; v < n; v++) {",
		"            if (visy[v]) continue;",
		"            int tmp = lx[u] + ly[v] - cost[u][v];",
		"            if (tmp == 0) {",
		"                visy[v] = true;",
		"                if (match[v] == -1 || dfs(match[v])) {",
		"                    match[v] = u;",
		"                    return true;",
		"                }",
		"            } else {",
		"                slack = min(slack, tmp);",
		"            }",
		"        }",
		"        return false;",
		"    }",
		"",
		"    int maxWeightMatching() {",
		"        // 初始化顶标",
		"        for (int i = 0; i < n; i++) {",
		"            lx[i] = *max_element(cost[i].begin(), cost[i].end());",
		"            ly[i] = 0;",
		"        }",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            while (true) {",
		"                fill(visx.begin(), visx.end(), false);",
		"                fill(visy.begin(), visy.end(), false);",
		"                slack = INT_MAX;",
		"",
		"                if (dfs(i)) break;",
		"",
		"                // 修改顶标",
		"                for (int j = 0; j < n; j++) {",
		"                    if (visx[j]) lx[j] -= slack;",
		"                    if (visy[j]) ly[j] += slack;",
		"                }",
		"            }",
		"        }",
		"",
		"        int result = 0;",
		"        for (int i = 0; i < n; i++) {",
		"            if (match[i] != -1) { result += cost[match[i]][i]; }",
		"        }",
		"        return result;",
		"    }",
		"",
		"    vector<pair<int, int>> getMatching() {",
		"        vector<pair<int, int>> result;",
		"        for (int i = 0; i < n; i++) {",
		"            if (match[i] != -1) { result.emplace_back(match[i], i); }",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// Hopcroft-Karp算法 - O(E√V) 最大匹配",
		"// ?????????????",
		"struct HopcroftKarp {",
		"    vector<vector<int>> g;",
		"    vector<int> pairU, pairV, dist;",
		"    int n, m, nil;",
		"",
		"    HopcroftKarp(int n, int m) : n(n), m(m), nil(0), g(n + 1), pairU(n + 1), pairV(m + 1), dist(n + 1) {}",
		"",
		"    void addEdge(int u, int v) {",
		"        g[u + 1].push_back(v + 1);  // 1-indexed",
		"    }",
		"",
		"    bool bfs() {",
		"        queue<int> q;",
		"        for (int u = 1; u <= n; u++) {",
		"            if (pairU[u] == nil) {",
		"                dist[u] = 0;",
		"                q.push(u);",
		"            } else {",
		"                dist[u] = INT_MAX;",
		"            }",
		"        }",
		"        dist[nil] = INT_MAX;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            if (dist[u] < dist[nil]) {",
		"                for (int v : g[u]) {",
		"                    if (dist[pairV[v]] == INT_MAX) {",
		"                        dist[pairV[v]] = dist[u] + 1;",
		"                        q.push(pairV[v]);",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return dist[nil] != INT_MAX;",
		"    }",
		"",
		"    bool dfs(int u) {",
		"        if (u != nil) {",
		"            for (int v : g[u]) {",
		"                if (dist[pairV[v]] == dist[u] + 1) {",
		"                    if (dfs(pairV[v])) {",
		"                        pairV[v] = u;",
		"                        pairU[u] = v;",
		"                        return true;",
		"                    }",
		"                }",
		"            }",
		"            dist[u] = INT_MAX;",
		"            return false;",
		"        }",
		"        return true;",
		"    }",
		"",
		"    int maxMatching() {",
		"        fill(pairU.begin(), pairU.end(), nil);",
		"        fill(pairV.begin(), pairV.end(), nil);",
		"",
		"        int matching = 0;",
		"        while (bfs()) {",
		"            for (int u = 1; u <= n; u++) {",
		"                if (pairU[u] == nil && dfs(u)) { matching++; }",
		"            }",
		"        }",
		"        return matching;",
		"    }",
		"",
		"    vector<pair<int, int>> getMatching() {",
		"        vector<pair<int, int>> result;",
		"        for (int u = 1; u <= n; u++) {",
		"            if (pairU[u] != nil) {",
		"                result.emplace_back(u - 1, pairU[u] - 1);  // ??0-indexed",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// Edmonds-Karp算法 - O(E^2V) 最大匹配",
		"// ????? - ???Blossom??",
		"struct Blossom {",
		"    vector<vector<int>> g;",
		"    vector<int> match, pre, base;",
		"    vector<bool> used, blossom;",
		"    queue<int> q;",
		"    int n;",
		"",
		"    Blossom(int n) : n(n), g(n), match(n, -1), pre(n), base(n), used(n), blossom(n) {}",
		"",
		"    void addEdge(int u, int v) {",
		"        g[u].push_back(v);",
		"        g[v].push_back(u);",
		"    }",
		"",
		"    int lca(int u, int v) {",
		"        fill(used.begin(), used.end(), false);",
		"        while (true) {",
		"            u = base[u];",
		"            used[u] = true;",
		"            if (match[u] == -1) break;",
		"            u = pre[match[u]];",
		"        }",
		"        while (true) {",
		"            v = base[v];",
		"            if (used[v]) return v;",
		"            v = pre[match[v]];",
		"        }",
		"    }",
		"",
		"    void markPath(int v, int b, int children) {",
		"        while (base[v] != b) {",
		"            blossom[base[v]] = blossom[base[match[v]]] = true;",
		"            pre[v] = children;",
		"            children = match[v];",
		"            v = pre[match[v]];",
		"        }",
		"    }",
		"",
		"    void shrinkBlossom(int u, int v) {",
		"        int b = lca(u, v);",
		"        fill(blossom.begin(), blossom.end(), false);",
		"        markPath(u, b, v);",
		"        markPath(v, b, u);",
		"        for (int i = 0; i < n; i++) {",
		"            if (blossom[base[i]]) {",
		"                base[i] = b;",
		"                if (!used[i]) {",
		"                    used[i] = true;",
		"                    q.push(i);",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    bool augment(int s) {",
		"        fill(used.begin(), used.end(), false);",
		"        fill(pre.begin(), pre.end(), -1);",
		"        for (int i = 0; i < n; i++) base[i] = i;",
		"",
		"        used[s] = true;",
		"        q = queue<int>();",
		"        q.push(s);",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            for (int v : g[u]) {",
		"                if (base[u] == base[v] || match[u] == v) continue;",
		"                if (v == s || (match[v] != -1 && pre[match[v]] != -1)) {",
		"                    shrinkBlossom(u, v);",
		"                } else if (pre[v] == -1) {",
		"                    pre[v] = u;",
		"                    if (match[v] == -1) {",
		"                        // 找到增广路径",
		"                        int cur = v, next;",
		"                        while (cur != -1) {",
		"                            next = match[pre[cur]];",
		"                            match[cur] = pre[cur];",
		"                            match[pre[cur]] = cur;",
		"                            cur = next;",
		"                        }",
		"                        return true;",
		"                    } else {",
		"                        used[match[v]] = true;",
		"                        q.push(match[v]);",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return false;",
		"    }",
		"",
		"    int maxMatching() {",
		"        int result = 0;",
		"        for (int i = 0; i < n; i++) {",
		"            if (match[i] == -1 && augment(i)) { result++; }",
		"        }",
		"        return result;",
		"    }",
		"",
		"    vector<pair<int, int>> getMatching() {",
		"        vector<pair<int, int>> result;",
		"        for (int i = 0; i < n; i++) {",
		"            if (match[i] != -1 && i < match[i]) { result.emplace_back(i, match[i]); }",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// 最小点覆盖 - König定理",
		"// 最小点覆盖 = 最大匹配",
		"struct MinimumVertexCover {",
		"    Hungarian hungarian;",
		"    vector<vector<int>> g;",
		"    vector<bool> visitedL, visitedR;",
		"    int n, m;",
		"",
		"    MinimumVertexCover(int n, int m) : n(n), m(m), hungarian(n, m), g(n), visitedL(n), visitedR(m) {}",
		"",
		"    void addEdge(int u, int v) {",
		"        g[u].push_back(v);",
		"        hungarian.addEdge(u, v);",
		"    }",
		"",
		"    void dfs(int u) {",
		"        visitedL[u] = true;",
		"        for (int v : g[u]) {",
		"            if (!visitedR[v] && hungarian.match[v] != u) {",
		"                visitedR[v] = true;",
		"                if (hungarian.match[v] != -1) { dfs(hungarian.match[v]); }",
		"            }",
		"        }",
		"    }",
		"",
		"    vector<int> getMinVertexCover() {",
		"        int maxMatch = hungarian.maxMatching();",
		"",
		"        fill(visitedL.begin(), visitedL.end(), false);",
		"        fill(visitedR.begin(), visitedR.end(), false);",
		"",
		"        // 反向DFS找未覆盖点",
		"        for (int i = 0; i < n; i++) {",
		"            bool matched = false;",
		"            for (int j = 0; j < m; j++) {",
		"                if (hungarian.match[j] == i) {",
		"                    matched = true;",
		"                    break;",
		"                }",
		"            }",
		"            if (!matched) { dfs(i); }",
		"        }",
		"",
		"        vector<int> cover;",
		"        // 左部未访问点 + 右部已访问点",
		"        for (int i = 0; i < n; i++) {",
		"            if (!visitedL[i]) {",
		"                cover.push_back(i);  // 左部点",
		"            }",
		"        }",
		"        for (int i = 0; i < m; i++) {",
		"            if (visitedR[i]) {",
		"                cover.push_back(n + i);  // 右部点编号加n",
		"            }",
		"        }",
		"        return cover;",
		"    }",
		"};",
		"",
		"// 最大独立集",
		"// 最大独立集 = 顶点数 - 最小点覆盖",
		"struct MaximumIndependentSet {",
		"    MinimumVertexCover mvc;",
		"    int n, m;",
		"",
		"    MaximumIndependentSet(int n, int m) : n(n), m(m), mvc(n, m) {}",
		"",
		"    void addEdge(int u, int v) { mvc.addEdge(u, v); }",
		"",
		"    vector<int> getMaxIndependentSet() {",
		"        auto cover = mvc.getMinVertexCover();",
		"        vector<bool> inCover(n + m, false);",
		"        for (int v : cover) { inCover[v] = true; }",
		"",
		"        vector<int> independent;",
		"        for (int i = 0; i < n + m; i++) {",
		"            if (!inCover[i]) { independent.push_back(i); }",
		"        }",
		"        return independent;",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Maximum_Flow\Dinic.h
s("02_graph_theory_maximum_flow_dinic_h", {
	t({
		"// Dinic最大流算法 - 时间复杂度: O(V^2 * E)",
		"// 使用分层图和当前弧优化，适用于大多数最大流问题",
		"struct Dinic {",
		"    struct Edge {",
		"        int to, cap, flow;",
		"    };",
		"",
		"    vector<Edge> edges;",
		"    vector<vector<int>> g;",
		"    vector<int> d, ptr;",
		"    int n;",
		"",
		"    Dinic(int _n) : n(_n) {",
		"        g.resize(n);",
		"        d.resize(n);",
		"        ptr.resize(n);",
		"    }",
		"    void add_edge(int from, int to, int cap) {",
		"        g[from].push_back(edges.size());",
		"        edges.push_back({to, cap, 0});",
		"        g[to].push_back(edges.size());",
		"        edges.push_back({from, 0, 0});  // 反向边",
		"    }",
		"    bool bfs(int s, int t) {",
		"        fill(d.begin(), d.end(), -1);",
		"        d[s] = 0;",
		"        queue<int> q;",
		"        q.push(s);",
		"",
		"        while (!q.empty()) {",
		"            int v = q.front();",
		"            q.pop();",
		"",
		"            for (int id : g[v]) {",
		"                if (d[edges[id].to] == -1 && edges[id].flow < edges[id].cap) {",
		"                    d[edges[id].to] = d[v] + 1;",
		"                    q.push(edges[id].to);",
		"                }",
		"            }",
		"        }",
		"",
		"        return d[t] != -1;  // 返回是否能到达汇点",
		"    }",
		"",
		"    int dfs(int v, int t, int pushed) {",
		"        if (v == t || pushed == 0) { return pushed; }",
		"",
		"        for (int& cid = ptr[v]; cid < g[v].size(); cid++) {",
		"            int id = g[v][cid];",
		"            int to = edges[id].to;",
		"",
		"            if (d[v] + 1 != d[to] || edges[id].cap <= edges[id].flow) { continue; }",
		"",
		"            int tr = dfs(to, t, min(pushed, edges[id].cap - edges[id].flow));",
		"            if (tr > 0) {",
		"                edges[id].flow += tr;",
		"                edges[id ^ 1].flow -= tr;",
		"                return tr;",
		"            }",
		"        }",
		"",
		"        return 0;",
		"    }",
		"",
		"    int max_flow(int s, int t) {",
		"        int flow = 0;",
		"",
		"        while (bfs(s, t)) {",
		"            fill(ptr.begin(), ptr.end(), 0);",
		"            while (int pushed = dfs(s, t, INT_MAX)) { flow += pushed; }",
		"        }",
		"",
		"        return flow;",
		"    }",
		"",
		"    // 获取最小割",
		"    vector<bool> min_cut(int s) {",
		"        vector<bool> cut(n, false);",
		"        function<void(int)> dfs_cut = [&](int v) {",
		"            cut[v] = true;",
		"            for (int id : g[v]) {",
		"                if (!cut[edges[id].to] && edges[id].flow < edges[id].cap) { dfs_cut(edges[id].to); }",
		"            }",
		"        };",
		"        dfs_cut(s);",
		"        return cut;",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Maximum_Flow\ISAP.h
s("02_graph_theory_maximum_flow_isap_h", {
	t({
		"// ISAP (Improved Shortest Augmenting Path) 最大流算法",
		"// 时间复杂度: O(V^2 * E)，在某些图上比Dinic更快",
		"struct ISAP {",
		"    struct Edge {",
		"        int to, cap, flow, rev;",
		"    };",
		"",
		"    vector<vector<Edge>> graph;",
		"    vector<int> level, iter, gap;",
		"    int n;",
		"",
		"    ISAP(int _n) : n(_n) {",
		"        graph.resize(n);",
		"        level.resize(n);",
		"        iter.resize(n);",
		"        gap.resize(n);",
		"    }",
		"",
		"    void add_edge(int from, int to, int cap) {",
		"        graph[from].push_back({to, cap, 0, (int)graph[to].size()});",
		"        graph[to].push_back({from, 0, 0, (int)graph[from].size() - 1});",
		"    }",
		"",
		"    void bfs(int t) {",
		"        fill(level.begin(), level.end(), -1);",
		"        fill(gap.begin(), gap.end(), 0);",
		"",
		"        queue<int> q;",
		"        level[t] = 0;",
		"        gap[0] = 1;",
		"        q.push(t);",
		"",
		"        while (!q.empty()) {",
		"            int v = q.front();",
		"            q.pop();",
		"",
		"            for (const Edge& e : graph[v]) {",
		"                if (level[e.to] == -1) {",
		"                    level[e.to] = level[v] + 1;",
		"                    gap[level[e.to]]++;",
		"                    q.push(e.to);",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    int dfs(int v, int t, int pushed) {",
		"        if (v == t) return pushed;",
		"",
		"        int res = 0;",
		"        for (int& i = iter[v]; i < graph[v].size(); i++) {",
		"            Edge& e = graph[v][i];",
		"",
		"            if (e.cap > e.flow && level[v] == level[e.to] + 1) {",
		"                int flow = dfs(e.to, t, min(pushed, e.cap - e.flow));",
		"                if (flow > 0) {",
		"                    e.flow += flow;",
		"                    graph[e.to][e.rev].flow -= flow;",
		"                    res += flow;",
		"                    pushed -= flow;",
		"                    if (pushed == 0) break;",
		"                }",
		"            }",
		"        }",
		"",
		"        if (res == 0) {",
		"            gap[level[v]]--;",
		"            if (gap[level[v]] == 0) {",
		"                for (int i = 0; i < n; i++) {",
		"                    if (i != v && level[i] > level[v] && level[i] < n) { level[i] = n; }",
		"                }",
		"            }",
		"            level[v] = n;",
		"            for (const Edge& e : graph[v]) {",
		"                if (e.cap > e.flow && level[e.to] + 1 < level[v]) { level[v] = level[e.to] + 1; }",
		"            }",
		"            gap[level[v]]++;",
		"        }",
		"",
		"        return res;",
		"    }",
		"",
		"    int max_flow(int s, int t) {",
		"        bfs(t);",
		"        if (level[s] == -1) return 0;",
		"",
		"        int flow = 0;",
		"        while (level[s] < n) {",
		"            fill(iter.begin(), iter.end(), 0);",
		"            flow += dfs(s, t, INT_MAX);",
		"        }",
		"",
		"        return flow;",
		"    }",
		"",
		"    // 获取最小割",
		"    vector<bool> min_cut(int s) {",
		"        vector<bool> cut(n, false);",
		"        function<void(int)> dfs_cut = [&](int v) {",
		"            cut[v] = true;",
		"            for (const Edge& e : graph[v]) {",
		"                if (!cut[e.to] && e.flow < e.cap) { dfs_cut(e.to); }",
		"            }",
		"        };",
		"        dfs_cut(s);",
		"        return cut;",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Maximum_Flow\MCMF_SPFA.h
s("02_graph_theory_maximum_flow_mcmf_spfa_h", {
	t({
		"constexpr int INF = 0x3f3f3f3f;",
		"",
		"// 最小费用最大流 (MCMF) 使用SPFA",
		"// 时间复杂度: O(V * E * F)，其中F为最大流量",
		"// 使用Johnson势能函数优化，避免负权边",
		"struct MCMF_SPFA {",
		"    struct Edge {",
		"        int to, cap, cost, flow, rev;",
		"    };",
		"",
		"    vector<vector<Edge>> graph;",
		"    vector<int> dist, parent_v, parent_e, h;",
		"    int n;",
		"    const int INF = 1e9;",
		"",
		"    MCMF_SPFA(int _n) : n(_n) {",
		"        graph.resize(n);",
		"        dist.resize(n);",
		"        parent_v.resize(n);",
		"        parent_e.resize(n);",
		"        h.resize(n);",
		"    }",
		"",
		"    void add_edge(int from, int to, int cap, int cost) {",
		"        graph[from].push_back({to, cap, cost, 0, (int)graph[to].size()});",
		"        graph[to].push_back({from, 0, -cost, 0, (int)graph[from].size() - 1});",
		"    }",
		"",
		"    bool spfa(int s, int t) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        vector<bool> inq(n, false);",
		"        queue<int> q;",
		"",
		"        dist[s] = 0;",
		"        q.push(s);",
		"        inq[s] = true;",
		"",
		"        while (!q.empty()) {",
		"            int v = q.front();",
		"            q.pop();",
		"            inq[v] = false;",
		"",
		"            for (int i = 0; i < graph[v].size(); i++) {",
		"                const Edge& e = graph[v][i];",
		"                if (e.cap > e.flow && dist[e.to] > dist[v] + e.cost) {",
		"                    dist[e.to] = dist[v] + e.cost;",
		"                    parent_v[e.to] = v;",
		"                    parent_e[e.to] = i;",
		"                    if (!inq[e.to]) {",
		"                        q.push(e.to);",
		"                        inq[e.to] = true;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        return dist[t] != INF;",
		"    }",
		"",
		"    bool dijkstra(int s, int t) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
		"",
		"        dist[s] = 0;",
		"        pq.push({0, s});",
		"",
		"        while (!pq.empty()) {",
		"            auto [d, v] = pq.top();",
		"            pq.pop();",
		"",
		"            if (d > dist[v]) continue;",
		"",
		"            for (int i = 0; i < graph[v].size(); i++) {",
		"                const Edge& e = graph[v][i];",
		"                int cost = e.cost + h[v] - h[e.to];",
		"                if (e.cap > e.flow && dist[e.to] > dist[v] + cost) {",
		"                    dist[e.to] = dist[v] + cost;",
		"                    parent_v[e.to] = v;",
		"                    parent_e[e.to] = i;",
		"                    pq.push({dist[e.to], e.to});",
		"                }",
		"            }",
		"        }",
		"        return dist[t] != INF;",
		"    }",
		"",
		"    pair<int, int> min_cost_max_flow(int s, int t, int max_flow_limit = 1000000000) {",
		"        int flow = 0, cost = 0;",
		"",
		"        // 使用SPFA计算初始势能",
		"        fill(h.begin(), h.end(), 0);",
		"",
		"        while (flow < max_flow_limit) {",
		"            bool found;",
		"            if (flow == 0) {",
		"                found = spfa(s, t);",
		"            } else {",
		"                // 更新势能",
		"                for (int v = 0; v < n; v++) {",
		"                    if (dist[v] != INF) { h[v] += dist[v]; }",
		"                }",
		"                found = dijkstra(s, t);",
		"            }",
		"            if (!found) break;",
		"",
		"            // 找到增广路径上的最小容量",
		"            int path_flow = max_flow_limit - flow;",
		"            int v = t;",
		"            while (v != s) {",
		"                const Edge& e = graph[parent_v[v]][parent_e[v]];",
		"                path_flow = min(path_flow, e.cap - e.flow);",
		"                v = parent_v[v];",
		"            }",
		"",
		"            // 更新流量",
		"            v = t;",
		"            while (v != s) {",
		"                Edge& e = graph[parent_v[v]][parent_e[v]];",
		"                e.flow += path_flow;",
		"                graph[v][e.rev].flow -= path_flow;",
		"                v = parent_v[v];",
		"            }",
		"",
		"            flow += path_flow;",
		"            cost += path_flow * (h[t] - h[s]);",
		"        }",
		"",
		"        return {flow, cost};",
		"    }",
		"",
		"    // 只求最小费用最大流",
		"    pair<int, int> solve(int s, int t) { return min_cost_max_flow(s, t); }",
		"};",
	})
}),

-- 02_Graph_Theory\Minimum_Spanning_Tree\Boruvka.h
s("02_graph_theory_minimum_spanning_tree_boruvka_h", {
	t({
		"// Borůvka最小生成树算法的独立实现 - 时间复杂度: O(E log V)",
		"// 并行友好的算法，每轮同时为所有连通分量选择最小出边",
		"struct BoruvkaMST {",
		"    struct Edge {",
		"        int u, v, weight;",
		"        int id;  // 边的编号",
		"",
		"        bool operator<(const Edge& other) const { return weight < other.weight; }",
		"    };",
		"",
		"    struct UnionFind {",
		"        vector<int> parent, rank;",
		"        int components;",
		"",
		"        UnionFind(int n) : parent(n), rank(n, 0), components(n) { iota(parent.begin(), parent.end(), 0); }",
		"",
		"        int find(int x) { return parent[x] == x ? x : parent[x] = find(parent[x]); }",
		"",
		"        bool unite(int x, int y) {",
		"            x = find(x), y = find(y);",
		"            if (x == y) return false;",
		"",
		"            if (rank[x] < rank[y]) swap(x, y);",
		"            parent[y] = x;",
		"            if (rank[x] == rank[y]) rank[x]++;",
		"            components--;",
		"            return true;",
		"        }",
		"",
		"        bool connected(int x, int y) { return find(x) == find(y); }",
		"    };",
		"",
		"    vector<Edge> edges;",
		"    int n;",
		"",
		"    BoruvkaMST(int _n) : n(_n) {}",
		"",
		"    void add_edge(int u, int v, int w) { edges.push_back({u, v, w, (int)edges.size()}); }",
		"",
		"    // 返回最小生成树的权值和选择的边",
		"    pair<long long, vector<Edge>> solve() {",
		"        UnionFind uf(n);",
		"        vector<Edge> mst_edges;",
		"        long long total_weight = 0;",
		"",
		"        while (uf.components > 1) {",
		"            vector<int> min_edge(n, -1);",
		"",
		"            // 为每个连通分量找最小出边",
		"            for (int i = 0; i < edges.size(); i++) {",
		"                int u = uf.find(edges[i].u);",
		"                int v = uf.find(edges[i].v);",
		"",
		"                if (u != v) {",
		"                    // 更新u所在分量的最小出边",
		"                    if (min_edge[u] == -1 || edges[i].weight < edges[min_edge[u]].weight) { min_edge[u] = i; }",
		"                    // 更新v所在分量的最小出边",
		"                    if (min_edge[v] == -1 || edges[i].weight < edges[min_edge[v]].weight) { min_edge[v] = i; }",
		"                }",
		"            }",
		"",
		"            // 添加找到的最小出边",
		"            vector<bool> added(edges.size(), false);",
		"            for (int i = 0; i < n; i++) {",
		"                if (min_edge[i] != -1 && !added[min_edge[i]]) {",
		"                    const Edge& e = edges[min_edge[i]];",
		"                    if (uf.unite(e.u, e.v)) {",
		"                        mst_edges.push_back(e);",
		"                        total_weight += e.weight;",
		"                        added[min_edge[i]] = true;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        return {total_weight, mst_edges};",
		"    }",
		"",
		"    // 只返回最小生成树的权值",
		"    long long get_weight() { return solve().first; }",
		"",
		"    // 检查图是否连通",
		"    bool is_connected() {",
		"        UnionFind uf(n);",
		"        for (const Edge& e : edges) { uf.unite(e.u, e.v); }",
		"        return uf.components == 1;",
		"    }",
		"",
		"    // 获取最小生成树的边数",
		"    int get_mst_edge_count() { return solve().second.size(); }",
		"};",
	})
}),

-- 02_Graph_Theory\Minimum_Spanning_Tree\Kruskal.h
s("02_graph_theory_minimum_spanning_tree_kruskal_h", {
	t({
		"// Kruskal最小生成树算法 - 时间复杂度: O(E log E)",
		"// 适用于稀疏图，基于边的贪心策略",
		"struct Kruskal {",
		"    struct Edge {",
		"        int u, v, w;",
		"        bool operator<(const Edge& other) const { return w < other.w; }",
		"    };",
		"",
		"    struct DSU {",
		"        vector<int> fa, rank;",
		"",
		"        DSU(int n) : fa(n), rank(n, 0) { iota(fa.begin(), fa.end(), 0); }",
		"",
		"        int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }",
		"",
		"        bool unite(int x, int y) {",
		"            x = find(x), y = find(y);",
		"            if (x == y) return false;",
		"            if (rank[x] < rank[y]) swap(x, y);",
		"            fa[y] = x;",
		"            if (rank[x] == rank[y]) rank[x]++;",
		"            return true;",
		"        }",
		"    };",
		"",
		"    vector<Edge> edges;",
		"    int n;",
		"",
		"    Kruskal(int _n) : n(_n) {}",
		"",
		"    void add_edge(int u, int v, int w) { edges.push_back({u, v, w}); }",
		"",
		"    // 返回最小生成树的权值和，选择的边存储在result中",
		"    long long solve(vector<Edge>& result) {",
		"        sort(edges.begin(), edges.end());",
		"        DSU dsu(n);",
		"        long long total_weight = 0;",
		"        result.clear();",
		"",
		"        for (const Edge& e : edges) {",
		"            if (dsu.unite(e.u, e.v)) {",
		"                total_weight += e.w;",
		"                result.push_back(e);",
		"                if (result.size() == n - 1) break;",
		"            }",
		"        }",
		"",
		"        return result.size() == n - 1 ? total_weight : -1;  // -1表示图不连通",
		"    }",
		"",
		"    // 只返回最小生成树的权值和",
		"    long long solve() {",
		"        vector<Edge> result;",
		"        return solve(result);",
		"    }",
		"};",
		"",
		"// Prim最小生成树算法 - 时间复杂度: O(E log V)",
		"// 适用于稠密图，基于点的贪心策略",
		"struct Prim {",
		"    struct Edge {",
		"        int to, w;",
		"    };",
		"",
		"    vector<vector<Edge>> graph;",
		"    int n;",
		"",
		"    Prim(int _n) : n(_n), graph(_n) {}",
		"",
		"    void add_edge(int u, int v, int w) {",
		"        graph[u].push_back({v, w});",
		"        graph[v].push_back({u, w});",
		"    }",
		"",
		"    // 返回最小生成树的权值和",
		"    long long solve(int start = 0) {",
		"        vector<bool> in_mst(n, false);",
		"        vector<int> min_cost(n, INT_MAX);",
		"        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
		"",
		"        min_cost[start] = 0;",
		"        pq.push({0, start});",
		"        long long total_weight = 0;",
		"        int edges_added = 0;",
		"",
		"        while (!pq.empty() && edges_added < n) {",
		"            auto [cost, u] = pq.top();",
		"            pq.pop();",
		"",
		"            if (in_mst[u]) continue;",
		"",
		"            in_mst[u] = true;",
		"            total_weight += cost;",
		"            edges_added++;",
		"",
		"            for (const Edge& e : graph[u]) {",
		"                if (!in_mst[e.to] && e.w < min_cost[e.to]) {",
		"                    min_cost[e.to] = e.w;",
		"                    pq.push({e.w, e.to});",
		"                }",
		"            }",
		"        }",
		"",
		"        return edges_added == n ? total_weight : -1;  // -1表示图不连通",
		"    }",
		"",
		"    // 返回最小生成树的边",
		"    vector<pair<int, int>> get_mst_edges(int start = 0) {",
		"        vector<bool> in_mst(n, false);",
		"        vector<int> min_cost(n, INT_MAX);",
		"        vector<int> parent(n, -1);",
		"        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
		"",
		"        min_cost[start] = 0;",
		"        pq.push({0, start});",
		"        vector<pair<int, int>> mst_edges;",
		"",
		"        while (!pq.empty()) {",
		"            auto [cost, u] = pq.top();",
		"            pq.pop();",
		"",
		"            if (in_mst[u]) continue;",
		"",
		"            in_mst[u] = true;",
		"            if (parent[u] != -1) { mst_edges.push_back({parent[u], u}); }",
		"",
		"            for (const Edge& e : graph[u]) {",
		"                if (!in_mst[e.to] && e.w < min_cost[e.to]) {",
		"                    min_cost[e.to] = e.w;",
		"                    parent[e.to] = u;",
		"                    pq.push({e.w, e.to});",
		"                }",
		"            }",
		"        }",
		"",
		"        return mst_edges;",
		"    }",
		"};",
		"",
		"// Borůvka最小生成树算法（适用于稠密图）- 时间复杂度: O(E log V)",
		"// 并行友好的最小生成树算法，每轮同时选择多条边",
		"struct Boruvka {",
		"    struct Edge {",
		"        int u, v, w;",
		"    };",
		"",
		"    struct DSU {",
		"        vector<int> fa, rank;",
		"",
		"        DSU(int n) : fa(n), rank(n, 0) { iota(fa.begin(), fa.end(), 0); }",
		"",
		"        int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }",
		"",
		"        bool unite(int x, int y) {",
		"            x = find(x), y = find(y);",
		"            if (x == y) return false;",
		"            if (rank[x] < rank[y]) swap(x, y);",
		"            fa[y] = x;",
		"            if (rank[x] == rank[y]) rank[x]++;",
		"            return true;",
		"        }",
		"    };",
		"",
		"    vector<Edge> edges;",
		"    int n;",
		"",
		"    Boruvka(int _n) : n(_n) {}",
		"",
		"    void add_edge(int u, int v, int w) { edges.push_back({u, v, w}); }",
		"",
		"    long long solve() {",
		"        DSU dsu(n);",
		"        long long total_weight = 0;",
		"        int components = n;",
		"",
		"        while (components > 1) {",
		"            vector<int> min_edge(n, -1);",
		"",
		"            // 找到每个连通分量的最小出边",
		"            for (int i = 0; i < edges.size(); i++) {",
		"                int u = dsu.find(edges[i].u);",
		"                int v = dsu.find(edges[i].v);",
		"",
		"                if (u != v) {",
		"                    if (min_edge[u] == -1 || edges[i].w < edges[min_edge[u]].w) { min_edge[u] = i; }",
		"                    if (min_edge[v] == -1 || edges[i].w < edges[min_edge[v]].w) { min_edge[v] = i; }",
		"                }",
		"            }",
		"",
		"            // 添加最小出边",
		"            for (int i = 0; i < n; i++) {",
		"                if (min_edge[i] != -1) {",
		"                    const Edge& e = edges[min_edge[i]];",
		"                    if (dsu.unite(e.u, e.v)) {",
		"                        total_weight += e.w;",
		"                        components--;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        return components == 1 ? total_weight : -1;",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Minimum_Spanning_Tree\Prim.h
s("02_graph_theory_minimum_spanning_tree_prim_h", {
	t({
		"// Prim最小生成树算法的独立实现 - 时间复杂度: O(E log V)",
		"// 基于优先队列的实现，适用于稠密图",
		"struct PrimMST {",
		"    struct Edge {",
		"        int to, weight;",
		"        bool operator>(const Edge& other) const { return weight > other.weight; }",
		"    };",
		"",
		"    vector<vector<Edge>> adj;",
		"    int n;",
		"",
		"    PrimMST(int _n) : n(_n), adj(_n) {}",
		"",
		"    void add_edge(int u, int v, int w) {",
		"        adj[u].push_back({v, w});",
		"        adj[v].push_back({u, w});",
		"    }",
		"",
		"    // 返回最小生成树的权值和和选择的边",
		"    pair<long long, vector<pair<int, int>>> solve(int start = 0) {",
		"        vector<bool> visited(n, false);",
		"        vector<int> key(n, INT_MAX);",
		"        vector<int> parent(n, -1);",
		"        priority_queue<Edge, vector<Edge>, greater<Edge>> pq;",
		"",
		"        key[start] = 0;",
		"        pq.push({start, 0});",
		"        long long total_weight = 0;",
		"        vector<pair<int, int>> mst_edges;",
		"",
		"        while (!pq.empty()) {",
		"            int u = pq.top().to;",
		"            pq.pop();",
		"",
		"            if (visited[u]) continue;",
		"            visited[u] = true;",
		"",
		"            if (parent[u] != -1) {",
		"                mst_edges.push_back({parent[u], u});",
		"                total_weight += key[u];",
		"            }",
		"",
		"            for (const Edge& edge : adj[u]) {",
		"                int v = edge.to;",
		"                int weight = edge.weight;",
		"",
		"                if (!visited[v] && weight < key[v]) {",
		"                    key[v] = weight;",
		"                    parent[v] = u;",
		"                    pq.push({v, weight});",
		"                }",
		"            }",
		"        }",
		"",
		"        // 检查是否所有顶点都被访问（图是否连通）",
		"        for (int i = 0; i < n; i++) {",
		"            if (!visited[i]) {",
		"                return {-1, {}};  // 图不连通",
		"            }",
		"        }",
		"",
		"        return {total_weight, mst_edges};",
		"    }",
		"",
		"    // 只返回最小生成树的权值",
		"    long long get_weight(int start = 0) { return solve(start).first; }",
		"",
		"    // 检查图是否连通",
		"    bool is_connected() { return get_weight() != -1; }",
		"};",
	})
}),

-- 02_Graph_Theory\Representation\AdjacencyList.h
s("02_graph_theory_representation_adjacencylist_h", {
	t({
		"// 邻接表 - 图的基本表示方法",
		"// 空间复杂度: O(V + E)",
		"template <typename T = int>",
		"struct AdjacencyList {",
		"    struct Edge {",
		"        int to;",
		"        T weight;",
		"        int id;  // 边的编号",
		"",
		"        Edge() : to(0), weight(0), id(0) {}",
		"        Edge(int t, T w = 0, int i = 0) : to(t), weight(w), id(i) {}",
		"    };",
		"",
		"    int n, edge_count;",
		"    vector<vector<Edge>> adj;",
		"",
		"    AdjacencyList(int size) : n(size), edge_count(0) { adj.resize(n); }",
		"",
		"    void add_edge(int from, int to, T weight = 0, bool directed = true) {",
		"        adj[from].emplace_back(to, weight, edge_count);",
		"        if (!directed) { adj[to].emplace_back(from, weight, edge_count); }",
		"        edge_count++;",
		"    }",
		"",
		"    void add_weighted_edge(int from, int to, T weight, bool directed = true) { add_edge(from, to, weight, directed); }",
		"",
		"    void add_unweighted_edge(int from, int to, bool directed = true) { add_edge(from, to, 1, directed); }",
		"",
		"    vector<Edge>& operator[](int u) { return adj[u]; }",
		"",
		"    const vector<Edge>& operator[](int u) const { return adj[u]; }",
		"",
		"    int size() const { return n; }",
		"    int edges() const { return edge_count; }",
		"",
		"    // DFS 遍历",
		"    void dfs(int u, vector<bool>& visited, function<void(int)> process = nullptr) {",
		"        visited[u] = true;",
		"        if (process) process(u);",
		"",
		"        for (const Edge& e : adj[u]) {",
		"            if (!visited[e.to]) { dfs(e.to, visited, process); }",
		"        }",
		"    }",
		"",
		"    // BFS 遍历",
		"    void bfs(int start, function<void(int)> process = nullptr) {",
		"        vector<bool> visited(n, false);",
		"        queue<int> q;",
		"",
		"        q.push(start);",
		"        visited[start] = true;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"",
		"            if (process) process(u);",
		"",
		"            for (const Edge& e : adj[u]) {",
		"                if (!visited[e.to]) {",
		"                    visited[e.to] = true;",
		"                    q.push(e.to);",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    // 检查连通性",
		"    bool is_connected() {",
		"        vector<bool> visited(n, false);",
		"        dfs(0, visited);",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            if (!visited[i]) return false;",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 获取所有边",
		"    vector<tuple<int, int, T>> get_edges() {",
		"        vector<tuple<int, int, T>> edges;",
		"        for (int u = 0; u < n; u++) {",
		"            for (const Edge& e : adj[u]) { edges.emplace_back(u, e.to, e.weight); }",
		"        }",
		"        return edges;",
		"    }",
		"",
		"    // 获取度数",
		"    int degree(int u) const { return adj[u].size(); }",
		"",
		"    // 清空图",
		"    void clear() {",
		"        for (int i = 0; i < n; i++) { adj[i].clear(); }",
		"        edge_count = 0;",
		"    }",
		"",
		"    // 删除边",
		"    void remove_edge(int from, int to) {",
		"        adj[from].erase(remove_if(adj[from].begin(), adj[from].end(), [to](const Edge& e) { return e.to == to; }),",
		"                        adj[from].end());",
		"    }",
		"",
		"    // 检查边",
		"    bool has_edge(int from, int to) const {",
		"        for (const Edge& e : adj[from]) {",
		"            if (e.to == to) return true;",
		"        }",
		"        return false;",
		"    }",
		"",
		"    // 获取边权重",
		"    T get_weight(int from, int to) const {",
		"        for (const Edge& e : adj[from]) {",
		"            if (e.to == to) return e.weight;",
		"        }",
		"        return T{};  // 默认值",
		"    }",
		"",
		"    // 拓扑排序（有向无环图）",
		"    vector<int> topological_sort() {",
		"        vector<int> in_degree(n, 0);",
		"        for (int u = 0; u < n; u++) {",
		"            for (const Edge& e : adj[u]) { in_degree[e.to]++; }",
		"        }",
		"",
		"        queue<int> q;",
		"        for (int i = 0; i < n; i++) {",
		"            if (in_degree[i] == 0) { q.push(i); }",
		"        }",
		"",
		"        vector<int> result;",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            result.push_back(u);",
		"",
		"            for (const Edge& e : adj[u]) {",
		"                in_degree[e.to]--;",
		"                if (in_degree[e.to] == 0) { q.push(e.to); }",
		"            }",
		"        }",
		"",
		"        return result.size() == n ? result : vector<int>();  // 如果有环返回空",
		"    }",
		"",
		"    // 检查有向图是否有环",
		"    bool has_cycle_directed() {",
		"        vector<int> color(n, 0);  // 0: 白色, 1: 灰色, 2: 黑色",
		"",
		"        function<bool(int)> dfs_cycle = [&](int u) -> bool {",
		"            color[u] = 1;  // 标记为灰色",
		"            for (const Edge& e : adj[u]) {",
		"                if (color[e.to] == 1 || (color[e.to] == 0 && dfs_cycle(e.to))) { return true; }",
		"            }",
		"            color[u] = 2;  // 标记为黑色",
		"            return false;",
		"        };",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            if (color[i] == 0 && dfs_cycle(i)) { return true; }",
		"        }",
		"        return false;",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Representation\ChainBuild.h
s("02_graph_theory_representation_chainbuild_h", {
	t({
		"// 链式前向星 - 一种高效的图存储结构",
		"// 适用于静态图，空间和时间效率都很高",
		"struct ChainBuild {",
		"    int n, m, cnt = 1;  // n: 顶点数, m: 边数上限, cnt: 当前边编号",
		"    vector<int> head;   // 每个顶点的第一条出边",
		"    vector<int> nxt;    // 下一条边的编号",
		"    vector<int> to;     // 边的终点",
		"    vector<int> val;    // 边的权值",
		"",
		"    ChainBuild() {}",
		"    ChainBuild(int n_) : n(n_), m(2 * n_) { init(); }",
		"    ChainBuild(int n_, int m_) : n(n_), m(2 * m_) { init(); }",
		"",
		"    void init() {",
		"        head.resize(n + 1, 0);",
		"        nxt.resize(m + 1);",
		"        to.resize(m + 1);",
		"        val.resize(m + 1);",
		"    }",
		"",
		"    void clear() {",
		"        cnt = 1;",
		"        fill(head.begin(), head.end(), 0);",
		"    }",
		"",
		"    // 添加有向边 u -> v，权重为 w",
		"    void addEdge(int u, int v, int w = 0) {",
		"        nxt[cnt] = head[u];",
		"        to[cnt] = v;",
		"        val[cnt] = w;",
		"        head[u] = cnt++;",
		"    }",
		"",
		"    // 添加无向边",
		"    void addUndirectedEdge(int u, int v, int w = 0) {",
		"        addEdge(u, v, w);",
		"        addEdge(v, u, w);",
		"    }",
		"",
		"    // 遍历顶点 u 的所有出边",
		"    // 使用方法: for (int i = head[u]; i; i = nxt[i]) { int v = to[i], w = val[i]; }",
		"};",
	})
}),

-- 02_Graph_Theory\Representation\EdgeList.h
s("02_graph_theory_representation_edgelist_h", {
	t({
		"// 边表法 - 存储所有边的列表形式",
		"// 空间复杂度: O(E)",
		"template <typename T = int>",
		"struct EdgeList {",
		"    struct Edge {",
		"        int from, to;",
		"        T weight;",
		"        int id;",
		"",
		"        Edge() : from(0), to(0), weight(0), id(0) {}",
		"        Edge(int f, int t, T w = 0, int i = 0) : from(f), to(t), weight(w), id(i) {}",
		"",
		"        bool operator<(const Edge& other) const { return weight < other.weight; }",
		"    };",
		"",
		"    vector<Edge> edges;",
		"    int n, edge_count;",
		"",
		"    EdgeList(int size) : n(size), edge_count(0) {}",
		"",
		"    void add_edge(int from, int to, T weight = 0, bool directed = true) {",
		"        edges.emplace_back(from, to, weight, edge_count++);",
		"        if (!directed) { edges.emplace_back(to, from, weight, edge_count++); }",
		"    }",
		"",
		"    Edge& operator[](int idx) { return edges[idx]; }",
		"",
		"    const Edge& operator[](int idx) const { return edges[idx]; }",
		"",
		"    int size() const { return n; }",
		"    int edge_size() const { return edges.size(); }",
		"",
		"    // 按权重排序",
		"    void sort_by_weight() { sort(edges.begin(), edges.end()); }",
		"",
		"    // Kruskal算法求最小生成树",
		"    T kruskal_mst(vector<Edge>& mst_edges) {",
		"        sort_by_weight();",
		"",
		"        // 并查集",
		"        vector<int> parent(n);",
		"        iota(parent.begin(), parent.end(), 0);",
		"",
		"        function<int(int)> find = [&](int x) { return parent[x] == x ? x : parent[x] = find(parent[x]); };",
		"",
		"        T total_weight = 0;",
		"        mst_edges.clear();",
		"",
		"        for (const Edge& e : edges) {",
		"            int u = find(e.from);",
		"            int v = find(e.to);",
		"            if (u != v) {",
		"                parent[u] = v;",
		"                mst_edges.push_back(e);",
		"                total_weight += e.weight;",
		"                if (mst_edges.size() == n - 1) break;",
		"            }",
		"        }",
		"",
		"        return mst_edges.size() == n - 1 ? total_weight : T(-1);",
		"    }",
		"",
		"    // 只返回最小生成树权重",
		"    T kruskal_weight() {",
		"        vector<Edge> mst_edges;",
		"        return kruskal_mst(mst_edges);",
		"    }",
		"",
		"    // 获取所有边",
		"    const vector<Edge>& get_edges() const { return edges; }",
		"",
		"    // 按起点排序",
		"    void sort_by_from() {",
		"        sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {",
		"            return a.from < b.from || (a.from == b.from && a.to < b.to);",
		"        });",
		"    }",
		"",
		"    // 按终点排序",
		"    void sort_by_to() {",
		"        sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {",
		"            return a.to < b.to || (a.to == b.to && a.from < b.from);",
		"        });",
		"    }",
		"",
		"    // 按权重范围过滤边",
		"    vector<Edge> filter_by_weight(T min_weight, T max_weight) {",
		"        vector<Edge> filtered;",
		"        for (const Edge& e : edges) {",
		"            if (e.weight >= min_weight && e.weight <= max_weight) { filtered.push_back(e); }",
		"        }",
		"        return filtered;",
		"    }",
		"",
		"    // 获取关联某点的边",
		"    vector<Edge> get_incident_edges(int vertex) {",
		"        vector<Edge> incident;",
		"        for (const Edge& e : edges) {",
		"            if (e.from == vertex || e.to == vertex) { incident.push_back(e); }",
		"        }",
		"        return incident;",
		"    }",
		"",
		"    // 删除边",
		"    void remove_edge(int idx) {",
		"        if (idx >= 0 && idx < edges.size()) { edges.erase(edges.begin() + idx); }",
		"    }",
		"",
		"    // 删除指定权重的边",
		"    void remove_edges_by_weight(T weight) {",
		"        edges.erase(remove_if(edges.begin(), edges.end(), [weight](const Edge& e) { return e.weight == weight; }),",
		"                    edges.end());",
		"    }",
		"",
		"    // 清空边表",
		"    void clear() {",
		"        edges.clear();",
		"        edge_count = 0;",
		"    }",
		"",
		"    // 检查是否有重边",
		"    bool has_multiple_edges() {",
		"        set<pair<int, int>> edge_set;",
		"        for (const Edge& e : edges) {",
		"            pair<int, int> edge_pair = {min(e.from, e.to), max(e.from, e.to)};",
		"            if (edge_set.count(edge_pair)) { return true; }",
		"            edge_set.insert(edge_pair);",
		"        }",
		"        return false;",
		"    }",
		"",
		"    // 去除重边（保留权重最小的）",
		"    void remove_duplicate_edges() {",
		"        map<pair<int, int>, Edge> edge_map;",
		"        for (const Edge& e : edges) {",
		"            pair<int, int> key = {min(e.from, e.to), max(e.from, e.to)};",
		"            if (edge_map.find(key) == edge_map.end() || e.weight < edge_map[key].weight) { edge_map[key] = e; }",
		"        }",
		"",
		"        edges.clear();",
		"        for (const auto& [key, edge] : edge_map) { edges.push_back(edge); }",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Shortest_Path\BellmanFord.h
s("02_graph_theory_shortest_path_bellmanford_h", {
	t({
		"// Bellman-Ford和SPFA算法",
		"// 用于求解带负权边的单源最短路径",
		"using ll = long long;",
		"const ll INF = numeric_limits<ll>::max() / 2;",
		"",
		"// 基础Bellman-Ford算法",
		"// 时间复杂度O(VE)，空间复杂度O(V)",
		"struct BellmanFordBasic {",
		"    struct Edge {",
		"        int u, v;",
		"        ll w;",
		"    };",
		"",
		"    vector<Edge> edges;",
		"    vector<ll> dist;",
		"    vector<int> pre;",
		"    int n;",
		"",
		"    BellmanFordBasic(int n) : n(n), dist(n), pre(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { edges.push_back({u, v, w}); }",
		"",
		"    // 返回true表示无负环，false表示有负环",
		"    bool bellmanFord(int s) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(pre.begin(), pre.end(), -1);",
		"        dist[s] = 0;",
		"",
		"        // 松弛n-1轮",
		"        for (int i = 0; i < n - 1; i++) {",
		"            bool updated = false;",
		"            for (auto& e : edges) {",
		"                if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {",
		"                    dist[e.v] = dist[e.u] + e.w;",
		"                    pre[e.v] = e.u;",
		"                    updated = true;",
		"                }",
		"            }",
		"            if (!updated) break;  // 提前退出",
		"        }",
		"",
		"        // 检查负环",
		"        for (auto& e : edges) {",
		"            if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {",
		"                return false;  // 有负环",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 获取到目标点的路径",
		"    vector<int> getPath(int t) {",
		"        vector<int> path;",
		"        for (int x = t; x != -1; x = pre[x]) { path.push_back(x); }",
		"        reverse(path.begin(), path.end());",
		"        return path;",
		"    }",
		"",
		"    // 找出受负环影响的点",
		"    vector<bool> findNegativeCycleAffected() {",
		"        vector<bool> affected(n, false);",
		"",
		"        // 继续松弛找出受影响的点",
		"        for (int i = 0; i < n; i++) {",
		"            for (auto& e : edges) {",
		"                if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {",
		"                    dist[e.v] = dist[e.u] + e.w;",
		"                    affected[e.v] = true;",
		"                }",
		"                if (affected[e.u]) { affected[e.v] = true; }",
		"            }",
		"        }",
		"        return affected;",
		"    }",
		"};",
		"",
		"// SPFA算法 (Shortest Path Faster Algorithm)",
		"// 平均时间复杂度O(VE)，最坏时间复杂度O(VE)",
		"struct SPFA {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    vector<int> pre, cnt;",
		"    vector<bool> inQueue;",
		"    int n;",
		"",
		"    SPFA(int n) : n(n), g(n), dist(n), pre(n), cnt(n), inQueue(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    // 返回true表示无负环，false表示有负环",
		"    bool spfa(int s) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(pre.begin(), pre.end(), -1);",
		"        fill(cnt.begin(), cnt.end(), 0);",
		"        fill(inQueue.begin(), inQueue.end(), false);",
		"",
		"        queue<int> q;",
		"        dist[s] = 0;",
		"        q.push(s);",
		"        inQueue[s] = true;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    pre[v] = u;",
		"                    if (!inQueue[v]) {",
		"                        q.push(v);",
		"                        inQueue[v] = true;",
		"                        cnt[v]++;",
		"                        if (cnt[v] >= n) {",
		"                            return false;  // 有负环",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 获取到目标点的路径",
		"    vector<int> getPath(int t) {",
		"        vector<int> path;",
		"        for (int x = t; x != -1; x = pre[x]) { path.push_back(x); }",
		"        reverse(path.begin(), path.end());",
		"        return path;",
		"    }",
		"};",
		"",
		"// SLF优化的SPFA",
		"// Small Label First：将距离更小的点放在队首",
		"struct SPFA_SLF {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    vector<int> cnt;",
		"    vector<bool> inQueue;",
		"    int n;",
		"",
		"    SPFA_SLF(int n) : n(n), g(n), dist(n), cnt(n), inQueue(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    bool spfaSLF(int s) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(cnt.begin(), cnt.end(), 0);",
		"        fill(inQueue.begin(), inQueue.end(), false);",
		"",
		"        deque<int> q;",
		"        dist[s] = 0;",
		"        q.push_back(s);",
		"        inQueue[s] = true;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop_front();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    if (!inQueue[v]) {",
		"                        // SLF优化：距离小的放队首，大的放队尾",
		"                        if (!q.empty() && dist[v] < dist[q.front()]) {",
		"                            q.push_front(v);",
		"                        } else {",
		"                            q.push_back(v);",
		"                        }",
		"                        inQueue[v] = true;",
		"                        cnt[v]++;",
		"                        if (cnt[v] >= n) {",
		"                            return false;  // 有负环",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"};",
		"",
		"// 多源最短路径",
		"// 同时从多个源点开始计算最短路径",
		"struct MultiSourceSPFA {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    vector<bool> inQueue;",
		"    int n;",
		"",
		"    MultiSourceSPFA(int n) : n(n), g(n), dist(n), inQueue(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    vector<ll> multiSourceSPFA(const vector<int>& sources) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(inQueue.begin(), inQueue.end(), false);",
		"",
		"        queue<int> q;",
		"        for (int s : sources) {",
		"            dist[s] = 0;",
		"            q.push(s);",
		"            inQueue[s] = true;",
		"        }",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    if (!inQueue[v]) {",
		"                        q.push(v);",
		"                        inQueue[v] = true;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return dist;",
		"    }",
		"};",
		"",
		"// 负环检测专用算法",
		"// 判断图中是否存在负环，入队次数>=n即有负环",
		"struct NegativeCycleDetector {",
		"    vector<vector<pair<int, ll>>> g;",
		"    int n;",
		"",
		"    NegativeCycleDetector(int n) : n(n), g(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    bool hasNegativeCycle() {",
		"        vector<ll> dist(n, 0);",
		"        vector<int> cnt(n, 0);",
		"        vector<bool> inQueue(n, false);",
		"        queue<int> q;",
		"",
		"        // 所有点入队",
		"        for (int i = 0; i < n; i++) {",
		"            q.push(i);",
		"            inQueue[i] = true;",
		"        }",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    if (!inQueue[v]) {",
		"                        q.push(v);",
		"                        inQueue[v] = true;",
		"                        cnt[v]++;",
		"                        if (cnt[v] >= n) {",
		"                            return true;  // 有负环",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return false;",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Shortest_Path\Dijkstra.h
s("02_graph_theory_shortest_path_dijkstra_h", {
	t({
		"// Dijkstra最短路径算法",
		"// 适用于非负权图，时间复杂度O((V+E)logV)",
		"using ll = long long;",
		"using pii = pair<ll, int>;",
		"const ll INF = numeric_limits<ll>::max();",
		"",
		"// 基础Dijkstra算法",
		"// 使用优先队列优化，适合稀疏图",
		"struct DijkstraBasic {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    vector<int> pre;",
		"    int n;",
		"",
		"    DijkstraBasic(int n) : n(n), g(n), dist(n), pre(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    vector<ll> dijkstra(int s) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(pre.begin(), pre.end(), -1);",
		"        priority_queue<pii, vector<pii>, greater<pii>> pq;",
		"",
		"        dist[s] = 0;",
		"        pq.emplace(0, s);",
		"",
		"        while (!pq.empty()) {",
		"            auto [d, u] = pq.top();",
		"            pq.pop();",
		"",
		"            if (d > dist[u]) continue;  // 跳过过期状态",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    pre[v] = u;",
		"                    pq.emplace(dist[v], v);",
		"                }",
		"            }",
		"        }",
		"        return dist;",
		"    }",
		"",
		"    // 获取从源点到目标点的路径",
		"    vector<int> getPath(int t) {",
		"        vector<int> path;",
		"        for (int x = t; x != -1; x = pre[x]) { path.push_back(x); }",
		"        reverse(path.begin(), path.end());",
		"        return path;",
		"    }",
		"};",
		"",
		"// K短路径算法",
		"// 求从源点到目标点的前K条最短路径",
		"struct KShortestPath {",
		"    struct Edge {",
		"        int to;",
		"        ll w;",
		"    };",
		"",
		"    struct State {",
		"        ll dist;",
		"        int u, cnt;",
		"        bool operator>(const State& other) const { return dist > other.dist; }",
		"    };",
		"",
		"    vector<vector<Edge>> g;",
		"    int n;",
		"",
		"    KShortestPath(int n) : n(n), g(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].push_back({v, w}); }",
		"",
		"    vector<ll> kShortest(int s, int t, int k) {",
		"        vector<ll> result;",
		"        priority_queue<State, vector<State>, greater<State>> pq;",
		"        vector<int> cnt(n, 0);",
		"",
		"        pq.push({0, s, 0});",
		"",
		"        while (!pq.empty() && result.size() < k) {",
		"            auto [d, u, _] = pq.top();",
		"            pq.pop();",
		"",
		"            cnt[u]++;",
		"            if (u == t) { result.push_back(d); }",
		"            if (cnt[u] > k) continue;",
		"",
		"            for (auto& e : g[u]) { pq.push({d + e.w, e.to, 0}); }",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
		"",
		"// 带限制的最短路径",
		"// 允许使用不超过k条特殊边",
		"struct ConstrainedDijkstra {",
		"    struct Edge {",
		"        int to;",
		"        ll w;",
		"        int type;  // 边的类型，0为普通边，1为特殊边",
		"    };",
		"",
		"    vector<vector<Edge>> g;",
		"    int n;",
		"",
		"    ConstrainedDijkstra(int n) : n(n), g(n) {}",
		"",
		"    void addEdge(int u, int v, ll w, int type = 0) { g[u].push_back({v, w, type}); }",
		"",
		"    // 最多使用k条特殊边的最短路径",
		"    vector<vector<ll>> dijkstraWithLimit(int s, int maxSpecial) {",
		"        vector<vector<ll>> dist(n, vector<ll>(maxSpecial + 1, INF));",
		"        priority_queue<tuple<ll, int, int>, vector<tuple<ll, int, int>>, greater<>> pq;",
		"",
		"        dist[s][0] = 0;",
		"        pq.emplace(0, s, 0);",
		"",
		"        while (!pq.empty()) {",
		"            auto [d, u, used] = pq.top();",
		"            pq.pop();",
		"",
		"            if (d > dist[u][used]) continue;",
		"",
		"            for (auto& e : g[u]) {",
		"                int newUsed = used + (e.type == 1 ? 1 : 0);",
		"                if (newUsed > maxSpecial) continue;",
		"",
		"                if (dist[u][used] + e.w < dist[e.to][newUsed]) {",
		"                    dist[e.to][newUsed] = dist[u][used] + e.w;",
		"                    pq.emplace(dist[e.to][newUsed], e.to, newUsed);",
		"                }",
		"            }",
		"        }",
		"",
		"        return dist;",
		"    }",
		"};",
		"",
		"// 差分约束系统求解",
		"// 将形如 x[v] - x[u] <= w 的约束转化为最短路径问题",
		"struct DifferenceConstraints {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    int n;",
		"",
		"    DifferenceConstraints(int n) : n(n + 1), g(n + 1), dist(n + 1) {}",
		"",
		"    // 添加约束 x[v] - x[u] <= w",
		"    void addConstraint(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    // 求解差分约束系统",
		"    bool solve() {",
		"        // 添加超级源点，连接到所有点",
		"        for (int i = 0; i < n - 1; i++) { g[n - 1].emplace_back(i, 0); }",
		"",
		"        fill(dist.begin(), dist.end(), INF);",
		"        dist[n - 1] = 0;",
		"",
		"        // 使用Bellman-Ford算法检测负环",
		"        for (int i = 0; i < n; i++) {",
		"            bool updated = false;",
		"            for (int u = 0; u < n; u++) {",
		"                if (dist[u] == INF) continue;",
		"                for (auto [v, w] : g[u]) {",
		"                    if (dist[u] + w < dist[v]) {",
		"                        dist[v] = dist[u] + w;",
		"                        updated = true;",
		"                    }",
		"                }",
		"            }",
		"            if (!updated) break;",
		"            if (i == n - 1) return false;  // 存在负环，无解",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 获取一组可行解",
		"    vector<ll> getSolution() { return vector<ll>(dist.begin(), dist.end() - 1); }",
		"};",
	})
}),

-- 02_Graph_Theory\Shortest_Path\Floyd.h
s("02_graph_theory_shortest_path_floyd_h", {
	t({
		"// Floyd-Warshall全源最短路径算法",
		"// 用于求解任意两点间的最短距离，时间复杂度O(V^3)",
		"using ll = long long;",
		"const ll INF = numeric_limits<ll>::max() / 2;",
		"",
		"// 基础Floyd-Warshall算法",
		"// 可以处理负权边，检测负环",
		"struct FloydWarshall {",
		"    vector<vector<ll>> dist, path;",
		"    int n;",
		"",
		"    FloydWarshall(int n) : n(n), dist(n, vector<ll>(n, INF)), path(n, vector<ll>(n, -1)) {",
		"        for (int i = 0; i < n; i++) { dist[i][i] = 0; }",
		"    }",
		"",
		"    void addEdge(int u, int v, ll w) {",
		"        if (w < dist[u][v]) {",
		"            dist[u][v] = w;",
		"            path[u][v] = v;",
		"        }",
		"    }",
		"",
		"    void floyd() {",
		"        // 初始化路径",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < n; j++) {",
		"                if (i != j && dist[i][j] != INF) { path[i][j] = j; }",
		"            }",
		"        }",
		"",
		"        // Floyd核心算法",
		"        for (int k = 0; k < n; k++) {",
		"            for (int i = 0; i < n; i++) {",
		"                for (int j = 0; j < n; j++) {",
		"                    if (dist[i][k] != INF && dist[k][j] != INF) {",
		"                        if (dist[i][k] + dist[k][j] < dist[i][j]) {",
		"                            dist[i][j] = dist[i][k] + dist[k][j];",
		"                            path[i][j] = path[i][k];",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    // 获取从i到j的路径",
		"    vector<int> getPath(int i, int j) {",
		"        if (dist[i][j] == INF) return {};",
		"",
		"        vector<int> result;",
		"        int cur = i;",
		"        result.push_back(cur);",
		"",
		"        while (cur != j) {",
		"            cur = path[cur][j];",
		"            result.push_back(cur);",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 检查负环",
		"    bool hasNegativeCycle() {",
		"        for (int i = 0; i < n; i++) {",
		"            if (dist[i][i] < 0) { return true; }",
		"        }",
		"        return false;",
		"    }",
		"",
		"    // 获取图的直径（最长最短路径）",
		"    ll getDiameter() {",
		"        ll maxDist = 0;",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < n; j++) {",
		"                if (dist[i][j] != INF) { maxDist = max(maxDist, dist[i][j]); }",
		"            }",
		"        }",
		"        return maxDist;",
		"    }",
		"",
		"    // 获取图的半径（到其他所有点最大距离的最小值）",
		"    ll getRadius() {",
		"        ll radius = INF;",
		"        for (int i = 0; i < n; i++) {",
		"            ll maxFromI = 0;",
		"            for (int j = 0; j < n; j++) {",
		"                if (i != j && dist[i][j] != INF) { maxFromI = max(maxFromI, dist[i][j]); }",
		"            }",
		"            radius = min(radius, maxFromI);",
		"        }",
		"        return radius;",
		"    }",
		"};",
		"",
		"// 传递闭包",
		"// 用于判断任意两点间的可达性",
		"struct TransitiveClosure {",
		"    vector<vector<bool>> reach;",
		"    int n;",
		"",
		"    TransitiveClosure(int n) : n(n), reach(n, vector<bool>(n, false)) {",
		"        for (int i = 0; i < n; i++) { reach[i][i] = true; }",
		"    }",
		"",
		"    void addEdge(int u, int v) { reach[u][v] = true; }",
		"",
		"    void buildClosure() {",
		"        for (int k = 0; k < n; k++) {",
		"            for (int i = 0; i < n; i++) {",
		"                for (int j = 0; j < n; j++) { reach[i][j] = reach[i][j] || (reach[i][k] && reach[k][j]); }",
		"            }",
		"        }",
		"    }",
		"",
		"    bool isReachable(int u, int v) { return reach[u][v]; }",
		"};",
		"",
		"// 最小环算法",
		"// 使用Floyd变种找图中最小权重环",
		"struct MinimumCycle {",
		"    vector<vector<ll>> dist, original;",
		"    int n;",
		"",
		"    MinimumCycle(int n) : n(n), dist(n, vector<ll>(n, INF)), original(n, vector<ll>(n, INF)) {}",
		"",
		"    void addEdge(int u, int v, ll w) {",
		"        dist[u][v] = min(dist[u][v], w);",
		"        original[u][v] = min(original[u][v], w);",
		"    }",
		"",
		"    ll findMinimumCycle() {",
		"        ll minCycle = INF;",
		"",
		"        for (int k = 0; k < n; k++) {",
		"            // 在加入点k之前，检查通过k形成的环",
		"            for (int i = 0; i < k; i++) {",
		"                for (int j = 0; j < k; j++) {",
		"                    if (dist[i][j] != INF && original[j][k] != INF && original[k][i] != INF) {",
		"                        minCycle = min(minCycle, dist[i][j] + original[j][k] + original[k][i]);",
		"                    }",
		"                }",
		"            }",
		"",
		"            // Floyd更新",
		"            for (int i = 0; i < n; i++) {",
		"                for (int j = 0; j < n; j++) {",
		"                    if (dist[i][k] != INF && dist[k][j] != INF) {",
		"                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        return minCycle == INF ? -1 : minCycle;",
		"    }",
		"};",
		"",
		"// Johnson算法全源最短路径",
		"// 结合Bellman-Ford和Dijkstra的优点",
		"struct Johnson {",
		"    struct Edge {",
		"        int to;",
		"        ll w;",
		"    };",
		"",
		"    vector<vector<Edge>> g;",
		"    vector<vector<ll>> dist;",
		"    vector<ll> h;  // ???",
		"    int n;",
		"",
		"    Johnson(int n) : n(n), g(n + 1), dist(n, vector<ll>(n)), h(n + 1) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].push_back({v, w}); }",
		"",
		"    bool johnson() {",
		"        // 添加超级源点",
		"        for (int i = 0; i < n; i++) { g[n].push_back({i, 0}); }",
		"",
		"        // 使用Bellman-Ford计算势能函数",
		"        fill(h.begin(), h.end(), INF);",
		"        h[n] = 0;",
		"",
		"        for (int i = 0; i <= n; i++) {",
		"            bool updated = false;",
		"            for (int u = 0; u <= n; u++) {",
		"                if (h[u] == INF) continue;",
		"                for (auto& e : g[u]) {",
		"                    if (h[u] + e.w < h[e.to]) {",
		"                        h[e.to] = h[u] + e.w;",
		"                        updated = true;",
		"                    }",
		"                }",
		"            }",
		"            if (!updated) break;",
		"            if (i == n) return false;  // 有负环",
		"        }",
		"",
		"        // 重新标记边权",
		"        for (int u = 0; u < n; u++) {",
		"            for (auto& e : g[u]) { e.w += h[u] - h[e.to]; }",
		"        }",
		"",
		"        // 对每个点运行Dijkstra",
		"        for (int s = 0; s < n; s++) { dijkstraFromSource(s); }",
		"",
		"        // 恢复原始距离",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < n; j++) {",
		"                if (dist[i][j] != INF) { dist[i][j] += h[j] - h[i]; }",
		"            }",
		"        }",
		"",
		"        return true;",
		"    }",
		"",
		"   private:",
		"    void dijkstraFromSource(int s) {",
		"        using pii = pair<ll, int>;",
		"        priority_queue<pii, vector<pii>, greater<pii>> pq;",
		"",
		"        fill(dist[s].begin(), dist[s].end(), INF);",
		"        dist[s][s] = 0;",
		"        pq.emplace(0, s);",
		"",
		"        while (!pq.empty()) {",
		"            auto [d, u] = pq.top();",
		"            pq.pop();",
		"",
		"            if (d > dist[s][u]) continue;",
		"",
		"            for (auto& e : g[u]) {",
		"                if (dist[s][u] + e.w < dist[s][e.to]) {",
		"                    dist[s][e.to] = dist[s][u] + e.w;",
		"                    pq.emplace(dist[s][e.to], e.to);",
		"                }",
		"            }",
		"        }",
		"    }",
		"};",
		"",
		"// 最短路径计数",
		"// 统计任意两点间最短路径的数量",
		"struct ShortestPathCount {",
		"    vector<vector<ll>> dist, cnt;",
		"    int n;",
		"    const ll MOD = 1e9 + 7;",
		"",
		"    ShortestPathCount(int n) : n(n), dist(n, vector<ll>(n, INF)), cnt(n, vector<ll>(n, 0)) {",
		"        for (int i = 0; i < n; i++) {",
		"            dist[i][i] = 0;",
		"            cnt[i][i] = 1;",
		"        }",
		"    }",
		"",
		"    void addEdge(int u, int v, ll w) {",
		"        if (w < dist[u][v]) {",
		"            dist[u][v] = w;",
		"            cnt[u][v] = 1;",
		"        } else if (w == dist[u][v]) {",
		"            cnt[u][v] = (cnt[u][v] + 1) % MOD;",
		"        }",
		"    }",
		"",
		"    void floyd() {",
		"        for (int k = 0; k < n; k++) {",
		"            for (int i = 0; i < n; i++) {",
		"                for (int j = 0; j < n; j++) {",
		"                    if (dist[i][k] != INF && dist[k][j] != INF) {",
		"                        ll newDist = dist[i][k] + dist[k][j];",
		"                        if (newDist < dist[i][j]) {",
		"                            dist[i][j] = newDist;",
		"                            cnt[i][j] = (cnt[i][k] * cnt[k][j]) % MOD;",
		"                        } else if (newDist == dist[i][j]) {",
		"                            cnt[i][j] = (cnt[i][j] + cnt[i][k] * cnt[k][j]) % MOD;",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    ll getPathCount(int u, int v) { return cnt[u][v]; }",
		"};",
	})
}),

-- 02_Graph_Theory\Shortest_Path\SPFA.h
s("02_graph_theory_shortest_path_spfa_h", {
	t({
		"// SPFA (Shortest Path Faster Algorithm) 算法",
		"// Bellman-Ford算法的队列优化版本，适用于有负权边的图",
		"// 时间复杂度：平均 O(VE)，最坏情况 O(VE)",
		"// 空间复杂度：O(V + E)",
		"using ll = long long;",
		"const ll INF = numeric_limits<ll>::max() / 2;",
		"",
		"// 基础SPFA算法实现",
		"struct SPFA {",
		"    vector<vector<pair<int, ll>>> g;  // 邻接表",
		"    vector<ll> dist;                  // 距离数组",
		"    vector<int> pre, cnt;             // 前驱节点、入队次数",
		"    vector<bool> inQueue;             // 是否在队列中",
		"    int n;",
		"",
		"    SPFA(int n) : n(n), g(n), dist(n), pre(n), cnt(n), inQueue(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) {",
		"        g[u].emplace_back(v, w);",
		"    }",
		"",
		"    // 单源最短路径，返回true表示无负环",
		"    bool spfa(int s) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(pre.begin(), pre.end(), -1);",
		"        fill(cnt.begin(), cnt.end(), 0);",
		"        fill(inQueue.begin(), inQueue.end(), false);",
		"",
		"        queue<int> q;",
		"        dist[s] = 0;",
		"        q.push(s);",
		"        inQueue[s] = true;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    pre[v] = u;",
		"                    if (!inQueue[v]) {",
		"                        q.push(v);",
		"                        inQueue[v] = true;",
		"                        cnt[v]++;",
		"                        if (cnt[v] >= n) {",
		"                            return false;  // 存在负环",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 获取从源点到目标点的路径",
		"    vector<int> getPath(int t) {",
		"        vector<int> path;",
		"        for (int x = t; x != -1; x = pre[x]) {",
		"            path.push_back(x);",
		"        }",
		"        reverse(path.begin(), path.end());",
		"        return path;",
		"    }",
		"",
		"    // 获取到各点的距离",
		"    vector<ll> getDistances() { return dist; }",
		"};",
		"",
		"// SLF优化的SPFA",
		"// Small Label First：将距离更小的点放在队首",
		"struct SPFA_SLF {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    vector<int> cnt;",
		"    vector<bool> inQueue;",
		"    int n;",
		"",
		"    SPFA_SLF(int n) : n(n), g(n), dist(n), cnt(n), inQueue(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    bool spfaSLF(int s) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(cnt.begin(), cnt.end(), 0);",
		"        fill(inQueue.begin(), inQueue.end(), false);",
		"",
		"        deque<int> q;",
		"        dist[s] = 0;",
		"        q.push_back(s);",
		"        inQueue[s] = true;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop_front();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    if (!inQueue[v]) {",
		"                        // SLF优化：如果新距离小于队首元素距离，插入队首",
		"                        if (!q.empty() && dist[v] < dist[q.front()]) {",
		"                            q.push_front(v);",
		"                        } else {",
		"                            q.push_back(v);",
		"                        }",
		"                        inQueue[v] = true;",
		"                        cnt[v]++;",
		"                        if (cnt[v] >= n) {",
		"                            return false;  // 存在负环",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"};",
		"",
		"// LLL优化的SPFA",
		"// Large Label Last：将距离较大的点移到队尾",
		"struct SPFA_LLL {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    vector<int> cnt;",
		"    vector<bool> inQueue;",
		"    int n;",
		"",
		"    SPFA_LLL(int n) : n(n), g(n), dist(n), cnt(n), inQueue(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    bool spfaLLL(int s) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(cnt.begin(), cnt.end(), 0);",
		"        fill(inQueue.begin(), inQueue.end(), false);",
		"",
		"        deque<int> q;",
		"        dist[s] = 0;",
		"        q.push_back(s);",
		"        inQueue[s] = true;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop_front();",
		"",
		"            // LLL优化：如果队首元素距离大于平均值，移到队尾",
		"            if (!q.empty()) {",
		"                ll avgDist = 0;",
		"                for (int x : q) avgDist += dist[x];",
		"                avgDist /= q.size();",
		"",
		"                if (dist[u] > avgDist) {",
		"                    q.push_back(u);",
		"                    continue;",
		"                }",
		"            }",
		"",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    if (!inQueue[v]) {",
		"                        q.push_back(v);",
		"                        inQueue[v] = true;",
		"                        cnt[v]++;",
		"                        if (cnt[v] >= n) {",
		"                            return false;  // 存在负环",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"};",
		"",
		"// 多源SPFA",
		"// 同时从多个源点开始计算最短路径",
		"struct MultiSourceSPFA {",
		"    vector<vector<pair<int, ll>>> g;",
		"    vector<ll> dist;",
		"    vector<bool> inQueue;",
		"    int n;",
		"",
		"    MultiSourceSPFA(int n) : n(n), g(n), dist(n), inQueue(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    vector<ll> multiSourceSPFA(const vector<int>& sources) {",
		"        fill(dist.begin(), dist.end(), INF);",
		"        fill(inQueue.begin(), inQueue.end(), false);",
		"",
		"        queue<int> q;",
		"        for (int s : sources) {",
		"            dist[s] = 0;",
		"            q.push(s);",
		"            inQueue[s] = true;",
		"        }",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    if (!inQueue[v]) {",
		"                        q.push(v);",
		"                        inQueue[v] = true;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return dist;",
		"    }",
		"};",
		"",
		"// 负环检测器",
		"// 专门用于检测图中是否存在负环",
		"struct NegativeCycleDetector {",
		"    vector<vector<pair<int, ll>>> g;",
		"    int n;",
		"",
		"    NegativeCycleDetector(int n) : n(n), g(n) {}",
		"",
		"    void addEdge(int u, int v, ll w) { g[u].emplace_back(v, w); }",
		"",
		"    // 检测是否存在负环",
		"    bool hasNegativeCycle() {",
		"        vector<ll> dist(n, 0);",
		"        vector<int> cnt(n, 0);",
		"        vector<bool> inQueue(n, false);",
		"        queue<int> q;",
		"",
		"        // 将所有点加入队列",
		"        for (int i = 0; i < n; i++) {",
		"            q.push(i);",
		"            inQueue[i] = true;",
		"        }",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            inQueue[u] = false;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    if (!inQueue[v]) {",
		"                        q.push(v);",
		"                        inQueue[v] = true;",
		"                        cnt[v]++;",
		"                        if (cnt[v] >= n) {",
		"                            return true;  // 存在负环",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return false;",
		"    }",
		"",
		"    // 找出所有在负环上或能到达负环的点",
		"    vector<bool> findNegativeCycleAffected() {",
		"        vector<ll> dist(n, 0);",
		"        vector<bool> inQueue(n, false);",
		"        vector<bool> affected(n, false);",
		"        queue<int> q;",
		"",
		"        // 将所有点加入队列",
		"        for (int i = 0; i < n; i++) {",
		"            q.push(i);",
		"            inQueue[i] = true;",
		"        }",
		"",
		"        // 运行n轮松弛",
		"        for (int round = 0; round < n; round++) {",
		"            int qSize = q.size();",
		"            for (int i = 0; i < qSize; i++) {",
		"                int u = q.front();",
		"                q.pop();",
		"                inQueue[u] = false;",
		"",
		"                for (auto [v, w] : g[u]) {",
		"                    if (dist[u] + w < dist[v]) {",
		"                        dist[v] = dist[u] + w;",
		"                        if (!inQueue[v]) {",
		"                            q.push(v);",
		"                            inQueue[v] = true;",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        // 再运行一轮，如果还能松弛，说明受负环影响",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"            affected[u] = true;",
		"",
		"            for (auto [v, w] : g[u]) {",
		"                if (dist[u] + w < dist[v] && !affected[v]) {",
		"                    dist[v] = dist[u] + w;",
		"                    q.push(v);",
		"                }",
		"            }",
		"        }",
		"",
		"        return affected;",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Special\Chromatic.h
s("02_graph_theory_special_chromatic_h", {
	t({
		"// 图着色算法集合",
		"// 包含多种图着色算法：贪心着色、回溯着色、DSATUR算法等",
		"// 时间复杂度：贪心O(V+E)，回溯O(k^V)，DSATUR O(V^2)",
		"struct GraphColoring {",
		"    int n;",
		"    vector<vector<int>> graph;",
		"    vector<int> color;",
		"    int max_colors;",
		"",
		"    GraphColoring(int sz) : n(sz), max_colors(0) {",
		"        graph.resize(n);",
		"        color.resize(n, -1);",
		"    }",
		"",
		"    void add_edge(int u, int v) {",
		"        graph[u].push_back(v);",
		"        graph[v].push_back(u);",
		"    }",
		"",
		"    // 贪心着色算法（Welsh-Powell算法）",
		"    // 按度数降序排列顶点，依次为每个顶点分配最小可用颜色",
		"    int greedy_coloring() {",
		"        color.assign(n, -1);",
		"        vector<int> order(n);",
		"        iota(order.begin(), order.end(), 0);",
		"",
		"        // 按度数降序排列（Welsh-Powell算法）",
		"        sort(order.begin(), order.end(), [&](int a, int b) { return graph[a].size() > graph[b].size(); });",
		"",
		"        max_colors = 0;",
		"        for (int u : order) {",
		"            vector<bool> used(n, false);",
		"            for (int v : graph[u]) {",
		"                if (color[v] != -1) { used[color[v]] = true; }",
		"            }",
		"",
		"            for (int c = 0; c < n; c++) {",
		"                if (!used[c]) {",
		"                    color[u] = c;",
		"                    max_colors = max(max_colors, c + 1);",
		"                    break;",
		"                }",
		"            }",
		"        }",
		"",
		"        return max_colors;",
		"    }",
		"",
		"    // 回溯算法精确着色",
		"    // 尝试用指定数量的颜色对图进行着色",
		"    bool backtrack_coloring(int vertex, int num_colors) {",
		"        if (vertex == n) return true;",
		"",
		"        for (int c = 0; c < num_colors; c++) {",
		"            bool valid = true;",
		"            for (int v : graph[vertex]) {",
		"                if (color[v] == c) {",
		"                    valid = false;",
		"                    break;",
		"                }",
		"            }",
		"",
		"            if (valid) {",
		"                color[vertex] = c;",
		"                if (backtrack_coloring(vertex + 1, num_colors)) { return true; }",
		"                color[vertex] = -1;",
		"            }",
		"        }",
		"",
		"        return false;",
		"    }",
		"",
		"    // 寻找最小着色数（色数）",
		"    // 使用回溯算法找到能够着色的最少颜色数",
		"    int find_chromatic_number() {",
		"        for (int colors = 1; colors <= n; colors++) {",
		"            color.assign(n, -1);",
		"            if (backtrack_coloring(0, colors)) {",
		"                max_colors = colors;",
		"                return colors;",
		"            }",
		"        }",
		"        return n;  // 最坏情况",
		"    }",
		"",
		"    // DSATUR算法（动态饱和度优先）",
		"    // 优先选择饱和度最大的顶点进行着色，通常比贪心算法效果更好",
		"    int dsatur_coloring() {",
		"        color.assign(n, -1);",
		"        vector<int> degree(n), saturation(n, 0);",
		"        vector<set<int>> colored_neighbors(n);",
		"",
		"        for (int i = 0; i < n; i++) { degree[i] = graph[i].size(); }",
		"",
		"        // 选择度数最大的顶点开始",
		"        int start = max_element(degree.begin(), degree.end()) - degree.begin();",
		"        color[start] = 0;",
		"        max_colors = 1;",
		"",
		"        // 更新相邻顶点的饱和度",
		"        for (int v : graph[start]) {",
		"            colored_neighbors[v].insert(0);",
		"            saturation[v] = colored_neighbors[v].size();",
		"        }",
		"",
		"        for (int colored = 1; colored < n; colored++) {",
		"            int next = -1;",
		"            int max_sat = -1, max_deg = -1;",
		"",
		"            // 选择饱和度最大的未着色顶点",
		"            for (int i = 0; i < n; i++) {",
		"                if (color[i] == -1) {",
		"                    if (saturation[i] > max_sat || (saturation[i] == max_sat && degree[i] > max_deg)) {",
		"                        max_sat = saturation[i];",
		"                        max_deg = degree[i];",
		"                        next = i;",
		"                    }",
		"                }",
		"            }",
		"",
		"            // 为选中的顶点着色",
		"            for (int c = 0; c < n; c++) {",
		"                if (colored_neighbors[next].find(c) == colored_neighbors[next].end()) {",
		"                    color[next] = c;",
		"                    max_colors = max(max_colors, c + 1);",
		"                    break;",
		"                }",
		"            }",
		"",
		"            // 更新相邻未着色顶点的饱和度",
		"            for (int v : graph[next]) {",
		"                if (color[v] == -1) {",
		"                    colored_neighbors[v].insert(color[next]);",
		"                    saturation[v] = colored_neighbors[v].size();",
		"                }",
		"            }",
		"        }",
		"",
		"        return max_colors;",
		"    }",
		"",
		"    // 检查是否为二分图（2-着色）",
		"    // 使用BFS检查图是否可以用两种颜色着色",
		"    bool is_bipartite() {",
		"        color.assign(n, -1);",
		"        queue<int> q;",
		"",
		"        for (int start = 0; start < n; start++) {",
		"            if (color[start] == -1) {",
		"                color[start] = 0;",
		"                q.push(start);",
		"",
		"                while (!q.empty()) {",
		"                    int u = q.front();",
		"                    q.pop();",
		"",
		"                    for (int v : graph[u]) {",
		"                        if (color[v] == -1) {",
		"                            color[v] = 1 - color[u];",
		"                            q.push(v);",
		"                        } else if (color[v] == color[u]) {",
		"                            return false;",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        max_colors = 2;",
		"        return true;",
		"    }",
		"",
		"    // 边着色算法（Vizing算法近似）",
		"    // 为图的边进行着色，使得相邻的边颜色不同",
		"    int edge_coloring() {",
		"        vector<vector<pair<int, int>>> edge_colors(n);",
		"        map<pair<int, int>, int> edge_color_map;",
		"        int num_edge_colors = 0;",
		"",
		"        for (int u = 0; u < n; u++) {",
		"            for (int v : graph[u]) {",
		"                if (u < v) {  // 避免重复处理边",
		"                    set<int> used_colors;",
		"",
		"                    // 收集u和v已使用的边颜色",
		"                    for (auto& edge : edge_colors[u]) { used_colors.insert(edge.second); }",
		"                    for (auto& edge : edge_colors[v]) { used_colors.insert(edge.second); }",
		"",
		"                    // 找到最小可用颜色",
		"                    int color = 0;",
		"                    while (used_colors.count(color)) color++;",
		"",
		"                    edge_colors[u].push_back({v, color});",
		"                    edge_colors[v].push_back({u, color});",
		"                    edge_color_map[{min(u, v), max(u, v)}] = color;",
		"                    num_edge_colors = max(num_edge_colors, color + 1);",
		"                }",
		"            }",
		"        }",
		"",
		"        return num_edge_colors;",
		"    }",
		"",
		"    // 完美着色验证",
		"    // 检查当前着色方案是否满足相邻顶点颜色不同的要求",
		"    bool verify_coloring() {",
		"        for (int u = 0; u < n; u++) {",
		"            for (int v : graph[u]) {",
		"                if (color[u] == color[v]) { return false; }",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 获取当前着色方案",
		"    vector<int> get_coloring() { return color; }",
		"",
		"    // 计算图的团数上界（着色数下界）",
		"    // 图的色数至少等于最大团的大小",
		"    int max_clique_bound() {",
		"        // 简单实现：寻找最大团的大小",
		"        int max_clique_size = 1;",
		"",
		"        for (int u = 0; u < n; u++) {",
		"            vector<int> candidates = graph[u];",
		"            candidates.push_back(u);",
		"",
		"            // 检查候选集合是否形成团",
		"            bool is_clique = true;",
		"            for (int i = 0; i < candidates.size() && is_clique; i++) {",
		"                for (int j = i + 1; j < candidates.size() && is_clique; j++) {",
		"                    int v1 = candidates[i], v2 = candidates[j];",
		"                    bool connected = false;",
		"                    for (int neighbor : graph[v1]) {",
		"                        if (neighbor == v2) {",
		"                            connected = true;",
		"                            break;",
		"                        }",
		"                    }",
		"                    if (!connected) is_clique = false;",
		"                }",
		"            }",
		"",
		"            if (is_clique) { max_clique_size = max(max_clique_size, (int)candidates.size()); }",
		"        }",
		"",
		"        return max_clique_size;",
		"    }",
		"",
		"    // Brooks定理检查",
		"    // 检查Brooks定理是否适用：除完全图和奇圈外，色数不超过最大度数",
		"    bool brooks_theorem_applies() {",
		"        // Brooks定理：除了完全图和奇圈，其他连通图的色数不超过最大度数",
		"        int max_degree = 0;",
		"        for (int i = 0; i < n; i++) { max_degree = max(max_degree, (int)graph[i].size()); }",
		"",
		"        // 检查是否为完全图",
		"        bool is_complete = true;",
		"        for (int i = 0; i < n && is_complete; i++) {",
		"            if (graph[i].size() != n - 1) is_complete = false;",
		"        }",
		"",
		"        if (is_complete) return false;",
		"",
		"        // 检查是否为奇圈",
		"        if (max_degree == 2) {",
		"            // 可能是圈，检查长度",
		"            vector<bool> visited(n, false);",
		"            function<bool(int, int, int)> is_odd_cycle = [&](int u, int start, int depth) -> bool {",
		"                if (depth > 1 && u == start) { return depth % 2 == 1; }",
		"",
		"                visited[u] = true;",
		"                for (int v : graph[u]) {",
		"                    if (depth == 0 || v != start || depth > 2) {",
		"                        if (!visited[v] || (depth > 2 && v == start)) {",
		"                            if (is_odd_cycle(v, start, depth + 1)) return true;",
		"                        }",
		"                    }",
		"                }",
		"                return false;",
		"            };",
		"",
		"            if (is_odd_cycle(0, 0, 0)) return false;",
		"        }",
		"",
		"        return true;",
		"    }",
		"};",
		"",
		"// 使用示例：",
		"// GraphColoring gc(n);",
		"// gc.add_edge(u, v);",
		"// int colors = gc.greedy_coloring();",
		"// bool bipartite = gc.is_bipartite();",
		"// int chromatic = gc.find_chromatic_number();",
	})
}),

-- 02_Graph_Theory\Special\EulerPath.h
s("02_graph_theory_special_eulerpath_h", {
	t({
		"// 欧拉路径和欧拉回路算法",
		"// 欧拉路径：经过图中每条边恰好一次的路径",
		"// 欧拉回路：起点和终点相同的欧拉路径",
		"// 时间复杂度：O(V+E)",
		"struct EulerPath {",
		"    int n;",
		"    vector<vector<int>> graph;",
		"    vector<int> degree;",
		"    vector<bool> used_edge;",
		"    vector<int> path;",
		"",
		"    EulerPath(int sz) : n(sz) {",
		"        graph.resize(n);",
		"        degree.resize(n, 0);",
		"    }",
		"",
		"    void add_edge(int u, int v, bool directed = false) {",
		"        graph[u].push_back(v);",
		"        degree[u]++;",
		"        if (!directed) {",
		"            graph[v].push_back(u);",
		"            degree[v]++;",
		"        } else {",
		"            degree[v]--;  // 有向图：记录出度-入度",
		"        }",
		"    }",
		"",
		"    // 检查是否存在欧拉路径/回路",
		"    // 无向图：奇度顶点0个→欧拉回路，2个→欧拉路径",
		"    // 有向图：所有顶点入度=出度→欧拉回路，1个顶点出度-入度=1，1个顶点入度-出度=1→欧拉路径",
		"    pair<bool, pair<int, int>> check_euler_path(bool directed = false) {",
		"        if (directed) {",
		"            int start = -1, end = -1;",
		"            for (int i = 0; i < n; i++) {",
		"                if (degree[i] == 1) {",
		"                    if (start == -1)",
		"                        start = i;",
		"                    else",
		"                        return {false, {-1, -1}};",
		"                } else if (degree[i] == -1) {",
		"                    if (end == -1)",
		"                        end = i;",
		"                    else",
		"                        return {false, {-1, -1}};",
		"                } else if (degree[i] != 0) {",
		"                    return {false, {-1, -1}};",
		"                }",
		"            }",
		"            if (start == -1 && end == -1) return {true, {0, 0}};        // 欧拉回路",
		"            if (start != -1 && end != -1) return {true, {start, end}};  // 欧拉路径",
		"            return {false, {-1, -1}};",
		"        } else {",
		"            int odd_count = 0;",
		"            vector<int> odd_vertices;",
		"            for (int i = 0; i < n; i++) {",
		"                if (degree[i] % 2 == 1) {",
		"                    odd_count++;",
		"                    odd_vertices.push_back(i);",
		"                }",
		"            }",
		"            if (odd_count == 0) return {true, {0, 0}};                              // 欧拉回路",
		"            if (odd_count == 2) return {true, {odd_vertices[0], odd_vertices[1]}};  // 欧拉路径",
		"            return {false, {-1, -1}};",
		"        }",
		"    }",
		"",
		"    // Hierholzer算法求欧拉路径",
		"    // 基于DFS的算法，时间复杂度O(V+E)",
		"    vector<int> find_euler_path(int start = -1, bool directed = false) {",
		"        auto euler_check = check_euler_path(directed);",
		"        if (!euler_check.first) return {};",
		"",
		"        if (start == -1) start = euler_check.second.first;",
		"",
		"        // 建立邻接表的边索引",
		"        vector<vector<pair<int, int>>> adj(n);",
		"        int edge_id = 0;",
		"        for (int u = 0; u < n; u++) {",
		"            for (int v : graph[u]) {",
		"                adj[u].push_back({v, edge_id++});",
		"                if (!directed) { adj[v].push_back({u, edge_id - 1}); }",
		"            }",
		"        }",
		"",
		"        used_edge.assign(edge_id, false);",
		"        vector<int> current_path;",
		"        vector<int> result;",
		"",
		"        current_path.push_back(start);",
		"",
		"        while (!current_path.empty()) {",
		"            int u = current_path.back();",
		"            bool found = false;",
		"",
		"            for (auto& edge : adj[u]) {",
		"                int v = edge.first;",
		"                int eid = edge.second;",
		"",
		"                if (!used_edge[eid]) {",
		"                    used_edge[eid] = true;",
		"                    current_path.push_back(v);",
		"                    found = true;",
		"                    break;",
		"                }",
		"            }",
		"",
		"            if (!found) {",
		"                result.push_back(current_path.back());",
		"                current_path.pop_back();",
		"            }",
		"        }",
		"",
		"        reverse(result.begin(), result.end());",
		"        return result;",
		"    }",
		"",
		"    // 检查图的连通性",
		"    // 欧拉路径存在的必要条件之一",
		"    bool is_connected() {",
		"        vector<bool> visited(n, false);",
		"        int start = 0;",
		"        while (start < n && graph[start].empty()) start++;",
		"        if (start == n) return true;  // 没有边",
		"",
		"        function<void(int)> dfs = [&](int u) {",
		"            visited[u] = true;",
		"            for (int v : graph[u]) {",
		"                if (!visited[v]) dfs(v);",
		"            }",
		"        };",
		"",
		"        dfs(start);",
		"        for (int i = 0; i < n; i++) {",
		"            if (!graph[i].empty() && !visited[i]) { return false; }",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 求所有欧拉回路的数量（BEST定理）",
		"    // 仅适用于有向强连通图且每个顶点入度=出度",
		"    long long count_euler_circuits() {",
		"        // 可以通过矩阵树定理计算，但实现复杂",
		"        return -1;  // 表示未实现",
		"    }",
		"};",
		"",
		"// 使用示例：",
		"// EulerPath euler(n);",
		"// euler.add_edge(u, v);",
		"// auto check = euler.check_euler_path();",
		"// if (check.first) {",
		"//     vector<int> path = euler.find_euler_path(check.second.first);",
		"// }",
	})
}),

-- 02_Graph_Theory\Special\HamiltonPath.h
s("02_graph_theory_special_hamiltonpath_h", {
	t({
		"// 哈密顿路径和哈密顿回路算法",
		"// 哈密顿路径：经过图中每个顶点恰好一次的路径",
		"// 哈密顿回路：起点和终点相同的哈密顿路径",
		"// 这是NP完全问题，只能用指数时间算法求解",
		"struct HamiltonPath {",
		"    int n;",
		"    vector<vector<int>> graph;",
		"    vector<vector<bool>> adj;",
		"    vector<bool> visited;",
		"    vector<int> path;",
		"    vector<vector<int>> all_paths;",
		"",
		"    HamiltonPath(int sz) : n(sz) {",
		"        graph.resize(n);",
		"        adj.assign(n, vector<bool>(n, false));",
		"        visited.resize(n);",
		"    }",
		"",
		"    void add_edge(int u, int v, bool directed = false) {",
		"        graph[u].push_back(v);",
		"        adj[u][v] = true;",
		"        if (!directed) {",
		"            graph[v].push_back(u);",
		"            adj[v][u] = true;",
		"        }",
		"    }",
		"",
		"    // 回溯算法求哈密顿路径",
		"    // 时间复杂度：O(n!)，适合小规模图",
		"    bool find_hamilton_path_dfs(int u, int target, int depth) {",
		"        if (depth == n) {",
		"            return (target == -1 || adj[u][target]);  // target=-1表示路径，否则是回路",
		"        }",
		"",
		"        for (int v : graph[u]) {",
		"            if (!visited[v]) {",
		"                visited[v] = true;",
		"                path[depth] = v;",
		"                if (find_hamilton_path_dfs(v, target, depth + 1)) { return true; }",
		"                visited[v] = false;",
		"            }",
		"        }",
		"        return false;",
		"    }",
		"",
		"    // 寻找哈密顿路径（从start开始）",
		"    vector<int> find_hamilton_path(int start) {",
		"        visited.assign(n, false);",
		"        path.assign(n, -1);",
		"",
		"        visited[start] = true;",
		"        path[0] = start;",
		"",
		"        if (find_hamilton_path_dfs(start, -1, 1)) { return path; }",
		"        return {};",
		"    }",
		"",
		"    // 寻找哈密顿回路（从start开始并回到start）",
		"    vector<int> find_hamilton_cycle(int start) {",
		"        visited.assign(n, false);",
		"        path.assign(n, -1);",
		"",
		"        visited[start] = true;",
		"        path[0] = start;",
		"",
		"        if (find_hamilton_path_dfs(start, start, 1)) { return path; }",
		"        return {};",
		"    }",
		"",
		"    // 动态规划解法（状态压缩DP）",
		"    // 时间复杂度：O(n^2 * 2^n)，空间复杂度：O(n * 2^n)",
		"    // 适合n<=20的图",
		"    pair<bool, vector<int>> hamilton_path_dp(int start, int end = -1) {",
		"        // dp[mask][i] 表示访问过mask中的点，当前在点i的最小路径长度",
		"        vector<vector<int>> dp(1 << n, vector<int>(n, -1));",
		"        vector<vector<int>> parent(1 << n, vector<int>(n, -1));",
		"",
		"        dp[1 << start][start] = 0;",
		"",
		"        for (int mask = 0; mask < (1 << n); mask++) {",
		"            for (int u = 0; u < n; u++) {",
		"                if (!(mask & (1 << u)) || dp[mask][u] == -1) continue;",
		"",
		"                for (int v : graph[u]) {",
		"                    if (mask & (1 << v)) continue;  // 已经访问过",
		"",
		"                    int new_mask = mask | (1 << v);",
		"                    if (dp[new_mask][v] == -1) {",
		"                        dp[new_mask][v] = dp[mask][u] + 1;",
		"                        parent[new_mask][v] = u;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        // 寻找哈密顿路径",
		"        int full_mask = (1 << n) - 1;",
		"        int best_end = -1;",
		"",
		"        if (end == -1) {",
		"            // 寻找任意终点的哈密顿路径",
		"            for (int i = 0; i < n; i++) {",
		"                if (dp[full_mask][i] != -1) {",
		"                    best_end = i;",
		"                    break;",
		"                }",
		"            }",
		"        } else {",
		"            // 指定终点",
		"            if (dp[full_mask][end] != -1) { best_end = end; }",
		"        }",
		"",
		"        if (best_end == -1) return {false, {}};",
		"",
		"        // 重构路径",
		"        vector<int> result_path;",
		"        int mask = full_mask;",
		"        int curr = best_end;",
		"",
		"        while (curr != -1) {",
		"            result_path.push_back(curr);",
		"            int prev = parent[mask][curr];",
		"            if (prev != -1) { mask ^= (1 << curr); }",
		"            curr = prev;",
		"        }",
		"",
		"        reverse(result_path.begin(), result_path.end());",
		"        return {true, result_path};",
		"    }",
		"",
		"    // 检查哈密顿回路（状态压缩DP）",
		"    // 使用动态规划检查是否存在哈密顿回路并构造路径",
		"    pair<bool, vector<int>> hamilton_cycle_dp(int start = 0) {",
		"        vector<vector<int>> dp(1 << n, vector<int>(n, -1));",
		"        vector<vector<int>> parent(1 << n, vector<int>(n, -1));",
		"",
		"        dp[1 << start][start] = 0;",
		"",
		"        for (int mask = 0; mask < (1 << n); mask++) {",
		"            for (int u = 0; u < n; u++) {",
		"                if (!(mask & (1 << u)) || dp[mask][u] == -1) continue;",
		"",
		"                for (int v : graph[u]) {",
		"                    if (mask & (1 << v)) continue;",
		"",
		"                    int new_mask = mask | (1 << v);",
		"                    if (dp[new_mask][v] == -1) {",
		"                        dp[new_mask][v] = dp[mask][u] + 1;",
		"                        parent[new_mask][v] = u;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        // 检查是否能回到起点",
		"        int full_mask = (1 << n) - 1;",
		"        for (int u = 0; u < n; u++) {",
		"            if (u != start && dp[full_mask][u] != -1 && adj[u][start]) {",
		"                // 重构路径",
		"                vector<int> result_path;",
		"                int mask = full_mask;",
		"                int curr = u;",
		"",
		"                while (curr != -1) {",
		"                    result_path.push_back(curr);",
		"                    int prev = parent[mask][curr];",
		"                    if (prev != -1) { mask ^= (1 << curr); }",
		"                    curr = prev;",
		"                }",
		"",
		"                reverse(result_path.begin(), result_path.end());",
		"                result_path.push_back(start);  // 添加回到起点",
		"                return {true, result_path};",
		"            }",
		"        }",
		"",
		"        return {false, {}};",
		"    }",
		"",
		"    // 计算所有哈密顿路径的数量",
		"    // 用于小规模图的完整枚举",
		"    int count_hamilton_paths() {",
		"        all_paths.clear();",
		"        function<void(int, vector<int>&)> dfs = [&](int depth, vector<int>& current_path) {",
		"            if (depth == n) {",
		"                all_paths.push_back(current_path);",
		"                return;",
		"            }",
		"",
		"            int u = current_path.back();",
		"            for (int v : graph[u]) {",
		"                if (find(current_path.begin(), current_path.end(), v) == current_path.end()) {",
		"                    current_path.push_back(v);",
		"                    dfs(depth + 1, current_path);",
		"                    current_path.pop_back();",
		"                }",
		"            }",
		"        };",
		"",
		"        for (int start = 0; start < n; start++) {",
		"            vector<int> current_path = {start};",
		"            dfs(1, current_path);",
		"        }",
		"",
		"        return all_paths.size();",
		"    }",
		"",
		"    // Ore定理检查（充分条件）",
		"    // 如果对于不相邻的顶点u,v，有deg(u)+deg(v)>=n，则存在哈密顿回路",
		"    bool ore_theorem_check() {",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = i + 1; j < n; j++) {",
		"                if (!adj[i][j] && graph[i].size() + graph[j].size() < n) { return false; }",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // Dirac定理检查（充分条件）",
		"    // 如果每个顶点的度数至少为n/2，则存在哈密顿回路",
		"    bool dirac_theorem_check() {",
		"        for (int i = 0; i < n; i++) {",
		"            if (graph[i].size() < n / 2) { return false; }",
		"        }",
		"        return true;",
		"    }",
		"};",
		"",
		"// 使用示例：",
		"// HamiltonPath hamilton(n);",
		"// hamilton.add_edge(u, v);",
		"// vector<int> path = hamilton.find_hamilton_path(0);",
		"// auto [has_cycle, cycle] = hamilton.hamilton_cycle_dp();",
	})
}),

-- 02_Graph_Theory\Special\PlanarGraph.h
s("02_graph_theory_special_planargraph_h", {
	t({
		"// 平面图相关算法",
		"// 平面图：可以在平面上绘制且边不相交的图",
		"// 包含平面性测试、欧拉公式验证、对偶图构造等算法",
		"struct PlanarGraph {",
		"    int n, m;",
		"    vector<vector<int>> graph;",
		"    vector<pair<int, int>> edges;",
		"",
		"    PlanarGraph(int vertices) : n(vertices), m(0) { graph.resize(n); }",
		"",
		"    void add_edge(int u, int v) {",
		"        graph[u].push_back(v);",
		"        graph[v].push_back(u);",
		"        edges.push_back({u, v});",
		"        m++;",
		"    }",
		"",
		"    // Kuratowski定理检查（基于K5和K3,3子图）",
		"    // 图是平面图当且仅当不包含K5或K3,3的细分",
		"    bool has_k5_subdivision() {",
		"        // 检查是否包含K5的细分",
		"        if (n < 5) return false;",
		"",
		"        // 枚举所有5个顶点的子集",
		"        function<bool(vector<int>&, int, int)> check_k5;",
		"        check_k5 = [&](vector<int>& vertices, int start, int count) -> bool {",
		"            if (count == 5) {",
		"                // 检查这5个顶点是否能形成K5的细分",
		"                for (int i = 0; i < 5; i++) {",
		"                    for (int j = i + 1; j < 5; j++) {",
		"                        // 检查vertices[i]和vertices[j]之间是否有路径",
		"                        if (!has_path_subdivision(vertices[i], vertices[j], vertices)) { return false; }",
		"                    }",
		"                }",
		"                return true;",
		"            }",
		"",
		"            for (int i = start; i < n; i++) {",
		"                vertices[count] = i;",
		"                if (check_k5(vertices, i + 1, count + 1)) { return true; }",
		"            }",
		"            return false;",
		"        };",
		"",
		"        vector<int> vertices(5);",
		"        return check_k5(vertices, 0, 0);",
		"    }",
		"",
		"    // 检查是否包含K3,3的细分",
		"    bool has_k33_subdivision() {",
		"        // 检查是否包含K3,3的细分",
		"        if (n < 6) return false;",
		"",
		"        function<bool(vector<int>&, vector<int>&, int, int, int, int)> check_k33;",
		"        check_k33 =",
		"            [&](vector<int>& part1, vector<int>& part2, int start1, int count1, int start2, int count2) -> bool {",
		"            if (count1 == 3 && count2 == 3) {",
		"                // 检查是否形成K3,3的细分",
		"                for (int i = 0; i < 3; i++) {",
		"                    for (int j = 0; j < 3; j++) {",
		"                        vector<int> forbidden = part1;",
		"                        forbidden.insert(forbidden.end(), part2.begin(), part2.end());",
		"                        if (!has_path_subdivision(part1[i], part2[j], forbidden)) { return false; }",
		"                    }",
		"                }",
		"                return true;",
		"            }",
		"",
		"            if (count1 < 3) {",
		"                for (int i = start1; i < n; i++) {",
		"                    part1[count1] = i;",
		"                    if (check_k33(part1, part2, i + 1, count1 + 1, start2, count2)) { return true; }",
		"                }",
		"            }",
		"",
		"            if (count2 < 3) {",
		"                for (int i = start2; i < n; i++) {",
		"                    bool in_part1 = false;",
		"                    for (int j = 0; j < count1; j++) {",
		"                        if (part1[j] == i) {",
		"                            in_part1 = true;",
		"                            break;",
		"                        }",
		"                    }",
		"                    if (!in_part1) {",
		"                        part2[count2] = i;",
		"                        if (check_k33(part1, part2, start1, count1, i + 1, count2 + 1)) { return true; }",
		"                    }",
		"                }",
		"            }",
		"",
		"            return false;",
		"        };",
		"",
		"        vector<int> part1(3), part2(3);",
		"        return check_k33(part1, part2, 0, 0, 0, 0);",
		"    }",
		"",
		"    // 辅助函数：检查两点间是否有路径细分",
		"    bool has_path_subdivision(int start, int end, const vector<int>& forbidden) {",
		"        vector<bool> visited(n, false);",
		"        for (int v : forbidden) {",
		"            if (v != start && v != end) visited[v] = true;",
		"        }",
		"",
		"        queue<int> q;",
		"        q.push(start);",
		"        visited[start] = true;",
		"",
		"        while (!q.empty()) {",
		"            int u = q.front();",
		"            q.pop();",
		"",
		"            if (u == end) return true;",
		"",
		"            for (int v : graph[u]) {",
		"                if (!visited[v]) {",
		"                    visited[v] = true;",
		"                    q.push(v);",
		"                }",
		"            }",
		"        }",
		"",
		"        return false;",
		"    }",
		"",
		"    // 基于Kuratowski定理的平面性测试",
		"    // 时间复杂度：指数级，仅适用于小规模图",
		"    bool is_planar_kuratowski() { return !has_k5_subdivision() && !has_k33_subdivision(); }",
		"",
		"    // 欧拉公式验证（必要条件）",
		"    // 连通平面图满足：V - E + F = 2，简单平面图：E ≤ 3V - 6",
		"    bool euler_formula_check() {",
		"        if (m == 0) return true;",
		"",
		"        // 对于连通平面图：V - E + F = 2",
		"        // 对于简单连通平面图：E <= 3V - 6",
		"        if (n >= 3 && m > 3 * n - 6) return false;",
		"",
		"        // 无三角形的平面图：E <= 2V - 4",
		"        bool has_triangle = false;",
		"        for (int u = 0; u < n; u++) {",
		"            for (int v : graph[u]) {",
		"                for (int w : graph[u]) {",
		"                    if (v != w && has_edge(v, w)) {",
		"                        has_triangle = true;",
		"                        break;",
		"                    }",
		"                }",
		"                if (has_triangle) break;",
		"            }",
		"            if (has_triangle) break;",
		"        }",
		"",
		"        if (!has_triangle && n >= 3 && m > 2 * n - 4) return false;",
		"",
		"        return true;",
		"    }",
		"",
		"    bool has_edge(int u, int v) {",
		"        for (int neighbor : graph[u]) {",
		"            if (neighbor == v) return true;",
		"        }",
		"        return false;",
		"    }",
		"",
		"    // 左右测试算法（Left-Right Planarity Test）简化版",
		"    // 线性时间平面性测试算法的简化实现",
		"    bool left_right_planarity_test() {",
		"        if (!euler_formula_check()) return false;",
		"",
		"        // 这里实现简化的左右测试",
		"        // 完整实现需要复杂的数据结构",
		"        return is_planar_kuratowski();",
		"    }",
		"",
		"    // DFS平面性测试",
		"    // 基于DFS树和反向边的平面性检测",
		"    bool dfs_planarity_test() {",
		"        vector<bool> visited(n, false);",
		"        vector<int> dfs_order;",
		"        vector<int> parent(n, -1);",
		"        vector<vector<int>> back_edges(n);",
		"",
		"        // DFS遍历",
		"        function<void(int)> dfs = [&](int u) {",
		"            visited[u] = true;",
		"            dfs_order.push_back(u);",
		"",
		"            for (int v : graph[u]) {",
		"                if (!visited[v]) {",
		"                    parent[v] = u;",
		"                    dfs(v);",
		"                } else if (parent[u] != v) {",
		"                    // 反向边",
		"                    back_edges[u].push_back(v);",
		"                }",
		"            }",
		"        };",
		"",
		"        if (n > 0) dfs(0);",
		"",
		"        // 检查反向边的平面嵌入",
		"        // 这里实现简化版本",
		"        return back_edges.size() <= n;  // 简化检查",
		"    }",
		"",
		"    // 获取图的亏格（genus）",
		"    // 亏格g：图嵌入到g-环面上的最小g值，平面图的亏格为0",
		"    int calculate_genus() {",
		"        // 根据欧拉公式：V - E + F = 2 - 2g（g为亏格）",
		"        // 对于连通图",
		"        int components = count_components();",
		"",
		"        if (components == 0) return 0;",
		"",
		"        // 简化计算，假设图是连通的",
		"        // g = (2 - V + E - F) / 2",
		"        // 对于平面图的最小嵌入，F可以通过面的计算得到",
		"",
		"        // 这里返回理论最小亏格",
		"        int max_edges_planar = max(0, 3 * n - 6);",
		"        if (m <= max_edges_planar) return 0;",
		"",
		"        return (m - max_edges_planar + 2) / 2;  // 简化估算",
		"    }",
		"",
		"    int count_components() {",
		"        vector<bool> visited(n, false);",
		"        int components = 0;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            if (!visited[i]) {",
		"                components++;",
		"                function<void(int)> dfs = [&](int u) {",
		"                    visited[u] = true;",
		"                    for (int v : graph[u]) {",
		"                        if (!visited[v]) dfs(v);",
		"                    }",
		"                };",
		"                dfs(i);",
		"            }",
		"        }",
		"",
		"        return components;",
		"    }",
		"",
		"    // 平面图的对偶图构造",
		"    // 对偶图：每个面对应一个顶点，相邻面对应的顶点相连",
		"    vector<vector<int>> construct_dual_graph() {",
		"        // 这需要知道平面嵌入的面信息",
		"        // 这里提供框架，实际实现需要更复杂的几何信息",
		"        vector<vector<int>> dual;",
		"",
		"        // 简化：假设已知面的邻接关系",
		"        // 实际需要从平面嵌入中提取面信息",
		"",
		"        return dual;",
		"    }",
		"",
		"    // 检查是否为外平面图",
		"    // 外平面图：所有顶点都在外面的平面图，不包含K4和K2,3细分",
		"    bool is_outerplanar() {",
		"        // 外平面图当且仅当不包含K4细分和K2,3细分",
		"        if (n < 4) return true;",
		"",
		"        // 检查K4细分",
		"        function<bool(vector<int>&, int, int)> check_k4;",
		"        check_k4 = [&](vector<int>& vertices, int start, int count) -> bool {",
		"            if (count == 4) {",
		"                // 检查这4个顶点是否能形成K4的细分",
		"                for (int i = 0; i < 4; i++) {",
		"                    for (int j = i + 1; j < 4; j++) {",
		"                        if (!has_path_subdivision(vertices[i], vertices[j], vertices)) { return false; }",
		"                    }",
		"                }",
		"                return true;",
		"            }",
		"",
		"            for (int i = start; i < n; i++) {",
		"                vertices[count] = i;",
		"                if (check_k4(vertices, i + 1, count + 1)) { return true; }",
		"            }",
		"            return false;",
		"        };",
		"",
		"        vector<int> vertices(4);",
		"        if (check_k4(vertices, 0, 0)) return false;",
		"",
		"        // 外平面图的边数限制：E <= 2V - 3",
		"        return m <= 2 * n - 3;",
		"    }",
		"",
		"    // 计算图的树宽上界（与平面性相关）",
		"    // 平面图的树宽最多为O(√n)",
		"    int tree_width_bound() {",
		"        // 平面图的树宽最多为sqrt(3*n)",
		"        // 这里给出理论上界",
		"        return (int)ceil(sqrt(3.0 * n));",
		"    }",
		"",
		"    // 四色定理应用（平面图4-着色）",
		"    // 根据四色定理，所有平面图都可以用4种颜色着色",
		"    bool is_four_colorable() {",
		"        // 根据四色定理，所有平面图都是4-可着色的",
		"        return is_planar_kuratowski();",
		"    }",
		"};",
		"",
		"// 使用示例：",
		"// PlanarGraph pg(n);",
		"// pg.add_edge(u, v);",
		"// bool planar = pg.is_planar_kuratowski();",
		"// bool outerplanar = pg.is_outerplanar();",
		"// int genus = pg.calculate_genus();",
	})
}),

-- 02_Graph_Theory\Tree_Algorithms\HeavyLightDecomp.h
s("02_graph_theory_tree_algorithms_heavylightdecomp_h", {
	t({
		"// 重链剖分 - 将树分解为重链和轻边，支持路径查询和子树查询",
		"// 时间复杂度：预处理 O(n)，单次查询 O(log n)",
		"// 空间复杂度：O(n)",
		"struct HeavyLightDecomp {",
		"    vector<vector<int>> tree;                         // 邻接表",
		"    vector<int> parent, depth, heavy, head, pos, sz;  // 父节点、深度、重儿子、链头、DFS序、子树大小",
		"    int n, timer;",
		"",
		"    HeavyLightDecomp(int _n) : n(_n), timer(0) {",
		"        tree.resize(n);",
		"        parent.resize(n);",
		"        depth.resize(n);",
		"        heavy.resize(n, -1);",
		"        head.resize(n);",
		"        pos.resize(n);",
		"        sz.resize(n);",
		"    }",
		"",
		"    void add_edge(int u, int v) {",
		"        tree[u].push_back(v);",
		"        tree[v].push_back(u);",
		"    }  // 第一次DFS：计算子树大小、深度、重儿子",
		"    int dfs1(int v, int p, int d) {",
		"        parent[v] = p;",
		"        depth[v] = d;",
		"        sz[v] = 1;",
		"        int max_size = 0;",
		"",
		"        for (int u : tree[v]) {",
		"            if (u != p) {",
		"                sz[v] += dfs1(u, v, d + 1);",
		"                if (sz[u] > max_size) {",
		"                    max_size = sz[u];",
		"                    heavy[v] = u;  // 子树最大的儿子作为重儿子",
		"                }",
		"            }",
		"        }",
		"",
		"        return sz[v];",
		"    }",
		"",
		"    // 第二次DFS：构建重链，分配DFS序",
		"    void dfs2(int v, int h) {",
		"        head[v] = h;       // 链头",
		"        pos[v] = timer++;  // DFS序",
		"",
		"        if (heavy[v] != -1) {",
		"            dfs2(heavy[v], h);  // 重儿子继续在同一条重链",
		"        }",
		"",
		"        for (int u : tree[v]) {",
		"            if (u != parent[v] && u != heavy[v]) {",
		"                dfs2(u, u);  // 轻儿子开始新的重链",
		"            }",
		"        }",
		"    }",
		"",
		"    void build(int root = 0) {",
		"        dfs1(root, -1, 0);",
		"        dfs2(root, root);",
		"    }  // 查询LCA（最近公共祖先）",
		"    int lca(int u, int v) {",
		"        while (head[u] != head[v]) {",
		"            if (depth[head[u]] > depth[head[v]]) {",
		"                u = parent[head[u]];",
		"            } else {",
		"                v = parent[head[v]];",
		"            }",
		"        }",
		"        return depth[u] < depth[v] ? u : v;",
		"    }",
		"",
		"    // 查询路径上的区间（用于配合线段树等数据结构）",
		"    vector<pair<int, int>> query_path(int u, int v) {",
		"        vector<pair<int, int>> up_path, down_path;",
		"",
		"        while (head[u] != head[v]) {",
		"            if (depth[head[u]] > depth[head[v]]) {",
		"                up_path.push_back({pos[head[u]], pos[u]});",
		"                u = parent[head[u]];",
		"            } else {",
		"                down_path.push_back({pos[head[v]], pos[v]});",
		"                v = parent[head[v]];",
		"            }",
		"        }",
		"",
		"        // 处理同一条重链上的部分",
		"        if (u != v) {",
		"            if (depth[u] > depth[v]) {",
		"                up_path.push_back({pos[v], pos[u]});",
		"            } else {",
		"                down_path.push_back({pos[u], pos[v]});",
		"            }",
		"        } else {",
		"            up_path.push_back({pos[u], pos[u]});",
		"        }",
		"",
		"        // 合并路径，注意down_path需要反向",
		"        reverse(down_path.begin(), down_path.end());",
		"        up_path.insert(up_path.end(), down_path.begin(), down_path.end());",
		"",
		"        return up_path;",
		"    }",
		"",
		"    // 查询子树对应的区间",
		"    pair<int, int> query_subtree(int v) { return {pos[v], pos[v] + sz[v] - 1}; }",
		"",
		"    // 查询两点间距离",
		"    int distance(int u, int v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
		"",
		"    // 判断u是否是v的祖先",
		"    bool is_ancestor(int u, int v) { return pos[u] <= pos[v] && pos[v] < pos[u] + sz[u]; }",
		"};",
	})
}),

-- 02_Graph_Theory\Tree_Algorithms\LCA_Binary.h
s("02_graph_theory_tree_algorithms_lca_binary_h", {
	t({
		"// LCA（最近公共祖先）倍增算法",
		"// 时间复杂度：预处理 O(n log n)，单次查询 O(log n)",
		"// 空间复杂度：O(n log n)",
		"struct LCA_Binary {",
		"    int n, LOG;",
		"    vector<vector<int>> up;  // up[i][j] 表示从节点 i 向上跳 2^j 步到达的节点",
		"    vector<int> depth;",
		"    vector<vector<int>> adj;",
		"",
		"    LCA_Binary(int _n) : n(_n) {",
		"        LOG = 0;",
		"        while ((1 << LOG) <= n) LOG++;",
		"        up.assign(n, vector<int>(LOG, -1));",
		"        depth.assign(n, 0);",
		"        adj.assign(n, vector<int>());",
		"    }",
		"",
		"    void add_edge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"    void dfs(int v, int p) {",
		"        up[v][0] = p;",
		"        // 预处理倍增数组",
		"        for (int i = 1; i < LOG; i++) {",
		"            if (up[v][i - 1] != -1) { up[v][i] = up[up[v][i - 1]][i - 1]; }",
		"        }",
		"",
		"        for (int u : adj[v]) {",
		"            if (u != p) {",
		"                depth[u] = depth[v] + 1;",
		"                dfs(u, v);",
		"            }",
		"        }",
		"    }",
		"",
		"    void preprocess(int root = 0) {",
		"        depth[root] = 0;",
		"        dfs(root, -1);",
		"    }",
		"",
		"    int lca(int u, int v) {",
		"        if (depth[u] < depth[v]) swap(u, v);",
		"",
		"        // 将u提升到与v相同的深度",
		"        int diff = depth[u] - depth[v];",
		"        for (int i = 0; i < LOG; i++) {",
		"            if ((diff >> i) & 1) { u = up[u][i]; }",
		"        }",
		"",
		"        if (u == v) return u;",
		"",
		"        // 二分查找LCA",
		"        for (int i = LOG - 1; i >= 0; i--) {",
		"            if (up[u][i] != up[v][i]) {",
		"                u = up[u][i];",
		"                v = up[v][i];",
		"            }",
		"        }",
		"",
		"        return up[u][0];",
		"    }",
		"",
		"    int distance(int u, int v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
		"",
		"    // 从u向上走k步（k步祖先）",
		"    int kth_ancestor(int u, int k) {",
		"        if (depth[u] < k) return -1;",
		"",
		"        for (int i = 0; i < LOG; i++) {",
		"            if ((k >> i) & 1) {",
		"                u = up[u][i];",
		"                if (u == -1) return -1;",
		"            }",
		"        }",
		"        return u;",
		"    }",
		"",
		"    // 路径上u到v的第k个节点（0-indexed）",
		"    int kth_node_on_path(int u, int v, int k) {",
		"        int l = lca(u, v);",
		"        int dist_u = depth[u] - depth[l];",
		"        int dist_v = depth[v] - depth[l];",
		"",
		"        if (k <= dist_u) {",
		"            return kth_ancestor(u, k);",
		"        } else {",
		"            return kth_ancestor(v, dist_u + dist_v - k);",
		"        }",
		"    }",
		"};",
	})
}),

-- 02_Graph_Theory\Tree_Algorithms\LCA_Tarjan.h
s("02_graph_theory_tree_algorithms_lca_tarjan_h", {
	t({
		"// Tarjan离线LCA算法",
		"// 时间复杂度：O(n + m α(n))，其中m为查询次数，α为反阿克曼函数",
		"// 空间复杂度：O(n + m)",
		"// 适用于需要批量处理大量LCA查询的场景",
		"struct LCA_Tarjan {",
		"    struct Query {",
		"        int v, id;  // 查询节点和查询编号",
		"    };",
		"",
		"    vector<vector<int>> adj;",
		"    vector<vector<Query>> queries;  // 每个节点的查询列表",
		"    vector<int> parent, ancestor;   // 并查集的父节点和祖先",
		"    vector<bool> visited;",
		"    vector<int> result;  // 查询结果",
		"    int n;",
		"",
		"    LCA_Tarjan(int _n) : n(_n) {",
		"        adj.resize(n);",
		"        queries.resize(n);",
		"        parent.resize(n);",
		"        ancestor.resize(n);",
		"        visited.resize(n, false);",
		"        iota(parent.begin(), parent.end(), 0);",
		"        iota(ancestor.begin(), ancestor.end(), 0);",
		"    }",
		"",
		"    void add_edge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"    void add_query(int u, int v, int id) {",
		"        queries[u].push_back({v, id});",
		"        queries[v].push_back({u, id});",
		"    }",
		"",
		"    int find(int x) { return parent[x] == x ? x : parent[x] = find(parent[x]); }",
		"",
		"    void unite(int x, int y) {",
		"        x = find(x), y = find(y);",
		"        if (x != y) { parent[y] = x; }",
		"    }",
		"",
		"    void dfs(int u, int p) {",
		"        ancestor[u] = u;",
		"",
		"        // 访问所有子节点",
		"        for (int v : adj[u]) {",
		"            if (v != p) {",
		"                dfs(v, u);",
		"                unite(u, v);",
		"                ancestor[find(u)] = u;  // 更新祖先",
		"            }",
		"        }",
		"",
		"        visited[u] = true;",
		"",
		"        // 处理与已访问节点的查询",
		"        for (const Query& q : queries[u]) {",
		"            if (visited[q.v]) { result[q.id] = ancestor[find(q.v)]; }",
		"        }",
		"    }",
		"",
		"    vector<int> solve(int root, int num_queries) {",
		"        result.resize(num_queries);",
		"        dfs(root, -1);",
		"        return result;",
		"    }",
		"};",
		"",
		"// 重链剖分LCA（重复实现，用于对比）",
		"// 时间复杂度：预处理 O(n)，单次查询 O(log n)",
		"// 空间复杂度：O(n)",
		"struct HeavyLightDecomposition {",
		"    vector<vector<int>> adj;",
		"    vector<int> parent, depth, heavy, head, pos, size;",
		"    int n, timer;",
		"",
		"    HeavyLightDecomposition(int _n) : n(_n), timer(0) {",
		"        adj.resize(n);",
		"        parent.resize(n);",
		"        depth.resize(n);",
		"        heavy.resize(n, -1);",
		"        head.resize(n);",
		"        pos.resize(n);",
		"        size.resize(n);",
		"    }",
		"",
		"    void add_edge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"    int dfs_size(int v, int p) {",
		"        size[v] = 1;",
		"        parent[v] = p;",
		"",
		"        for (int u : adj[v]) {",
		"            if (u != p) {",
		"                depth[u] = depth[v] + 1;",
		"                size[v] += dfs_size(u, v);",
		"                if (heavy[v] == -1 || size[u] > size[heavy[v]]) { heavy[v] = u; }",
		"            }",
		"        }",
		"",
		"        return size[v];",
		"    }",
		"",
		"    void dfs_decompose(int v, int h) {",
		"        head[v] = h;",
		"        pos[v] = timer++;",
		"",
		"        if (heavy[v] != -1) { dfs_decompose(heavy[v], h); }",
		"",
		"        for (int u : adj[v]) {",
		"            if (u != parent[v] && u != heavy[v]) { dfs_decompose(u, u); }",
		"        }",
		"    }",
		"",
		"    void preprocess(int root = 0) {",
		"        depth[root] = 0;",
		"        dfs_size(root, -1);",
		"        dfs_decompose(root, root);",
		"    }",
		"",
		"    int lca(int u, int v) {",
		"        while (head[u] != head[v]) {",
		"            if (depth[head[u]] > depth[head[v]]) {",
		"                u = parent[head[u]];",
		"            } else {",
		"                v = parent[head[v]];",
		"            }",
		"        }",
		"        return depth[u] < depth[v] ? u : v;",
		"    }",
		"",
		"    // 获取路径分解后的区间列表",
		"    vector<pair<int, int>> get_path(int u, int v) {",
		"        vector<pair<int, int>> result;",
		"",
		"        while (head[u] != head[v]) {",
		"            if (depth[head[u]] > depth[head[v]]) {",
		"                result.push_back({pos[head[u]], pos[u]});",
		"                u = parent[head[u]];",
		"            } else {",
		"                result.push_back({pos[head[v]], pos[v]});",
		"                v = parent[head[v]];",
		"            }",
		"        }",
		"",
		"        if (depth[u] > depth[v]) swap(u, v);",
		"        result.push_back({pos[u], pos[v]});",
		"",
		"        return result;",
		"    }",
		"",
		"    int distance(int u, int v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
		"};",
	})
}),

-- 02_Graph_Theory\Tree_Algorithms\TreeChain.h
s("02_graph_theory_tree_algorithms_treechain_h", {
	t({
		"// 树链剖分模板（配合线段树使用）",
		"// 时间复杂度：预处理 O(n)，单次路径操作 O(log^2 n)，单次子树操作 O(log n)",
		"// 空间复杂度：O(n)",
		"struct TreeChain {",
		"    int n, cnt;",
		"    vector<vector<int>> adj;        // 邻接表",
		"    vector<int> fa, son, dep, siz;  // 父节点、重儿子、深度、子树大小",
		"    vector<int> top, dfn, rnk;      // 链顶、DFS序、DFS序对应的节点",
		"",
		"    TreeChain(int _n) : n(_n), cnt(0) {",
		"        adj.resize(n + 1);",
		"        fa.resize(n + 1);",
		"        son.resize(n + 1, 0);",
		"        dep.resize(n + 1, 0);",
		"        siz.resize(n + 1);",
		"        top.resize(n + 1);",
		"        dfn.resize(n + 1);",
		"        rnk.resize(n + 1);",
		"    }",
		"",
		"    void add_edge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"",
		"    // 第一次DFS：计算深度、父节点、子树大小、重儿子",
		"    void dfs1(int u, int f) {",
		"        fa[u] = f;",
		"        dep[u] = dep[f] + 1;",
		"        siz[u] = 1;",
		"",
		"        for (int v : adj[u]) {",
		"            if (v == f) continue;",
		"            dfs1(v, u);",
		"            siz[u] += siz[v];",
		"            if (siz[v] > siz[son[u]]) {",
		"                son[u] = v;  // 更新重儿子",
		"            }",
		"        }",
		"    }",
		"",
		"    // 第二次DFS：建立重链，分配DFS序",
		"    void dfs2(int u, int t) {",
		"        dfn[u] = ++cnt;  // DFS序",
		"        rnk[cnt] = u;    // DFS序对应的节点",
		"        top[u] = t;      // 链顶",
		"",
		"        if (!son[u]) return;  // 叶子节点",
		"",
		"        dfs2(son[u], t);  // 重儿子继续在同一条链",
		"",
		"        // 处理轻儿子，每个轻儿子开始新的链",
		"        for (int v : adj[u]) {",
		"            if (v != fa[u] && v != son[u]) { dfs2(v, v); }",
		"        }",
		"    }",
		"",
		"    void build(int root = 1) {",
		"        dfs1(root, 0);",
		"        dfs2(root, root);",
		"    }",
		"",
		"    // 查询LCA",
		"    int lca(int u, int v) {",
		"        while (top[u] != top[v]) {",
		"            if (dep[top[u]] >= dep[top[v]]) {",
		"                u = fa[top[u]];",
		"            } else {",
		"                v = fa[top[v]];",
		"            }",
		"        }",
		"        return (dfn[u] <= dfn[v] ? u : v);",
		"    }",
		"",
		"    // 查询两点间距离",
		"    int distance(int u, int v) { return dep[u] + dep[v] - 2 * dep[lca(u, v)]; }",
		"",
		"    // 获取路径分解后的区间（用于路径修改/查询）",
		"    vector<pair<int, int>> get_path_ranges(int u, int v) {",
		"        vector<pair<int, int>> ranges;",
		"",
		"        while (top[u] != top[v]) {",
		"            if (dep[top[u]] < dep[top[v]]) swap(u, v);",
		"            ranges.push_back({dfn[top[u]], dfn[u]});",
		"            u = fa[top[u]];",
		"        }",
		"",
		"        if (dep[u] > dep[v]) swap(u, v);",
		"        ranges.push_back({dfn[u], dfn[v]});",
		"",
		"        return ranges;",
		"    }",
		"",
		"    // 获取子树对应的区间",
		"    pair<int, int> get_subtree_range(int u) { return {dfn[u], dfn[u] + siz[u] - 1}; }",
		"",
		"    // 判断u是否为v的祖先",
		"    bool is_ancestor(int u, int v) { return dfn[u] <= dfn[v] && dfn[v] <= dfn[u] + siz[u] - 1; }",
		"",
		"    // 路径上第k个节点（从u到v，0-indexed）",
		"    int kth_on_path(int u, int v, int k) {",
		"        int l = lca(u, v);",
		"        int dist_u = dep[u] - dep[l];",
		"        int dist_v = dep[v] - dep[l];",
		"",
		"        if (k <= dist_u) {",
		"            // 在u到lca的路径上",
		"            for (int i = 0; i < k; i++) { u = fa[u]; }",
		"            return u;",
		"        } else {",
		"            // 在lca到v的路径上",
		"            k = dist_u + dist_v - k;",
		"            for (int i = 0; i < k; i++) { v = fa[v]; }",
		"            return v;",
		"        }",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Advanced\PlugDP.h
s("03_dynamic_programming_advanced_plugdp_h", {
	t({
		"/**",
		" * 插头动态规划模板",
		" * 功能：哈密顿回路、简单回路、路径覆盖、连通子图计数",
		" * 时间复杂度：O(n*m*4^m)，空间复杂度：O(4^m)",
		" */",
		"struct PlugDP {",
		"    int n, m;",
		"    map<long long, long long> dp, new_dp;",
		"    vector<vector<int>> grid;",
		"",
		"    PlugDP(int rows, int cols) : n(rows), m(cols) { grid.assign(n, vector<int>(m, 1)); }",
		"",
		"    void set_grid(const vector<vector<int>>& g) { grid = g; }  // 哈密顿回路计数",
		"    long long count_hamilton_cycles() {",
		"        dp.clear();",
		"        dp[0] = 1;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) {",
		"                new_dp.clear();",
		"                for (auto& [state, ways] : dp) {",
		"                    if (grid[i][j] == 0) {",
		"                        add_state(shift_state(state), ways);",
		"                    } else {",
		"                        process_cell(i, j, state, ways);",
		"                    }",
		"                }",
		"                dp = new_dp;",
		"            }",
		"        }",
		"        return dp.count(0) ? dp[0] : 0;",
		"    }  // 简单回路计数",
		"    long long count_simple_cycles() {",
		"        dp.clear();",
		"        dp[0] = 1;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) {",
		"                new_dp.clear();",
		"                for (auto& [state, ways] : dp) {",
		"                    if (grid[i][j] == 0) {",
		"                        add_state(shift_state(state), ways);",
		"                    } else {",
		"                        process_simple_cycle_cell(i, j, state, ways);",
		"                    }",
		"                }",
		"                dp = new_dp;",
		"            }",
		"        }",
		"        return dp.count(0) ? dp[0] : 0;",
		"    }  // 最小路径覆盖",
		"    long long min_path_cover() {",
		"        dp.clear();",
		"        dp[0] = 1;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) {",
		"                new_dp.clear();",
		"                for (auto& [state, ways] : dp) {",
		"                    if (grid[i][j] == 0) {",
		"                        add_state(shift_state(state), ways);",
		"                    } else {",
		"                        process_path_cover_cell(i, j, state, ways);",
		"                    }",
		"                }",
		"                dp = new_dp;",
		"            }",
		"        }",
		"        return dp.count(0) ? dp[0] : 0;",
		"    }",
		"",
		"   private:  // 插头操作",
		"    int get_plug(long long state, int pos) { return (state >> (pos * 2)) & 3; }",
		"    long long set_plug(long long state, int pos, int value) {",
		"        long long mask = 3LL << (pos * 2);",
		"        return (state & (~mask)) | ((long long)value << (pos * 2));",
		"    }",
		"    long long shift_state(long long state) { return state >> 2; }",
		"    void add_state(long long state, long long ways) { new_dp[state] += ways; }  // 处理哈密顿回路格子",
		"    void process_cell(int i, int j, long long state, long long ways) {",
		"        int up = get_plug(state, j), left = get_plug(state, j + 1);",
		"",
		"        if (up == 0 && left == 0) {",
		"            // 开始新路径",
		"            if (i < n - 1 && j < m - 1 && grid[i + 1][j] && grid[i][j + 1]) {",
		"                long long new_state = set_plug(state, j, 1);",
		"                new_state = set_plug(new_state, j + 1, 2);",
		"                add_state(shift_state(new_state), ways);",
		"            }",
		"        } else if (up > 0 && left == 0) {",
		"            // 延伸上插头",
		"            if (i < n - 1 && grid[i + 1][j]) {",
		"                add_state(shift_state(set_plug(set_plug(state, j, up), j + 1, 0)), ways);",
		"            }",
		"            if (j < m - 1 && grid[i][j + 1]) {",
		"                add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, up)), ways);",
		"            }",
		"        } else if (up == 0 && left > 0) {",
		"            // 延伸左插头",
		"            if (i < n - 1 && grid[i + 1][j]) {",
		"                add_state(shift_state(set_plug(set_plug(state, j, left), j + 1, 0)), ways);",
		"            }",
		"            if (j < m - 1 && grid[i][j + 1]) {",
		"                add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, left)), ways);",
		"            }",
		"        } else {",
		"            // 连接两插头",
		"            if (up == left) {",
		"                if (i == n - 1 && j == m - 1) {",
		"                    add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, 0)), ways);",
		"                }",
		"            } else {",
		"                long long new_state = set_plug(set_plug(state, j, 0), j + 1, 0);",
		"                add_state(shift_state(merge_components(new_state, up, left)), ways);",
		"            }",
		"        }",
		"    }  // 处理简单回路格子",
		"    void process_simple_cycle_cell(int i, int j, long long state, long long ways) {",
		"        int up = get_plug(state, j), left = get_plug(state, j + 1);",
		"",
		"        // 不通过此格子",
		"        add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, 0)), ways);",
		"",
		"        if (up == 0 && left == 0) {",
		"            // 开始新回路",
		"            if (can_form_cycle(i, j)) { add_state(shift_state(set_plug(set_plug(state, j, 1), j + 1, 1)), ways); }",
		"        } else if (up > 0 && left == 0) {",
		"            // 延伸上插头",
		"            if (i < n - 1) add_state(shift_state(set_plug(set_plug(state, j, up), j + 1, 0)), ways);",
		"            if (j < m - 1) add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, up)), ways);",
		"        } else if (up == 0 && left > 0) {",
		"            // 延伸左插头",
		"            if (i < n - 1) add_state(shift_state(set_plug(set_plug(state, j, left), j + 1, 0)), ways);",
		"            if (j < m - 1) add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, left)), ways);",
		"        } else if (up == left) {",
		"            // 闭合回路",
		"            add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, 0)), ways);",
		"        }",
		"    }  // 处理路径覆盖格子",
		"    void process_path_cover_cell(int i, int j, long long state, long long ways) {",
		"        int up = get_plug(state, j), left = get_plug(state, j + 1);",
		"",
		"        // 不覆盖此格子",
		"        add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, 0)), ways);",
		"",
		"        if (up == 0 && left == 0) {",
		"            // 开始新路径",
		"            add_state(shift_state(set_plug(set_plug(state, j, 1), j + 1, 2)), ways);",
		"        } else if (up > 0 && left == 0) {",
		"            // 延伸上插头",
		"            add_state(shift_state(set_plug(set_plug(state, j, up), j + 1, 0)), ways);",
		"            add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, up)), ways);",
		"            // 终止路径",
		"            add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, 0)), ways);",
		"        } else if (up == 0 && left > 0) {",
		"            // 延伸左插头",
		"            add_state(shift_state(set_plug(set_plug(state, j, left), j + 1, 0)), ways);",
		"            add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, left)), ways);",
		"            // 终止路径",
		"            add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, 0)), ways);",
		"        } else {",
		"            // 连接两插头",
		"            add_state(shift_state(merge_components(set_plug(set_plug(state, j, 0), j + 1, 0), up, left)), ways);",
		"        }",
		"    }  // 合并连通分量",
		"    long long merge_components(long long state, int comp1, int comp2) {",
		"        if (comp1 == comp2) return state;",
		"        for (int i = 0; i <= m; i++) {",
		"            if (get_plug(state, i) == comp2) { state = set_plug(state, i, comp1); }",
		"        }",
		"        return state;",
		"    }",
		"",
		"    // 检查能否形成回路",
		"    bool can_form_cycle(int i, int j) { return i < n - 1 && j < m - 1 && grid[i + 1][j] && grid[i][j + 1]; }",
		"",
		"   public:",
		"    // 连通子图计数",
		"    long long count_connected_subgraphs() {",
		"        dp.clear();",
		"        dp[0] = 1;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) {",
		"                new_dp.clear();",
		"                for (auto& [state, ways] : dp) {",
		"                    add_state(shift_state(state), ways);",
		"                    if (grid[i][j] == 1) { process_connected_subgraph_cell(i, j, state, ways); }",
		"                }",
		"                dp = new_dp;",
		"            }",
		"        }",
		"",
		"        long long result = 0;",
		"        for (auto& [state, ways] : dp) result += ways;",
		"        return result - 1;  // 减去空集",
		"    }",
		"    void clear() {",
		"        dp.clear();",
		"        new_dp.clear();",
		"    }",
		"",
		"   private:",
		"    void process_connected_subgraph_cell(int i, int j, long long state, long long ways) {",
		"        int up = get_plug(state, j), left = get_plug(state, j + 1);",
		"",
		"        if (up == 0 && left == 0) {",
		"            // 开始新连通分量",
		"            int max_id = 0;",
		"            for (int k = 0; k <= m; k++) max_id = max(max_id, get_plug(state, k));",
		"            int new_id = max_id + 1;",
		"            long long new_state = state;",
		"            if (i < n - 1 && grid[i + 1][j]) new_state = set_plug(new_state, j, new_id);",
		"            if (j < m - 1 && grid[i][j + 1]) new_state = set_plug(new_state, j + 1, new_id);",
		"            add_state(shift_state(new_state), ways);",
		"        } else if (up > 0 && left == 0) {",
		"            add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, up)), ways);",
		"        } else if (up == 0 && left > 0) {",
		"            add_state(shift_state(set_plug(set_plug(state, j, left), j + 1, 0)), ways);",
		"        } else if (up == left) {",
		"            add_state(shift_state(set_plug(set_plug(state, j, 0), j + 1, 0)), ways);",
		"        } else {",
		"            add_state(shift_state(merge_components(set_plug(set_plug(state, j, 0), j + 1, 0), up, left)), ways);",
		"        }",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Advanced\ProfileDP.h
s("03_dynamic_programming_advanced_profiledp_h", {
	t({
		"/**",
		" * 轮廓线动态规划模板",
		" * 功能：棋盘填充、哈密顿路径、独立集、着色等问题",
		" * 时间复杂度：O(n*2^m)，空间复杂度：O(2^m)",
		" */",
		"struct ProfileDP {",
		"    int n, m, max_mask;",
		"    vector<vector<long long>> dp, new_dp;",
		"",
		"    ProfileDP(int rows, int cols) : n(rows), m(cols), max_mask(1 << cols) {",
		"        dp.assign(n + 1, vector<long long>(max_mask, 0));",
		"        new_dp.assign(n + 1, vector<long long>(max_mask, 0));",
		"    }  // 棋盘填充（1x2和2x1骨牌）",
		"    long long count_tilings() {",
		"        dp[0][0] = 1;",
		"        for (int i = 0; i < n; i++) {",
		"            for (int mask = 0; mask < max_mask; mask++) new_dp[i + 1][mask] = 0;",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                if (dp[i][mask] == 0) continue;",
		"                fill_row(i, 0, mask, 0, dp[i][mask]);",
		"            }",
		"            for (int mask = 0; mask < max_mask; mask++) dp[i + 1][mask] = new_dp[i + 1][mask];",
		"        }",
		"        return dp[n][0];",
		"    }  // 递归填充行",
		"    void fill_row(int row, int col, int cur_mask, int next_mask, long long ways) {",
		"        if (col == m) {",
		"            new_dp[row + 1][next_mask] += ways;",
		"            return;",
		"        }",
		"        if (cur_mask & (1 << col)) {",
		"            // 被上方竖直骨牌占据",
		"            fill_row(row, col + 1, cur_mask, next_mask, ways);",
		"        } else {",
		"            // 放竖直骨牌",
		"            fill_row(row, col + 1, cur_mask, next_mask | (1 << col), ways);",
		"            // 放水平骨牌",
		"            if (col + 1 < m && !(cur_mask & (1 << (col + 1)))) { fill_row(row, col + 2, cur_mask, next_mask, ways); }",
		"        }",
		"    }  // 带障碍的棋盘填充",
		"    long long count_tilings_with_obstacles(const vector<vector<bool>>& blocked) {",
		"        dp[0][0] = 1;",
		"        for (int i = 0; i < n; i++) {",
		"            for (int mask = 0; mask < max_mask; mask++) new_dp[i + 1][mask] = 0;",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                if (dp[i][mask] == 0) continue;",
		"                fill_row_with_obstacles(i, 0, mask, 0, dp[i][mask], blocked);",
		"            }",
		"            for (int mask = 0; mask < max_mask; mask++) dp[i + 1][mask] = new_dp[i + 1][mask];",
		"        }",
		"        return dp[n][0];",
		"    }",
		"    void fill_row_with_obstacles(",
		"        int row, int col, int cur_mask, int next_mask, long long ways, const vector<vector<bool>>& blocked) {",
		"        if (col == m) {",
		"            new_dp[row + 1][next_mask] += ways;",
		"            return;",
		"        }",
		"        if (blocked[row][col]) {",
		"            fill_row_with_obstacles(row, col + 1, cur_mask, next_mask, ways, blocked);",
		"        } else if (cur_mask & (1 << col)) {",
		"            fill_row_with_obstacles(row, col + 1, cur_mask, next_mask, ways, blocked);",
		"        } else {",
		"            // 放竖直骨牌",
		"            if (row + 1 < n && !blocked[row + 1][col]) {",
		"                fill_row_with_obstacles(row, col + 1, cur_mask, next_mask | (1 << col), ways, blocked);",
		"            }",
		"            // 放水平骨牌",
		"            if (col + 1 < m && !blocked[row][col + 1] && !(cur_mask & (1 << (col + 1)))) {",
		"                fill_row_with_obstacles(row, col + 2, cur_mask, next_mask, ways, blocked);",
		"            }",
		"        }",
		"    }  // 最大独立集",
		"    long long max_independent_set() {",
		"        vector<vector<long long>> indep_dp(n + 1, vector<long long>(max_mask, 0));",
		"        indep_dp[0][0] = 1;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int mask = 0; mask < max_mask; mask++) new_dp[i + 1][mask] = 0;",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                if (indep_dp[i][mask] == 0) continue;",
		"                generate_independent_sets(i, 0, mask, 0, indep_dp[i][mask]);",
		"            }",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                indep_dp[i + 1][mask] = max(indep_dp[i + 1][mask], new_dp[i + 1][mask]);",
		"            }",
		"        }",
		"        return *max_element(indep_dp[n].begin(), indep_dp[n].end());",
		"    }",
		"",
		"    void generate_independent_sets(int row, int col, int prev_mask, int cur_mask, long long value) {",
		"        if (col == m) {",
		"            new_dp[row + 1][cur_mask] = max(new_dp[row + 1][cur_mask], value);",
		"            return;",
		"        }",
		"        // 不选当前位置",
		"        generate_independent_sets(row, col + 1, prev_mask, cur_mask, value);",
		"        // 选当前位置",
		"        bool can_select = !(prev_mask & (1 << col)) && (col == 0 || !(cur_mask & (1 << (col - 1))));",
		"        if (can_select) { generate_independent_sets(row, col + 1, prev_mask, cur_mask | (1 << col), value + 1); }",
		"    }",
		"",
		"    void clear() {",
		"        for (int i = 0; i <= n; i++) {",
		"            fill(dp[i].begin(), dp[i].end(), 0);",
		"            fill(new_dp[i].begin(), new_dp[i].end(), 0);",
		"        }",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Advanced\SOS_DP.h
s("03_dynamic_programming_advanced_sos_dp_h", {
	t({
		"/**",
		" * SOS动态规划模板",
		" * 功能：子集和、超集和、集合卷积、最大权重独立集",
		" * 时间复杂度：O(n*2^n)，空间复杂度：O(2^n)",
		" */",
		"struct SOS_DP {",
		"    int n, max_mask;",
		"    vector<long long> dp, original;",
		"",
		"    SOS_DP(int bits) : n(bits), max_mask(1 << bits) {",
		"        dp.resize(max_mask, 0);",
		"        original.resize(max_mask, 0);",
		"    }",
		"",
		"    void set_value(int mask, long long value) {",
		"        original[mask] = value;",
		"        dp[mask] = value;",
		"    }  // 计算子集和",
		"    void compute_subset_sum() {",
		"        dp = original;",
		"        for (int i = 0; i < n; i++) {",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                if (mask & (1 << i)) { dp[mask] += dp[mask ^ (1 << i)]; }",
		"            }",
		"        }",
		"    }",
		"",
		"    // 计算超集和",
		"    void compute_superset_sum() {",
		"        dp = original;",
		"        for (int i = 0; i < n; i++) {",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                if (!(mask & (1 << i))) { dp[mask] += dp[mask | (1 << i)]; }",
		"            }",
		"        }",
		"    }  // 集合卷积",
		"    vector<long long> subset_convolution(const vector<long long>& a, const vector<long long>& b) {",
		"        vector<vector<long long>> fa(n + 1, vector<long long>(max_mask, 0));",
		"        vector<vector<long long>> fb(n + 1, vector<long long>(max_mask, 0));",
		"",
		"        for (int mask = 0; mask < max_mask; mask++) {",
		"            int pc = __builtin_popcount(mask);",
		"            fa[pc][mask] = a[mask];",
		"            fb[pc][mask] = b[mask];",
		"        }",
		"",
		"        for (int i = 0; i <= n; i++) {",
		"            for (int j = 0; j < n; j++) {",
		"                for (int mask = 0; mask < max_mask; mask++) {",
		"                    if (mask & (1 << j)) {",
		"                        fa[i][mask] += fa[i][mask ^ (1 << j)];",
		"                        fb[i][mask] += fb[i][mask ^ (1 << j)];",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        vector<vector<long long>> fh(n + 1, vector<long long>(max_mask, 0));",
		"        for (int i = 0; i <= n; i++) {",
		"            for (int j = 0; j <= i; j++) {",
		"                for (int mask = 0; mask < max_mask; mask++) { fh[i][mask] += fa[j][mask] * fb[i - j][mask]; }",
		"            }",
		"        }",
		"",
		"        for (int i = 0; i <= n; i++) {",
		"            for (int j = 0; j < n; j++) {",
		"                for (int mask = 0; mask < max_mask; mask++) {",
		"                    if (mask & (1 << j)) { fh[i][mask] -= fh[i][mask ^ (1 << j)]; }",
		"                }",
		"            }",
		"        }",
		"",
		"        vector<long long> result(max_mask);",
		"        for (int mask = 0; mask < max_mask; mask++) { result[mask] = fh[__builtin_popcount(mask)][mask]; }",
		"        return result;",
		"    }  // 枚举子集",
		"    void enumerate_subsets(int mask, function<void(int)> callback) {",
		"        for (int submask = mask;; submask = (submask - 1) & mask) {",
		"            callback(submask);",
		"            if (submask == 0) break;",
		"        }",
		"    }",
		"",
		"    // 计算交集为空的集合对数量",
		"    long long count_disjoint_pairs() {",
		"        vector<long long> cnt(max_mask, 0);",
		"        for (int mask = 0; mask < max_mask; mask++) cnt[mask] = original[mask];",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                if (mask & (1 << i)) cnt[mask] += cnt[mask ^ (1 << i)];",
		"            }",
		"        }",
		"",
		"        long long result = 0;",
		"        for (int mask = 0; mask < max_mask; mask++) {",
		"            int complement = ((1 << n) - 1) ^ mask;",
		"            result += original[mask] * cnt[complement];",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 最大权重独立集",
		"    long long max_weight_independent_set() {",
		"        dp = original;",
		"        for (int i = 0; i < n; i++) {",
		"            for (int mask = 0; mask < max_mask; mask++) {",
		"                if (mask & (1 << i)) { dp[mask] = max(dp[mask], dp[mask ^ (1 << i)]); }",
		"            }",
		"        }",
		"        return dp[max_mask - 1];",
		"    }",
		"",
		"    vector<long long> get_result() { return dp; }",
		"    long long get_result(int mask) { return dp[mask]; }",
		"    void clear() {",
		"        fill(dp.begin(), dp.end(), 0);",
		"        fill(original.begin(), original.end(), 0);",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Classical\EditDistance.h
s("03_dynamic_programming_classical_editdistance_h", {
	t({
		"/**",
		" * 编辑距离算法模板",
		" * 功能：基础编辑距离、带权重、空间优化、K编辑距离",
		" * 时间复杂度：O(nm)，空间复杂度：O(nm)或O(min(n,m))",
		" */",
		"",
		"// 基础编辑距离",
		"template <typename T>",
		"struct EditDistance {",
		"    vector<vector<int>> dp;",
		"    int n, m;",
		"",
		"    int solve(const T& s1, const T& s2) {",
		"        n = s1.size(), m = s2.size();",
		"        dp.assign(n + 1, vector<int>(m + 1, 0));",
		"",
		"        for (int i = 0; i <= n; i++) dp[i][0] = i;",
		"        for (int j = 0; j <= m; j++) dp[0][j] = j;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= m; j++) {",
		"                if (s1[i - 1] == s2[j - 1]) {",
		"                    dp[i][j] = dp[i - 1][j - 1];",
		"                } else {",
		"                    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;",
		"                }",
		"            }",
		"        }",
		"        return dp[n][m];",
		"    }",
		"",
		"    // 获取编辑操作序列",
		"    vector<string> getOperations(const string& s1, const string& s2) {",
		"        solve(s1, s2);",
		"        vector<string> ops;",
		"        int i = n, j = m;",
		"",
		"        while (i > 0 || j > 0) {",
		"            if (i > 0 && j > 0 && s1[i - 1] == s2[j - 1]) {",
		"                i--, j--;",
		"            } else if (i > 0 && j > 0 && dp[i][j] == dp[i - 1][j - 1] + 1) {",
		"                ops.push_back(\"Replace \" + string(1, s1[i - 1]) + \" with \" + string(1, s2[j - 1]));",
		"                i--, j--;",
		"            } else if (i > 0 && dp[i][j] == dp[i - 1][j] + 1) {",
		"                ops.push_back(\"Delete \" + string(1, s1[i - 1]));",
		"                i--;",
		"            } else {",
		"                ops.push_back(\"Insert \" + string(1, s2[j - 1]));",
		"                j--;",
		"            }",
		"        }",
		"        reverse(ops.begin(), ops.end());",
		"        return ops;",
		"    }",
		"};",
		"",
		"// 带权重的编辑距离",
		"template <typename T>",
		"struct WeightedEditDistance {",
		"    vector<vector<int>> dp;",
		"    int insert_cost, delete_cost, replace_cost;",
		"",
		"    WeightedEditDistance(int ins = 1, int del = 1, int rep = 1)",
		"        : insert_cost(ins), delete_cost(del), replace_cost(rep) {}",
		"",
		"    int solve(const T& s1, const T& s2) {",
		"        int n = s1.size(), m = s2.size();",
		"        dp.assign(n + 1, vector<int>(m + 1, 0));",
		"",
		"        for (int i = 0; i <= n; i++) dp[i][0] = i * delete_cost;",
		"        for (int j = 0; j <= m; j++) dp[0][j] = j * insert_cost;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= m; j++) {",
		"                if (s1[i - 1] == s2[j - 1]) {",
		"                    dp[i][j] = dp[i - 1][j - 1];",
		"                } else {",
		"                    dp[i][j] =",
		"                        min({dp[i - 1][j] + delete_cost, dp[i][j - 1] + insert_cost, dp[i - 1][j - 1] + replace_cost});",
		"                }",
		"            }",
		"        }",
		"        return dp[n][m];",
		"    }",
		"};",
		"",
		"// 空间优化版本",
		"template <typename T>",
		"int editDistanceOptimized(const T& s1, const T& s2) {",
		"    int n = s1.size(), m = s2.size();",
		"    vector<int> prev(m + 1), curr(m + 1);",
		"",
		"    for (int j = 0; j <= m; j++) prev[j] = j;",
		"",
		"    for (int i = 1; i <= n; i++) {",
		"        curr[0] = i;",
		"        for (int j = 1; j <= m; j++) {",
		"            if (s1[i - 1] == s2[j - 1]) {",
		"                curr[j] = prev[j - 1];",
		"            } else {",
		"                curr[j] = min({prev[j], curr[j - 1], prev[j - 1]}) + 1;",
		"            }",
		"        }",
		"        swap(prev, curr);",
		"    }",
		"    return prev[m];",
		"}",
		"",
		"// K编辑距离",
		"template <typename T>",
		"bool canTransformWithKEdits(const T& s1, const T& s2, int k) {",
		"    int n = s1.size(), m = s2.size();",
		"    if (abs(n - m) > k) return false;",
		"",
		"    vector<vector<int>> dp(n + 1, vector<int>(m + 1, k + 1));",
		"    dp[0][0] = 0;",
		"",
		"    for (int i = 0; i <= n; i++) {",
		"        for (int j = 0; j <= m; j++) {",
		"            if (i == 0 && j == 0) continue;",
		"            if (i > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);",
		"            if (j > 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);",
		"            if (i > 0 && j > 0) {",
		"                int cost = (s1[i - 1] == s2[j - 1]) ? 0 : 1;",
		"                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + cost);",
		"            }",
		"        }",
		"    }",
		"    return dp[n][m] <= k;",
		"}",
	})
}),

-- 03_Dynamic_Programming\Classical\Knapsack.h
s("03_dynamic_programming_classical_knapsack_h", {
	t({
		"// 背包问题模板集合",
		"using ll = long long;",
		"",
		"// 0-1背包问题 - 每个物品只能选择一次",
		"struct ZeroOneKnapsack {",
		"    vector<int> weights, values;",
		"    int n, W;",
		"",
		"    ZeroOneKnapsack(int n, int W) : n(n), W(W), weights(n), values(n) {}",
		"",
		"    void addItem(int idx, int weight, int value) {",
		"        weights[idx] = weight;",
		"        values[idx] = value;",
		"    }",
		"",
		"    // 空间优化版本 O(nW) 时间, O(W) 空间",
		"    int solve() {",
		"        vector<int> dp(W + 1, 0);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int w = W; w >= weights[i]; w--) { dp[w] = max(dp[w], dp[w - weights[i]] + values[i]); }",
		"        }",
		"        return dp[W];",
		"    }",
		"};",
		"// 完全背包问题 - 每个物品可以选择无限次",
		"struct CompleteKnapsack {",
		"    vector<int> weights, values;",
		"    int n, W;",
		"",
		"    CompleteKnapsack(int n, int W) : n(n), W(W), weights(n), values(n) {}",
		"",
		"    void addItem(int idx, int weight, int value) {",
		"        weights[idx] = weight;",
		"        values[idx] = value;",
		"    }",
		"",
		"    int solve() {",
		"        vector<int> dp(W + 1, 0);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int w = weights[i]; w <= W; w++) { dp[w] = max(dp[w], dp[w - weights[i]] + values[i]); }",
		"        }",
		"        return dp[W];",
		"    }",
		"};",
		"",
		"// 多重背包问题 - 每个物品有数量限制",
		"struct MultipleKnapsack {",
		"    vector<int> weights, values, counts;",
		"    int n, W;",
		"",
		"    MultipleKnapsack(int n, int W) : n(n), W(W), weights(n), values(n), counts(n) {}",
		"",
		"    void addItem(int idx, int weight, int value, int count) {",
		"        weights[idx] = weight;",
		"        values[idx] = value;",
		"        counts[idx] = count;",
		"    }",
		"",
		"    // 二进制优化版本 O(n*log(count)*W)",
		"    int solve() {",
		"        vector<pair<int, int>> items;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            int cnt = counts[i], k = 1;",
		"            while (k <= cnt) {",
		"                items.emplace_back(k * weights[i], k * values[i]);",
		"                cnt -= k;",
		"                k *= 2;",
		"            }",
		"            if (cnt > 0) { items.emplace_back(cnt * weights[i], cnt * values[i]); }",
		"        }",
		"",
		"        vector<int> dp(W + 1, 0);",
		"        for (auto [w, v] : items) {",
		"            for (int j = W; j >= w; j--) { dp[j] = max(dp[j], dp[j - w] + v); }",
		"        }",
		"        return dp[W];",
		"    }",
		"};",
		"// 分组背包问题 - 每个组只能选择一个物品",
		"struct GroupKnapsack {",
		"    vector<vector<pair<int, int>>> groups;  // {weight, value}",
		"    int W;",
		"",
		"    GroupKnapsack(int W) : W(W) {}",
		"",
		"    void addGroup(const vector<pair<int, int>>& items) { groups.push_back(items); }",
		"",
		"    int solve() {",
		"        vector<int> dp(W + 1, 0);",
		"        for (auto& group : groups) {",
		"            for (int w = W; w >= 0; w--) {",
		"                for (auto [weight, value] : group) {",
		"                    if (w >= weight) { dp[w] = max(dp[w], dp[w - weight] + value); }",
		"                }",
		"            }",
		"        }",
		"        return dp[W];",
		"    }",
		"};",
		"",
		"// 二维背包问题 - 有两个约束条件",
		"struct TwoDimensionalKnapsack {",
		"    vector<int> weights1, weights2, values;",
		"    int n, W1, W2;",
		"",
		"    TwoDimensionalKnapsack(int n, int W1, int W2) : n(n), W1(W1), W2(W2), weights1(n), weights2(n), values(n) {}",
		"",
		"    void addItem(int idx, int w1, int w2, int value) {",
		"        weights1[idx] = w1;",
		"        weights2[idx] = w2;",
		"        values[idx] = value;",
		"    }",
		"",
		"    int solve() {",
		"        vector<vector<int>> dp(W1 + 1, vector<int>(W2 + 1, 0));",
		"        for (int i = 0; i < n; i++) {",
		"            for (int w1 = W1; w1 >= weights1[i]; w1--) {",
		"                for (int w2 = W2; w2 >= weights2[i]; w2--) {",
		"                    dp[w1][w2] = max(dp[w1][w2], dp[w1 - weights1[i]][w2 - weights2[i]] + values[i]);",
		"                }",
		"            }",
		"        }",
		"        return dp[W1][W2];",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Classical\LCS.h
s("03_dynamic_programming_classical_lcs_h", {
	t({
		"// 最长公共子序列(LCS)算法集合",
		"",
		"// 基础LCS - O(nm)算法",
		"struct LCS {",
		"    string s1, s2;",
		"    int n, m;",
		"",
		"    LCS(const string& a, const string& b) : s1(a), s2(b), n(a.length()), m(b.length()) {}",
		"",
		"    int solve() {",
		"        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= m; j++) {",
		"                if (s1[i - 1] == s2[j - 1]) {",
		"                    dp[i][j] = dp[i - 1][j - 1] + 1;",
		"                } else {",
		"                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);",
		"                }",
		"            }",
		"        }",
		"        return dp[n][m];",
		"    }",
		"",
		"    string getLCS() {",
		"        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= m; j++) {",
		"                if (s1[i - 1] == s2[j - 1]) {",
		"                    dp[i][j] = dp[i - 1][j - 1] + 1;",
		"                } else {",
		"                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);",
		"                }",
		"            }",
		"        }",
		"",
		"        string result;",
		"        int i = n, j = m;",
		"        while (i > 0 && j > 0) {",
		"            if (s1[i - 1] == s2[j - 1]) {",
		"                result = s1[i - 1] + result;",
		"                i--;",
		"                j--;",
		"            } else if (dp[i - 1][j] > dp[i][j - 1]) {",
		"                i--;",
		"            } else {",
		"                j--;",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// 空间优化的LCS - O(min(n,m))空间",
		"struct LCSOptimized {",
		"    string s1, s2;",
		"    int n, m;",
		"",
		"    LCSOptimized(const string& a, const string& b) : s1(a), s2(b), n(a.length()), m(b.length()) {}",
		"",
		"    int solve() {",
		"        if (n < m) {",
		"            swap(s1, s2);",
		"            swap(n, m);",
		"        }",
		"        vector<int> prev(m + 1, 0), curr(m + 1, 0);",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= m; j++) {",
		"                if (s1[i - 1] == s2[j - 1]) {",
		"                    curr[j] = prev[j - 1] + 1;",
		"                } else {",
		"                    curr[j] = max(prev[j], curr[j - 1]);",
		"                }",
		"            }",
		"            prev = curr;",
		"        }",
		"        return curr[m];",
		"    }",
		"};",
		"",
		"// 最长公共递增子序列(LCIS)",
		"struct LCIS {",
		"    vector<int> a, b;",
		"    int n, m;",
		"",
		"    LCIS(const vector<int>& arr1, const vector<int>& arr2) : a(arr1), b(arr2), n(arr1.size()), m(arr2.size()) {}",
		"",
		"    int solve() {",
		"        vector<int> dp(m, 0);",
		"        for (int i = 0; i < n; i++) {",
		"            int cur_len = 0;",
		"            for (int j = 0; j < m; j++) {",
		"                if (a[i] == b[j] && dp[j] < cur_len + 1) { dp[j] = cur_len + 1; }",
		"                if (b[j] < a[i] && dp[j] > cur_len) { cur_len = dp[j]; }",
		"            }",
		"        }",
		"        return *max_element(dp.begin(), dp.end());",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Classical\LIS.h
s("03_dynamic_programming_classical_lis_h", {
	t({
		"/**",
		" * 最长递增子序列(LIS)算法模板",
		" * 功能：基础LIS、快速LIS、最长递减子序列",
		" * 时间复杂度：O(n^2)或O(nlogn)",
		" */",
		"",
		"// 基础LIS - O(n^2)算法",
		"struct LIS {",
		"    vector<int> arr;",
		"    int n;",
		"",
		"    LIS(const vector<int>& a) : arr(a), n(a.size()) {}",
		"",
		"    int solve() {",
		"        vector<int> dp(n, 1);",
		"        for (int i = 1; i < n; i++) {",
		"            for (int j = 0; j < i; j++) {",
		"                if (arr[j] < arr[i]) { dp[i] = max(dp[i], dp[j] + 1); }",
		"            }",
		"        }",
		"        return *max_element(dp.begin(), dp.end());",
		"    }",
		"",
		"    vector<int> getLIS() {",
		"        vector<int> dp(n, 1), pre(n, -1);",
		"        for (int i = 1; i < n; i++) {",
		"            for (int j = 0; j < i; j++) {",
		"                if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {",
		"                    dp[i] = dp[j] + 1;",
		"                    pre[i] = j;",
		"                }",
		"            }",
		"        }",
		"",
		"        int pos = max_element(dp.begin(), dp.end()) - dp.begin();",
		"        vector<int> result;",
		"        while (pos != -1) {",
		"            result.push_back(arr[pos]);",
		"            pos = pre[pos];",
		"        }",
		"        reverse(result.begin(), result.end());",
		"        return result;",
		"    }",
		"};",
		"",
		"// 优化LIS - O(nlogn)算法",
		"struct LISFast {",
		"    vector<int> arr;",
		"    int n;",
		"",
		"    LISFast(const vector<int>& a) : arr(a), n(a.size()) {}",
		"",
		"    int solve() {",
		"        vector<int> tail;",
		"        for (int i = 0; i < n; i++) {",
		"            auto it = lower_bound(tail.begin(), tail.end(), arr[i]);",
		"            if (it == tail.end()) {",
		"                tail.push_back(arr[i]);",
		"            } else {",
		"                *it = arr[i];",
		"            }",
		"        }",
		"        return tail.size();",
		"    }",
		"};",
		"",
		"// 最长递减子序列",
		"struct LDS {",
		"    vector<int> arr;",
		"    int n;",
		"",
		"    LDS(const vector<int>& a) : arr(a), n(a.size()) {}",
		"",
		"    int solve() {",
		"        vector<int> tail;",
		"        for (int i = 0; i < n; i++) {",
		"            auto it = lower_bound(tail.begin(), tail.end(), arr[i], greater<int>());",
		"            if (it == tail.end()) {",
		"                tail.push_back(arr[i]);",
		"            } else {",
		"                *it = arr[i];",
		"            }",
		"        }",
		"        return tail.size();",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Classical\MatrixChain.h
s("03_dynamic_programming_classical_matrixchain_h", {
	t({
		"using ll = long long;",
		"const ll INF = 1e18;",
		"",
		"// 基础矩阵链乘法 - 最小代价计算",
		"struct MatrixChain {",
		"    ll solve(const vector<int>& dims) {",
		"        int n = dims.size() - 1;",
		"        if (n <= 0) return 0;",
		"",
		"        vector<vector<ll>> dp(n, vector<ll>(n, 0));",
		"        for (int len = 2; len <= n; len++) {",
		"            for (int i = 0; i <= n - len; i++) {",
		"                int j = i + len - 1;",
		"                dp[i][j] = INF;",
		"                for (int k = i; k < j; k++) {",
		"                    ll cost = dp[i][k] + dp[k + 1][j] + (ll)dims[i] * dims[k + 1] * dims[j + 1];",
		"                    dp[i][j] = min(dp[i][j], cost);",
		"                }",
		"            }",
		"        }",
		"        return dp[0][n - 1];",
		"    }",
		"};",
		"",
		"// 带分割点记录的矩阵链乘法",
		"struct MatrixChainWithSplit {",
		"    vector<vector<int>> split;",
		"",
		"    ll solve(const vector<int>& dims) {",
		"        int n = dims.size() - 1;",
		"        if (n <= 0) return 0;",
		"",
		"        vector<vector<ll>> dp(n, vector<ll>(n, 0));",
		"        split.assign(n, vector<int>(n, 0));",
		"",
		"        for (int len = 2; len <= n; len++) {",
		"            for (int i = 0; i <= n - len; i++) {",
		"                int j = i + len - 1;",
		"                dp[i][j] = INF;",
		"                for (int k = i; k < j; k++) {",
		"                    ll cost = dp[i][k] + dp[k + 1][j] + (ll)dims[i] * dims[k + 1] * dims[j + 1];",
		"                    if (cost < dp[i][j]) {",
		"                        dp[i][j] = cost;",
		"                        split[i][j] = k;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return dp[0][n - 1];",
		"    }",
		"",
		"    void printOrder(int i, int j) {",
		"        if (i == j)",
		"            cout << \"A\" << i;",
		"        else {",
		"            cout << \"(\";",
		"            printOrder(i, split[i][j]);",
		"            cout << \" x \";",
		"            printOrder(split[i][j] + 1, j);",
		"            cout << \")\";",
		"        }",
		"    }",
		"};",
		"",
		"// Knuth优化版本 - O(n^3)降为实际更快的运行时间",
		"struct MatrixChainKnuth {",
		"    ll solve(const vector<int>& dims) {",
		"        int n = dims.size() - 1;",
		"        if (n <= 0) return 0;",
		"",
		"        vector<vector<ll>> dp(n, vector<ll>(n, 0));",
		"        vector<vector<int>> opt(n, vector<int>(n, 0));",
		"",
		"        for (int i = 0; i < n; i++) opt[i][i] = i;",
		"",
		"        for (int len = 2; len <= n; len++) {",
		"            for (int i = 0; i <= n - len; i++) {",
		"                int j = i + len - 1;",
		"                dp[i][j] = INF;",
		"",
		"                int left = (i + 1 <= j - 1) ? opt[i][j - 1] : i;",
		"                int right = (i + 1 <= j - 1) ? opt[i + 1][j] : j - 1;",
		"",
		"                for (int k = left; k <= right; k++) {",
		"                    ll cost = dp[i][k] + dp[k + 1][j] + (ll)dims[i] * dims[k + 1] * dims[j + 1];",
		"                    if (cost < dp[i][j]) {",
		"                        dp[i][j] = cost;",
		"                        opt[i][j] = k;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return dp[0][n - 1];",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Digit_DP\DigitDP_Template.h
s("03_dynamic_programming_digit_dp_digitdp_template_h", {
	t({
		"using ll = long long;",
		"",
		"// 基础数位DP模板",
		"struct DigitDP {",
		"    string num;",
		"    vector<vector<vector<ll>>> dp;",
		"    int len;",
		"",
		"    // dp[pos][tight][state] 表示当前位置pos，是否受限制tight，当前状态state的方案数",
		"    virtual ll dfs(int pos, bool tight, int state) {",
		"        if (pos == len) return isValid(state);",
		"",
		"        if (!tight && dp[pos][0][state] != -1) return dp[pos][0][state];",
		"",
		"        int limit = tight ? (num[pos] - '0') : 9;",
		"        ll res = 0;",
		"",
		"        for (int digit = 0; digit <= limit; digit++) {",
		"            int newState = getNextState(state, digit, pos);",
		"            bool newTight = tight && (digit == limit);",
		"            res += dfs(pos + 1, newTight, newState);",
		"        }",
		"",
		"        if (!tight) dp[pos][0][state] = res;",
		"        return res;",
		"    }",
		"",
		"    virtual bool isValid(int state) = 0;",
		"    virtual int getNextState(int state, int digit, int pos) = 0;",
		"    virtual int getInitState() = 0;",
		"    virtual int getMaxState() = 0;",
		"",
		"    ll solve(ll n) {",
		"        if (n < 0) return 0;",
		"        num = to_string(n);",
		"        len = num.size();",
		"        dp.assign(len, vector<vector<ll>>(2, vector<ll>(getMaxState() + 1, -1)));",
		"        return dfs(0, true, getInitState());",
		"    }",
		"",
		"    ll solve(ll l, ll r) { return solve(r) - solve(l - 1); }",
		"    virtual ~DigitDP() = default;",
		"};",
		"",
		"// 数字和能被K整除",
		"struct DivisibleByK : DigitDP {",
		"    int k;",
		"    DivisibleByK(int k_) : k(k_) {}",
		"    bool isValid(int state) override { return state == 0; }",
		"    int getNextState(int state, int digit, int pos) override { return (state + digit) % k; }",
		"    int getInitState() override { return 0; }",
		"    int getMaxState() override { return k - 1; }",
		"};",
		"",
		"// 不含指定数字",
		"struct WithoutDigit : DigitDP {",
		"    int forbidden;",
		"    WithoutDigit(int d) : forbidden(d) {}",
		"    bool isValid(int state) override { return state == 0; }",
		"    int getNextState(int state, int digit, int pos) override { return (digit == forbidden) ? 1 : state; }",
		"    int getInitState() override { return 0; }",
		"    int getMaxState() override { return 1; }",
		"};",
		"",
		"// 数字和等于目标值",
		"struct DigitSum : DigitDP {",
		"    int target;",
		"    DigitSum(int sum) : target(sum) {}",
		"    bool isValid(int state) override { return state == target; }",
		"    int getNextState(int state, int digit, int pos) override { return state + digit; }",
		"    int getInitState() override { return 0; }",
		"    int getMaxState() override { return target; }",
		"};",
		"",
		"// 带前导零处理的数位DP",
		"struct DigitDPWithLeadingZero {",
		"    string num;",
		"    vector<vector<vector<vector<ll>>>> dp;  // dp[pos][tight][state][hasNum]",
		"    int len, target;",
		"",
		"    DigitDPWithLeadingZero(int t) : target(t) {}",
		"",
		"    ll dfs(int pos, bool tight, int state, bool hasNum) {",
		"        if (pos == len) return hasNum && (state == target);",
		"",
		"        if (!tight && dp[pos][0][state][hasNum] != -1) return dp[pos][0][state][hasNum];",
		"",
		"        ll res = 0;",
		"",
		"        // 可以继续不选数字(前导零)",
		"        if (!hasNum) res += dfs(pos + 1, tight && (num[pos] == '0'), state, false);",
		"",
		"        // 选择数字",
		"        int start = hasNum ? 0 : 1;",
		"        int limit = tight ? (num[pos] - '0') : 9;",
		"",
		"        for (int digit = start; digit <= limit; digit++) {",
		"            int newState = state + digit;",
		"            bool newTight = tight && (digit == limit);",
		"            res += dfs(pos + 1, newTight, newState, true);",
		"        }",
		"",
		"        if (!tight) dp[pos][0][state][hasNum] = res;",
		"        return res;",
		"    }",
		"",
		"    ll solve(ll n) {",
		"        if (n < 0) return 0;",
		"        num = to_string(n);",
		"        len = num.size();",
		"        dp.assign(len, vector<vector<vector<ll>>>(2, vector<vector<ll>>(target + 1, vector<ll>(2, -1))));",
		"        return dfs(0, true, 0, false);",
		"    }",
		"",
		"    ll solve(ll l, ll r) { return solve(r) - solve(l - 1); }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Optimization\ConvexHullTrick.h
s("03_dynamic_programming_optimization_convexhulltrick_h", {
	t({
		"using ll = long long;",
		"",
		"// 凸包优化 - 斜率递减，查询点递增",
		"struct ConvexHullTrick {",
		"    struct Line {",
		"        ll k, b;",
		"        Line(ll k = 0, ll b = 0) : k(k), b(b) {}",
		"        ll eval(ll x) const { return k * x + b; }",
		"    };",
		"",
		"    deque<Line> lines;",
		"",
		"    bool bad(const Line& l1, const Line& l2, const Line& l3) {",
		"        return (l3.b - l1.b) * (l1.k - l2.k) <= (l2.b - l1.b) * (l1.k - l3.k);",
		"    }",
		"",
		"    void add(ll k, ll b) {",
		"        Line line(k, b);",
		"        while (lines.size() >= 2 && bad(lines[lines.size() - 2], lines.back(), line)) { lines.pop_back(); }",
		"        lines.push_back(line);",
		"    }",
		"",
		"    ll query(ll x) {",
		"        while (lines.size() >= 2 && lines[0].eval(x) >= lines[1].eval(x)) { lines.pop_front(); }",
		"        return lines.empty() ? 1e18 : lines[0].eval(x);",
		"    }",
		"",
		"    void clear() { lines.clear(); }",
		"};",
		"",
		"// Li Chao Tree - 动态插入直线",
		"struct LiChaoTree {",
		"    struct Line {",
		"        ll k, b;",
		"        Line(ll k = 0, ll b = 1e18) : k(k), b(b) {}",
		"        ll eval(ll x) const { return k * x + b; }",
		"    };",
		"",
		"    vector<Line> tree;",
		"    int n;",
		"    ll xmin, xmax;",
		"",
		"    LiChaoTree(ll xmin, ll xmax) : xmin(xmin), xmax(xmax) {",
		"        n = 1;",
		"        while (n < xmax - xmin + 1) n *= 2;",
		"        tree.assign(2 * n, Line());",
		"    }",
		"",
		"    void add(ll k, ll b) { add(Line(k, b), xmin, xmax, 1); }",
		"",
		"    void add(Line line, ll tl, ll tr, int v) {",
		"        ll tm = (tl + tr) / 2;",
		"        bool left = line.eval(tl) < tree[v].eval(tl);",
		"        bool mid = line.eval(tm) < tree[v].eval(tm);",
		"",
		"        if (mid) swap(tree[v], line);",
		"        if (tl == tr) return;",
		"",
		"        if (left != mid)",
		"            add(line, tl, tm, 2 * v);",
		"        else",
		"            add(line, tm + 1, tr, 2 * v + 1);",
		"    }",
		"",
		"    ll query(ll x) { return query(x, xmin, xmax, 1); }",
		"",
		"    ll query(ll x, ll tl, ll tr, int v) {",
		"        if (tl == tr) return tree[v].eval(x);",
		"        ll tm = (tl + tr) / 2;",
		"        ll res = tree[v].eval(x);",
		"        if (x <= tm)",
		"            res = min(res, query(x, tl, tm, 2 * v));",
		"        else",
		"            res = min(res, query(x, tm + 1, tr, 2 * v + 1));",
		"        return res;",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Optimization\DivideConquer.h
s("03_dynamic_programming_optimization_divideconquer_h", {
	t({
		"using ll = long long;",
		"",
		"// 分治优化DP - 决策单调性",
		"struct DivideConquerDP {",
		"    vector<vector<ll>> dp;",
		"    function<ll(int, int)> cost;",
		"",
		"    DivideConquerDP(function<ll(int, int)> f) : cost(f) {}",
		"",
		"    void compute(int layer, int l, int r, int optl, int optr) {",
		"        if (l > r) return;",
		"",
		"        int mid = (l + r) / 2;",
		"        int bestk = optl;",
		"",
		"        for (int k = optl; k <= min(mid - 1, optr); k++) {",
		"            if (dp[layer - 1][k] != 1e18) {",
		"                ll val = dp[layer - 1][k] + cost(k + 1, mid);",
		"                if (val < dp[layer][mid]) {",
		"                    dp[layer][mid] = val;",
		"                    bestk = k;",
		"                }",
		"            }",
		"        }",
		"",
		"        compute(layer, l, mid - 1, optl, bestk);",
		"        compute(layer, mid + 1, r, bestk, optr);",
		"    }",
		"",
		"    vector<ll> solve(int n, int k, const vector<ll>& base) {",
		"        dp.assign(k + 1, vector<ll>(n + 1, 1e18));",
		"",
		"        for (int i = 1; i <= n; i++) dp[1][i] = base[i - 1];",
		"",
		"        for (int layer = 2; layer <= k; layer++) {",
		"            fill(dp[layer].begin(), dp[layer].end(), 1e18);",
		"            compute(layer, layer, n, layer - 1, n - 1);",
		"        }",
		"",
		"        return dp[k];",
		"    }",
		"};",
		"",
		"// Knuth-Yao优化 - 四边形不等式",
		"struct KnuthYaoDP {",
		"    vector<vector<ll>> dp;",
		"    vector<vector<int>> opt;",
		"    function<ll(int, int)> cost;",
		"",
		"    KnuthYaoDP(function<ll(int, int)> f) : cost(f) {}",
		"",
		"    vector<vector<ll>> solve(int n) {",
		"        dp.assign(n, vector<ll>(n, 1e18));",
		"        opt.assign(n, vector<int>(n, 0));",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            dp[i][i] = 0;",
		"            opt[i][i] = i;",
		"        }",
		"",
		"        for (int len = 2; len <= n; len++) {",
		"            for (int i = 0; i <= n - len; i++) {",
		"                int j = i + len - 1;",
		"                int left = (i + 1 <= j - 1) ? opt[i][j - 1] : i;",
		"                int right = (i + 1 <= j - 1) ? opt[i + 1][j] : j - 1;",
		"",
		"                for (int k = left; k <= right; k++) {",
		"                    ll val = dp[i][k] + dp[k + 1][j] + cost(i, j);",
		"                    if (val < dp[i][j]) {",
		"                        dp[i][j] = val;",
		"                        opt[i][j] = k;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        return dp;",
		"    }",
		"};",
		"",
		"// 单调队列优化",
		"struct MonotonicQueue {",
		"    deque<pair<ll, int>> dq;",
		"",
		"    void push(ll val, int idx) {",
		"        while (!dq.empty() && dq.back().first >= val) dq.pop_back();",
		"        dq.push_back({val, idx});",
		"    }",
		"",
		"    void popWhile(function<bool(int)> shouldRemove) {",
		"        while (!dq.empty() && shouldRemove(dq.front().second)) dq.pop_front();",
		"    }",
		"",
		"    ll getMin() { return dq.empty() ? (ll)1e18 : dq.front().first; }",
		"    pair<ll, int> getMinWithIdx() { return dq.empty() ? make_pair((ll)1e18, -1) : dq.front(); }",
		"",
		"    void clear() { dq.clear(); }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Tree_DP\RerootingDP.h
s("03_dynamic_programming_tree_dp_rerootingdp_h", {
	t({
		"using ll = long long;",
		"",
		"// 换根DP通用模板",
		"template <typename T>",
		"struct RerootingDP {",
		"    vector<vector<int>> adj;",
		"    vector<T> down, up, ans;",
		"    int n;",
		"",
		"    RerootingDP(int size) : n(size) {",
		"        adj.resize(n);",
		"        down.resize(n);",
		"        up.resize(n);",
		"        ans.resize(n);",
		"    }",
		"",
		"    void addEdge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"",
		"    virtual T merge(const T& a, const T& b) = 0;",
		"    virtual T addRoot(const T& subtree, int u) = 0;",
		"    virtual T identity() = 0;",
		"",
		"    T dfs1(int u, int parent) {",
		"        down[u] = identity();",
		"        for (int v : adj[u]) {",
		"            if (v != parent) { down[u] = merge(down[u], addRoot(dfs1(v, u), v)); }",
		"        }",
		"        return down[u];",
		"    }",
		"",
		"    void dfs2(int u, int parent, const T& fromParent) {",
		"        vector<T> prefix(adj[u].size() + 1, identity());",
		"        vector<T> suffix(adj[u].size() + 1, identity());",
		"",
		"        for (int i = 0; i < adj[u].size(); i++) {",
		"            int v = adj[u][i];",
		"            if (v != parent) {",
		"                prefix[i + 1] = merge(prefix[i], addRoot(down[v], v));",
		"            } else {",
		"                prefix[i + 1] = merge(prefix[i], fromParent);",
		"            }",
		"        }",
		"",
		"        for (int i = adj[u].size() - 1; i >= 0; i--) {",
		"            int v = adj[u][i];",
		"            if (v != parent) {",
		"                suffix[i] = merge(suffix[i + 1], addRoot(down[v], v));",
		"            } else {",
		"                suffix[i] = merge(suffix[i + 1], fromParent);",
		"            }",
		"        }",
		"",
		"        ans[u] = prefix[adj[u].size()];",
		"",
		"        for (int i = 0; i < adj[u].size(); i++) {",
		"            int v = adj[u][i];",
		"            if (v != parent) {",
		"                T upValue = addRoot(merge(prefix[i], suffix[i + 1]), u);",
		"                dfs2(v, u, upValue);",
		"            }",
		"        }",
		"    }",
		"",
		"    vector<T> solve(int root = 0) {",
		"        dfs1(root, -1);",
		"        dfs2(root, -1, identity());",
		"        return ans;",
		"    }",
		"",
		"    virtual ~RerootingDP() = default;",
		"};",
		"",
		"// 子树大小和",
		"struct SubtreeSize : RerootingDP<ll> {",
		"    SubtreeSize(int n) : RerootingDP<ll>(n) {}",
		"    ll merge(const ll& a, const ll& b) override { return a + b; }",
		"    ll addRoot(const ll& subtree, int u) override { return subtree + 1; }",
		"    ll identity() override { return 0; }",
		"};",
		"",
		"// 距离和计算",
		"struct DistanceSum : RerootingDP<pair<ll, ll>> {",
		"    DistanceSum(int n) : RerootingDP<pair<ll, ll>>(n) {}",
		"    pair<ll, ll> merge(const pair<ll, ll>& a, const pair<ll, ll>& b) override {",
		"        return {a.first + b.first, a.second + b.second};",
		"    }",
		"    pair<ll, ll> addRoot(const pair<ll, ll>& subtree, int u) override {",
		"        return {subtree.first + subtree.second, subtree.second + 1};",
		"    }",
		"    pair<ll, ll> identity() override { return {0, 0}; }",
		"};",
		"",
		"// 最大深度",
		"struct MaxDepth : RerootingDP<ll> {",
		"    MaxDepth(int n) : RerootingDP<ll>(n) {}",
		"    ll merge(const ll& a, const ll& b) override { return max(a, b); }",
		"    ll addRoot(const ll& subtree, int u) override { return subtree + 1; }",
		"    ll identity() override { return 0; }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Tree_DP\TreeCutting.h
s("03_dynamic_programming_tree_dp_treecutting_h", {
	t({
		"using ll = long long;",
		"",
		"// 基础树DP模板",
		"struct TreeDP {",
		"    vector<vector<int>> adj;",
		"    int n;",
		"",
		"    TreeDP(int size) : n(size) { adj.resize(n); }",
		"",
		"    void addEdge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"};",
		"",
		"// 树的直径",
		"struct TreeDiameter : TreeDP {",
		"    ll diameter;",
		"",
		"    TreeDiameter(int n) : TreeDP(n), diameter(0) {}",
		"",
		"    ll dfs(int u, int parent) {",
		"        vector<ll> child;",
		"        for (int v : adj[u]) {",
		"            if (v != parent) { child.push_back(dfs(v, u) + 1); }",
		"        }",
		"",
		"        sort(child.rbegin(), child.rend());",
		"        ll path = 0;",
		"        if (child.size() >= 1) path += child[0];",
		"        if (child.size() >= 2) path += child[1];",
		"        diameter = max(diameter, path);",
		"",
		"        return child.empty() ? 0 : child[0];",
		"    }",
		"",
		"    ll solve() {",
		"        diameter = 0;",
		"        dfs(0, -1);",
		"        return diameter;",
		"    }",
		"};",
		"",
		"// 树的重心",
		"struct TreeCentroid : TreeDP {",
		"    vector<int> size;",
		"    int centroid;",
		"",
		"    TreeCentroid(int n) : TreeDP(n), centroid(-1) { size.resize(n); }",
		"",
		"    int dfs(int u, int parent) {",
		"        size[u] = 1;",
		"        int maxSub = 0;",
		"",
		"        for (int v : adj[u]) {",
		"            if (v != parent) {",
		"                int sub = dfs(v, u);",
		"                size[u] += sub;",
		"                maxSub = max(maxSub, sub);",
		"            }",
		"        }",
		"",
		"        maxSub = max(maxSub, n - size[u]);",
		"",
		"        if (centroid == -1 || maxSub < size[centroid]) { centroid = u; }",
		"",
		"        return size[u];",
		"    }",
		"",
		"    int solve() {",
		"        centroid = -1;",
		"        dfs(0, -1);",
		"        return centroid;",
		"    }",
		"};",
		"",
		"// 最大独立集",
		"struct MaxIndependentSet : TreeDP {",
		"    vector<ll> dp0, dp1;  // dp0[u]: 不选u, dp1[u]: 选u",
		"",
		"    MaxIndependentSet(int n) : TreeDP(n) {",
		"        dp0.resize(n);",
		"        dp1.resize(n);",
		"    }",
		"",
		"    void dfs(int u, int parent) {",
		"        dp0[u] = 0;",
		"        dp1[u] = 1;",
		"",
		"        for (int v : adj[u]) {",
		"            if (v != parent) {",
		"                dfs(v, u);",
		"                dp0[u] += max(dp0[v], dp1[v]);",
		"                dp1[u] += dp0[v];",
		"            }",
		"        }",
		"    }",
		"",
		"    ll solve() {",
		"        dfs(0, -1);",
		"        return max(dp0[0], dp1[0]);",
		"    }",
		"};",
		"",
		"// 子树大小",
		"struct SubtreeSize : TreeDP {",
		"    vector<int> size;",
		"",
		"    SubtreeSize(int n) : TreeDP(n) { size.resize(n); }",
		"",
		"    int dfs(int u, int parent) {",
		"        size[u] = 1;",
		"        for (int v : adj[u]) {",
		"            if (v != parent) { size[u] += dfs(v, u); }",
		"        }",
		"        return size[u];",
		"    }",
		"",
		"    vector<int> solve() {",
		"        dfs(0, -1);",
		"        return size;",
		"    }",
		"};",
	})
}),

-- 03_Dynamic_Programming\Tree_DP\TreeDP_Basic.h
s("03_dynamic_programming_tree_dp_treedp_basic_h", {
	t({
		"using ll = long long;",
		"",
		"// 树DP通用模板",
		"template <typename T>",
		"struct TreeDPTemplate {",
		"    vector<vector<int>> adj;",
		"    vector<T> dp;",
		"    int n;",
		"",
		"    TreeDPTemplate(int size) : n(size) {",
		"        adj.resize(n);",
		"        dp.resize(n);",
		"    }",
		"",
		"    void addEdge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"",
		"    virtual T dfs(int u, int parent) = 0;",
		"    virtual T getIdentity() = 0;",
		"",
		"    T solve(int root = 0) {",
		"        fill(dp.begin(), dp.end(), getIdentity());",
		"        return dfs(root, -1);",
		"    }",
		"",
		"    virtual ~TreeDPTemplate() = default;",
		"};",
		"",
		"// 树上路径数",
		"struct TreePaths : TreeDPTemplate<ll> {",
		"    ll totalPaths;",
		"",
		"    TreePaths(int n) : TreeDPTemplate<ll>(n), totalPaths(0) {}",
		"",
		"    ll getIdentity() override { return 0; }",
		"",
		"    ll dfs(int u, int parent) override {",
		"        dp[u] = 1;",
		"        for (int v : adj[u]) {",
		"            if (v != parent) {",
		"                ll child = dfs(v, u);",
		"                totalPaths += dp[u] * child;",
		"                dp[u] += child;",
		"            }",
		"        }",
		"        return dp[u];",
		"    }",
		"",
		"    ll getPaths() {",
		"        totalPaths = 0;",
		"        solve();",
		"        return totalPaths;",
		"    }",
		"};",
		"",
		"// 树上最长路径",
		"struct TreeLongestPath : TreeDPTemplate<ll> {",
		"    ll maxPath;",
		"",
		"    TreeLongestPath(int n) : TreeDPTemplate<ll>(n), maxPath(0) {}",
		"",
		"    ll getIdentity() override { return 0; }",
		"",
		"    ll dfs(int u, int parent) override {",
		"        vector<ll> children;",
		"        for (int v : adj[u]) {",
		"            if (v != parent) {",
		"                ll child = dfs(v, u);",
		"                children.push_back(child);",
		"            }",
		"        }",
		"",
		"        sort(children.rbegin(), children.rend());",
		"        ll path = 0;",
		"        if (children.size() >= 1) path += children[0];",
		"        if (children.size() >= 2) path += children[1];",
		"        maxPath = max(maxPath, path);",
		"",
		"        dp[u] = children.empty() ? 0 : children[0] + 1;",
		"        return dp[u];",
		"    }",
		"",
		"    ll getMaxPath() {",
		"        maxPath = 0;",
		"        solve();",
		"        return maxPath;",
		"    }",
		"};",
		"",
		"// 简化版树DP",
		"struct SimpleTreeDP {",
		"    vector<vector<int>> adj;",
		"    int n;",
		"",
		"    SimpleTreeDP(int size) : n(size) { adj.resize(n); }",
		"",
		"    void addEdge(int u, int v) {",
		"        adj[u].push_back(v);",
		"        adj[v].push_back(u);",
		"    }",
		"",
		"    // 计算子树大小",
		"    vector<int> getSubtreeSizes() {",
		"        vector<int> size(n);",
		"        function<int(int, int)> dfs = [&](int u, int p) {",
		"            size[u] = 1;",
		"            for (int v : adj[u]) {",
		"                if (v != p) size[u] += dfs(v, u);",
		"            }",
		"            return size[u];",
		"        };",
		"        dfs(0, -1);",
		"        return size;",
		"    }",
		"",
		"    // 计算树的直径",
		"    ll getDiameter() {",
		"        ll ans = 0;",
		"        function<ll(int, int)> dfs = [&](int u, int p) -> ll {",
		"            vector<ll> depths;",
		"            for (int v : adj[u]) {",
		"                if (v != p) depths.push_back(dfs(v, u) + 1);",
		"            }",
		"            sort(depths.rbegin(), depths.rend());",
		"            ll path = 0;",
		"            if (depths.size() >= 1) path += depths[0];",
		"            if (depths.size() >= 2) path += depths[1];",
		"            ans = max(ans, path);",
		"            return depths.empty() ? 0 : depths[0];",
		"        };",
		"        dfs(0, -1);",
		"        return ans;",
		"    }",
		"",
		"    // 最大独立集",
		"    ll getMaxIndependentSet() {",
		"        vector<ll> dp0(n), dp1(n);  // dp0: 不选, dp1: 选",
		"        function<void(int, int)> dfs = [&](int u, int p) {",
		"            dp0[u] = 0;",
		"            dp1[u] = 1;",
		"            for (int v : adj[u]) {",
		"                if (v != p) {",
		"                    dfs(v, u);",
		"                    dp0[u] += max(dp0[v], dp1[v]);",
		"                    dp1[u] += dp0[v];",
		"                }",
		"            }",
		"        };",
		"        dfs(0, -1);",
		"        return max(dp0[0], dp1[0]);",
		"    }",
		"};",
	})
}),

-- 04_Math\Combinatorics\Advanced\Bell.h
s("04_math_combinatorics_advanced_bell_h", {
	t({
		"/**",
		" * 贝尔数模板",
		" * 功能：贝尔数计算、贝尔三角形",
		" * 时间复杂度：O(n^2)",
		" */",
		"",
		"using ll = long long;",
		"",
		"// 贝尔数（集合分割数）",
		"struct Bell {",
		"    vector<ll> B;",
		"    vector<vector<ll>> triangle;",
		"    int n;",
		"    ll mod;",
		"",
		"    Bell(int n, ll mod = 1e9 + 7) : n(n), mod(mod) {",
		"        B.resize(n + 1);",
		"        triangle.resize(n + 1);",
		"        for (int i = 0; i <= n; i++) { triangle[i].resize(i + 2); }",
		"        init();",
		"    }",
		"",
		"    void init() {",
		"        // 贝尔三角形计算贝尔数",
		"        triangle[0][0] = B[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            triangle[i][0] = triangle[i - 1][i - 1];",
		"",
		"            for (int j = 1; j <= i; j++) { triangle[i][j] = (triangle[i - 1][j - 1] + triangle[i][j - 1]) % mod; }",
		"",
		"            B[i] = triangle[i][0];",
		"        }",
		"    }",
		"",
		"    ll get(int n) {",
		"        if (n < 0 || n > this->n) return 0;",
		"        return B[n];",
		"    }",
		"};",
		"",
		"// 使用第二类斯特林数计算贝尔数",
		"struct BellByStirling {",
		"    vector<ll> B;",
		"    int n;",
		"    ll mod;",
		"",
		"    BellByStirling(int n, ll mod = 1e9 + 7) : n(n), mod(mod), B(n + 1, 0) { init(); }",
		"",
		"    void init() {",
		"        // B(n) = sum_{k=0}^{n} S(n,k)",
		"        vector<vector<ll>> S(n + 1, vector<ll>(n + 1, 0));",
		"        S[0][0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= i; j++) { S[i][j] = (S[i - 1][j - 1] + (ll)j * S[i - 1][j]) % mod; }",
		"        }",
		"",
		"        for (int i = 0; i <= n; i++) {",
		"            for (int j = 0; j <= i; j++) { B[i] = (B[i] + S[i][j]) % mod; }",
		"        }",
		"    }",
		"",
		"    ll get(int n) {",
		"        if (n < 0 || n > this->n) return 0;",
		"        return B[n];",
		"    }",
		"};",
		"",
		"// 扩展贝尔数模板类",
		"template <typename T = long long>",
		"class BellNumbers {",
		"   private:",
		"    static const int maxn = 1000;",
		"    static const T MOD = 1e9 + 7;",
		"",
		"    vector<T> bell;",
		"    vector<vector<T>> triangle;",
		"",
		"    // 快速幂",
		"    T power(T base, T exp) {",
		"        T result = 1;",
		"        while (exp > 0) {",
		"            if (exp & 1) result = (result * base) % MOD;",
		"            base = (base * base) % MOD;",
		"            exp >>= 1;",
		"        }",
		"        return result;",
		"    }",
		"",
		"   public:",
		"    BellNumbers() {",
		"        bell.resize(maxn + 1);",
		"        triangle.resize(maxn + 1);",
		"        for (int i = 0; i <= maxn; i++) { triangle[i].resize(i + 2); }",
		"        init();",
		"    }",
		"",
		"    void init() {",
		"        // 初始化贝尔三角形",
		"        triangle[0][0] = bell[0] = 1;",
		"",
		"        for (int i = 1; i <= maxn; i++) {",
		"            triangle[i][0] = triangle[i - 1][i - 1];",
		"",
		"            for (int j = 1; j <= i; j++) { triangle[i][j] = (triangle[i - 1][j - 1] + triangle[i][j - 1]) % MOD; }",
		"",
		"            bell[i] = triangle[i][0];",
		"        }",
		"    }",
		"",
		"    // 获取第n个贝尔数",
		"    T get_bell(int n) {",
		"        if (n <= maxn) return bell[n];",
		"        return calculate_bell_large(n);",
		"    }",
		"",
		"    // 使用第二类斯特林数计算贝尔数",
		"    T bell_from_stirling2(int n) {",
		"        T res = 0;",
		"        vector<T> stirling2(n + 1, 0);",
		"        stirling2[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = min(i, n); j >= 1; j--) { stirling2[j] = (stirling2[j - 1] + (T)j * stirling2[j]) % MOD; }",
		"        }",
		"",
		"        for (int k = 0; k <= n; k++) { res = (res + stirling2[k]) % MOD; }",
		"",
		"        return res;",
		"    }",
		"",
		"    // 使用指数生成函数计算大贝尔数",
		"    T calculate_bell_large(int n) { return bell_from_stirling2(n); }",
		"",
		"    // 使用Dobinski公式计算贝尔数（仅理论用途）",
		"    double dobinski_formula(int n) {",
		"        const double E = 2.718281828459045;",
		"        double sum = 0.0;",
		"        double factorial = 1.0;",
		"",
		"        for (int k = 0; k <= 100; k++) {",
		"            if (k > 0) factorial *= k;",
		"            double term = pow(k, n) / factorial;",
		"            sum += term;",
		"            if (term < 1e-15) break;",
		"        }",
		"",
		"        return sum / E;",
		"    }",
		"",
		"    // 贝尔数的递推关系",
		"    T bell_recurrence(int n) {",
		"        if (n == 0) return 1;",
		"",
		"        vector<T> dp(n + 1);",
		"        dp[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            dp[i] = 0;",
		"            T binom = 1;",
		"",
		"            for (int k = 0; k < i; k++) {",
		"                dp[i] = (dp[i] + binom * dp[k]) % MOD;",
		"",
		"                if (k + 1 < i) {",
		"                    binom = binom * (i - 1 - k) % MOD;",
		"                    binom = binom * power(k + 1, MOD - 2) % MOD;",
		"                }",
		"            }",
		"        }",
		"",
		"        return dp[n];",
		"    }",
		"",
		"    // 计算贝尔数的前n项和",
		"    T bell_sum(int n) {",
		"        T sum = 0;",
		"        for (int i = 0; i <= n; i++) { sum = (sum + get_bell(i)) % MOD; }",
		"        return sum;",
		"    }",
		"",
		"    // 获取贝尔三角形的某一行",
		"    vector<T> get_bell_triangle_row(int row) {",
		"        if (row <= maxn) { return vector<T>(triangle[row].begin(), triangle[row].begin() + row + 1); }",
		"",
		"        vector<T> prev_row = get_bell_triangle_row(row - 1);",
		"        vector<T> curr_row(row + 1);",
		"",
		"        curr_row[0] = prev_row.back();",
		"        for (int j = 1; j <= row; j++) { curr_row[j] = (prev_row[j - 1] + curr_row[j - 1]) % MOD; }",
		"",
		"        return curr_row;",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"BellNumbers<long long> bell;",
		"cout << bell.get_bell(5) << endl; // 输出52",
		"cout << bell.bell_sum(5) << endl; // 输出前6个贝尔数的和",
		"",
		"vector<long long> row = bell.get_bell_triangle_row(4);",
		"for (auto x : row) {",
		"    cout << x << \" \";",
		"}",
		"*/",
	})
}),

-- 04_Math\Combinatorics\Advanced\Catalan.h
s("04_math_combinatorics_advanced_catalan_h", {
	t({
		"/**",
		" * 卡特兰数模板",
		" * 功能：卡特兰数计算、应用实例",
		" * 时间复杂度：O(n)预处理，O(1)查询",
		" */",
		"",
		"using ll = long long;",
		"",
		"template <typename T = ll>",
		"struct CatalanNumbers {",
		"    static const int maxn = 1000005;",
		"    static const T MOD = 1e9 + 7;",
		"",
		"    vector<T> catalan;",
		"    vector<T> fact, inv_fact;",
		"    int n;",
		"    T mod;",
		"",
		"    CatalanNumbers(int n = maxn, T mod = MOD) : n(n), mod(mod) {",
		"        catalan.resize(n + 1);",
		"        fact.resize(2 * n + 1);",
		"        inv_fact.resize(2 * n + 1);",
		"        init();",
		"    }",
		"",
		"    T power(T a, T b) {",
		"        T res = 1;",
		"        a %= mod;",
		"        while (b) {",
		"            if (b & 1) res = res * a % mod;",
		"            a = a * a % mod;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    void init() {",
		"        // 预处理阶乘",
		"        fact[0] = 1;",
		"        for (int i = 1; i <= 2 * n; i++) { fact[i] = fact[i - 1] * i % mod; }",
		"        inv_fact[2 * n] = power(fact[2 * n], mod - 2);",
		"        for (int i = 2 * n - 1; i >= 0; i--) { inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod; }",
		"",
		"        calculate_catalan();",
		"    }",
		"",
		"    void calculate_catalan() {",
		"        // 方法1: 递推公式 C(n) = sum_{i=0}^{n-1} C(i) * C(n-1-i)",
		"        catalan[0] = 1;",
		"        for (int i = 1; i <= n; i++) {",
		"            catalan[i] = 0;",
		"            for (int j = 0; j < i; j++) { catalan[i] = (catalan[i] + catalan[j] * catalan[i - 1 - j]) % mod; }",
		"        }",
		"    }",
		"",
		"    // 使用组合数公式计算: C(n) = C(2n, n) / (n + 1)",
		"    T catalan_formula(int n) {",
		"        if (n == 0) return 1;",
		"        return fact[2 * n] * inv_fact[n] % mod * inv_fact[n + 1] % mod;",
		"    }",
		"",
		"    // 另一个公式: C(n) = C(2n, n) - C(2n, n+1)",
		"    T catalan_formula2(int n) {",
		"        T c1 = fact[2 * n] * inv_fact[n] % mod * inv_fact[n] % mod;",
		"        T c2 = fact[2 * n] * inv_fact[n + 1] % mod * inv_fact[n - 1] % mod;",
		"        return (c1 - c2 + mod) % mod;",
		"    }",
		"",
		"    // 获取第n个卡特兰数",
		"    T get_catalan(int n) {",
		"        if (n <= this->n) return catalan[n];",
		"        return catalan_formula(n);",
		"    }",
		"",
		"    // 卡特兰数的各种应用",
		"",
		"    // 1. n对括号的合法匹配数",
		"    T valid_parentheses(int n) { return get_catalan(n); }",
		"",
		"    // 2. n+1个数字构成的二叉搜索树数量",
		"    T binary_search_trees(int n) { return get_catalan(n); }",
		"",
		"    // 3. 从(0,0)到(n,n)不越过对角线的路径数",
		"    T lattice_paths(int n) { return get_catalan(n); }",
		"",
		"    // 4. n+2边形的三角剖分数",
		"    T polygon_triangulations(int n) { return get_catalan(n); }",
		"",
		"    // 5. 长度为2n的Dyck路径数",
		"    T dyck_paths(int n) { return get_catalan(n); }",
		"",
		"    // 6. n个节点的满二叉树数量",
		"    T full_binary_trees(int n) {",
		"        if (n % 2 == 0) return 0;  // 满二叉树节点数必须为奇数",
		"        return get_catalan((n - 1) / 2);",
		"    }",
		"",
		"    // 7. 山脉数组的数量（n个上升，n个下降）",
		"    T mountain_ranges(int n) { return get_catalan(n); }",
		"",
		"    // 扩展：带权重的卡特兰数",
		"    T weighted_catalan(int n, vector<T>& weights) {",
		"        vector<T> dp(n + 1, 0);",
		"        dp[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 0; j < i; j++) { dp[i] = (dp[i] + dp[j] * dp[i - 1 - j] % mod * weights[j]) % mod; }",
		"        }",
		"",
		"        return dp[n];",
		"    }",
		"",
		"    // 超级卡特兰数：S(m,n) = ((2m)!(2n)!) / ((m+n)!m!n!)",
		"    T super_catalan(int m, int n) {",
		"        T res = fact[2 * m] * fact[2 * n] % mod;",
		"        res = res * inv_fact[m + n] % mod;",
		"        res = res * inv_fact[m] % mod;",
		"        res = res * inv_fact[n] % mod;",
		"        return res;",
		"    }",
		"",
		"    // 生成函数方法计算卡特兰数",
		"    vector<T> catalan_generating_function(int n) {",
		"        vector<T> c(n + 1, 0);",
		"        c[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 0; j < i; j++) { c[i] = (c[i] + c[j] * c[i - 1 - j]) % mod; }",
		"        }",
		"",
		"        return c;",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"CatalanNumbers<long long> cat(100);",
		"cout << cat.get_catalan(5) << endl; // 输出42",
		"cout << cat.valid_parentheses(3) << endl; // 3对括号的合法匹配数：5",
		"cout << cat.binary_search_trees(4) << endl; // 4个节点的BST数量：14",
		"*/",
	})
}),

-- 04_Math\Combinatorics\Advanced\Stirling.h
s("04_math_combinatorics_advanced_stirling_h", {
	t({
		"/**",
		" * 斯特林数模板",
		" * 功能：第一类斯特林数、第二类斯特林数",
		" * 时间复杂度：O(n^2)",
		" */",
		"",
		"using ll = long long;",
		"",
		"// 第一类斯特林数",
		"struct Stirling1 {",
		"    vector<vector<ll>> s;",
		"    int n;",
		"    ll mod;",
		"",
		"    Stirling1(int n, ll mod = 1e9 + 7) : n(n), mod(mod) {",
		"        s.assign(n + 1, vector<ll>(n + 1, 0));",
		"        init();",
		"    }",
		"",
		"    void init() {",
		"        s[0][0] = 1;",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= i; j++) { s[i][j] = (s[i - 1][j - 1] + (ll)(i - 1) * s[i - 1][j]) % mod; }",
		"        }",
		"    }",
		"",
		"    ll get(int n, int k) {",
		"        if (n < 0 || k < 0 || k > n) return 0;",
		"        return s[n][k];",
		"    }",
		"};",
		"",
		"// 第二类斯特林数",
		"struct Stirling2 {",
		"    vector<vector<ll>> S;",
		"    int n;",
		"    ll mod;",
		"",
		"    Stirling2(int n, ll mod = 1e9 + 7) : n(n), mod(mod) {",
		"        S.assign(n + 1, vector<ll>(n + 1, 0));",
		"        init();",
		"    }",
		"",
		"    void init() {",
		"        S[0][0] = 1;",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= i; j++) { S[i][j] = (S[i - 1][j - 1] + (ll)j * S[i - 1][j]) % mod; }",
		"        }",
		"    }",
		"",
		"    ll get(int n, int k) {",
		"        if (n < 0 || k < 0 || k > n) return 0;",
		"        return S[n][k];",
		"    }",
		"};",
		"",
		"// 贝尔数（第二类斯特林数的行和）",
		"struct Bell {",
		"    vector<ll> B;",
		"    int n;",
		"    ll mod;",
		"",
		"    Bell(int n, ll mod = 1e9 + 7) : n(n), mod(mod), B(n + 1, 0) { init(); }",
		"",
		"    void init() {",
		"        Stirling2 s2(n, mod);",
		"        for (int i = 0; i <= n; i++) {",
		"            for (int j = 0; j <= i; j++) { B[i] = (B[i] + s2.get(i, j)) % mod; }",
		"        }",
		"    }",
		"",
		"    ll get(int n) {",
		"        if (n < 0 || n > this->n) return 0;",
		"        return B[n];",
		"    }",
		"};",
		"",
		"// 斯特林数工具类",
		"template <typename T = long long>",
		"class StirlingNumbers {",
		"   private:",
		"    static const T MOD = 1e9 + 7;",
		"    static const int maxn = 1000;",
		"    vector<vector<T>> stirling1, stirling2;",
		"    int n;",
		"",
		"   public:",
		"    StirlingNumbers(int size) : n(size) {",
		"        stirling1.assign(size + 1, vector<T>(size + 1, 0));",
		"        stirling2.assign(size + 1, vector<T>(size + 1, 0));",
		"        init();",
		"    }",
		"",
		"    void init() {",
		"        // 初始化第一类斯特林数",
		"        stirling1[0][0] = 1;",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= i; j++) {",
		"                stirling1[i][j] = (stirling1[i - 1][j - 1] + (T)(i - 1) * stirling1[i - 1][j]) % MOD;",
		"            }",
		"        }",
		"",
		"        // 初始化第二类斯特林数",
		"        stirling2[0][0] = 1;",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 1; j <= i; j++) {",
		"                stirling2[i][j] = (stirling2[i - 1][j - 1] + (T)j * stirling2[i - 1][j]) % MOD;",
		"            }",
		"        }",
		"    }",
		"",
		"    // 获取第一类斯特林数",
		"    T get_stirling1(int n, int k) {",
		"        if (n > this->n || k > this->n || n < 0 || k < 0) return 0;",
		"        return stirling1[n][k];",
		"    }",
		"",
		"    // 获取第二类斯特林数",
		"    T get_stirling2(int n, int k) {",
		"        if (n > this->n || k > this->n || n < 0 || k < 0) return 0;",
		"        return stirling2[n][k];",
		"    }",
		"",
		"    // 计算贝尔数 B(n) = sum_{k=0}^n S(n,k)",
		"    T bell_number(int n) {",
		"        T res = 0;",
		"        for (int k = 0; k <= n; k++) { res = (res + stirling2[n][k]) % MOD; }",
		"        return res;",
		"    }",
		"",
		"    // 快速幂",
		"    T power(T a, T b) {",
		"        T res = 1;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % MOD;",
		"            a = a * a % MOD;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    // 组合数计算",
		"    T combination(T n, T k) {",
		"        if (k > n || k < 0) return 0;",
		"        if (k == 0 || k == n) return 1;",
		"",
		"        T res = 1;",
		"        for (T i = 0; i < k; i++) {",
		"            res = res * ((n - i) % MOD) % MOD;",
		"            res = res * power(i + 1, MOD - 2) % MOD;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    // 使用容斥原理计算第二类斯特林数的大数版本",
		"    T stirling2_large(T n, T k) {",
		"        if (k > n || k == 0) return 0;",
		"        if (k == 1 || k == n) return 1;",
		"",
		"        T res = 0;",
		"        T fact_k = 1;",
		"        for (T i = 1; i <= k; i++) { fact_k = fact_k * i % MOD; }",
		"",
		"        T inv_fact_k = power(fact_k, MOD - 2);",
		"",
		"        for (T i = 0; i <= k; i++) {",
		"            T term = combination(k, i) * power(k - i, n) % MOD;",
		"            if (i & 1) {",
		"                res = (res - term + MOD) % MOD;",
		"            } else {",
		"                res = (res + term) % MOD;",
		"            }",
		"        }",
		"",
		"        return res * inv_fact_k % MOD;",
		"    }",
		"",
		"    // 第二类斯特林数的生成函数方法",
		"    vector<T> stirling2_row(int n) {",
		"        vector<T> dp(n + 1, 0);",
		"        dp[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = min(i, n); j >= 1; j--) { dp[j] = (dp[j - 1] + (T)j * dp[j]) % MOD; }",
		"        }",
		"",
		"        return dp;",
		"    }",
		"",
		"    // 第一类斯特林数某一行",
		"    vector<T> stirling1_row(int n) {",
		"        vector<T> dp(n + 1, 0);",
		"        dp[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = min(i, n); j >= 1; j--) { dp[j] = (dp[j - 1] + (T)(i - 1) * dp[j]) % MOD; }",
		"        }",
		"",
		"        return dp;",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"StirlingNumbers<long long> stirling(100);",
		"cout << stirling.get_stirling2(5, 3) << endl; // 输出25",
		"cout << stirling.bell_number(5) << endl; // 输出52",
		"*/",
	})
}),

-- 04_Math\Combinatorics\Basic\BasicMath.h
s("04_math_combinatorics_basic_basicmath_h", {
	t({
		"/**",
		" * 基础数学函数模板",
		" * 功能：整数除法、开方、对数、数学工具函数",
		" * 时间复杂度：O(1)或O(log n)",
		" */",
		"",
		"using ll = long long;",
		"",
		"// 向上取整除法",
		"template <typename T>",
		"constexpr T ceil_div(T n, T m) {",
		"    return (n + m - 1) / m;",
		"}",
		"",
		"// 向下取整除法",
		"template <typename T>",
		"constexpr T floor_div(T n, T m) {",
		"    return n / m;",
		"}",
		"",
		"// 更新最大值",
		"template <typename T>",
		"void chmax(T &a, T b) {",
		"    if (a < b) a = b;",
		"}",
		"",
		"// 更新最小值",
		"template <typename T>",
		"void chmin(T &a, T b) {",
		"    if (a > b) a = b;",
		"}",
		"",
		"// 整数开方",
		"ll isqrt(ll n) {",
		"    ll s = sqrtl(n);",
		"    while (s * s > n) s--;",
		"    while ((s + 1) * (s + 1) <= n) s++;",
		"    return s;",
		"}",
		"",
		"// 找到最小的u使得1+2+...+u >= n",
		"ll triangular_root(ll n) {",
		"    ll u = isqrt(2 * n);",
		"    while (u * (u + 1) / 2 < n) u++;",
		"    while (u * (u - 1) / 2 >= n) u--;",
		"    return u;",
		"}",
		"",
		"// 整数对数：返回log_a(b)的上界",
		"int ilog(int a, ll b) {",
		"    int t = 0;",
		"    ll v = 1;",
		"    while (v < b) {",
		"        v *= a;",
		"        t++;",
		"    }",
		"    return t;",
		"}",
		"",
		"// 判断是否为2的幂",
		"bool is_power_of_2(ll x) { return x > 0 && (x & (x - 1)) == 0; }",
		"",
		"// 返回小于等于x的最大2的幂",
		"ll max_power_of_2(ll x) { return x <= 0 ? 0 : 1LL << (63 - __builtin_clzll(x)); }",
		"",
		"// 预处理log2数组",
		"struct Log2Table {",
		"    vector<int> lg;",
		"",
		"    Log2Table(int n = 100000) : lg(n + 1) {",
		"        lg[1] = 0;",
		"        for (int i = 2; i <= n; i++) { lg[i] = lg[i / 2] + 1; }",
		"    }",
		"",
		"    int operator[](int x) const { return lg[x]; }",
		"};",
	})
}),

-- 04_Math\Combinatorics\Basic\Combination.h
s("04_math_combinatorics_basic_combination_h", {
	t({
		"/**",
		" * 组合数计算模板",
		" * 功能：杨辉三角、直接计算、Lucas定理",
		" * 时间复杂度：O(n^2)预处理，O(1)查询或O(log p)",
		" */",
		"",
		"using ll = long long;",
		"",
		"// 快速幂",
		"ll power(ll a, ll b, ll mod) {",
		"    ll res = 1;",
		"    a %= mod;",
		"    while (b) {",
		"        if (b & 1) res = res * a % mod;",
		"        a = a * a % mod;",
		"        b >>= 1;",
		"    }",
		"    return res;",
		"}",
		"",
		"// 杨辉三角预处理组合数",
		"struct PascalTriangle {",
		"    vector<vector<ll>> C;",
		"    int n;",
		"    ll mod;",
		"",
		"    PascalTriangle(int n, ll mod = 1e9 + 7) : n(n), mod(mod) {",
		"        C.assign(n + 1, vector<ll>(n + 1, 0));",
		"        init();",
		"    }",
		"",
		"    void init() {",
		"        for (int i = 0; i <= n; i++) {",
		"            C[i][0] = C[i][i] = 1;",
		"            for (int j = 1; j < i; j++) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; }",
		"        }",
		"    }",
		"",
		"    ll get(int n, int k) {",
		"        if (n < 0 || k < 0 || k > n) return 0;",
		"        return C[n][k];",
		"    }",
		"};",
		"",
		"// 直接计算组合数",
		"ll combination(ll n, ll k, ll mod = 1e9 + 7) {",
		"    if (k < 0 || k > n) return 0;",
		"    if (k == 0 || k == n) return 1;",
		"",
		"    k = min(k, n - k);  // 优化：利用对称性",
		"",
		"    ll num = 1, den = 1;",
		"    for (int i = 0; i < k; i++) {",
		"        num = num * ((n - i) % mod) % mod;",
		"        den = den * (i + 1) % mod;",
		"    }",
		"",
		"    return num * power(den, mod - 2, mod) % mod;",
		"}",
		"",
		"// Lucas 定理计算大数组合数",
		"ll lucas(ll n, ll k, ll p) {",
		"    if (k == 0) return 1;",
		"    return combination(n % p, k % p, p) * lucas(n / p, k / p, p) % p;",
		"}",
		"",
		"// 多项式系数",
		"ll multinomial(const vector<int>& k, ll mod = 1e9 + 7) {",
		"    int n = 0;",
		"    for (int x : k) n += x;",
		"",
		"    ll result = 1;",
		"    for (int x : k) {",
		"        result = result * combination(n, x, mod) % mod;",
		"        n -= x;",
		"    }",
		"    return result;",
		"}",
	})
}),

-- 04_Math\Combinatorics\Basic\ExLucas.h
s("04_math_combinatorics_basic_exlucas_h", {
	t({
		"/**",
		" * 扩展Lucas定理模板",
		" * 功能：计算C(n,m) mod p，p可以不是质数",
		" * 时间复杂度：O(p^k * log n)",
		" */",
		"",
		"using ll = long long;",
		"",
		"// 扩展Lucas定理",
		"struct ExLucas {",
		"    ll power(ll a, ll b, ll mod) {",
		"        ll res = 1;",
		"        a %= mod;",
		"        while (b) {",
		"            if (b & 1) res = res * a % mod;",
		"            a = a * a % mod;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    ll exgcd(ll a, ll b, ll &x, ll &y) {",
		"        if (!b) {",
		"            x = 1, y = 0;",
		"            return a;",
		"        }",
		"        ll d = exgcd(b, a % b, y, x);",
		"        y -= a / b * x;",
		"        return d;",
		"    }",
		"",
		"    ll inv(ll a, ll mod) {",
		"        ll x, y;",
		"        ll d = exgcd(a, mod, x, y);",
		"        return d == 1 ? (x % mod + mod) % mod : -1;",
		"    }",
		"",
		"    ll calc_fac(ll n, ll p, ll pk) {",
		"        if (!n) return 1;",
		"        ll res = 1;",
		"        for (ll i = 1; i <= pk; i++) {",
		"            if (i % p) res = res * i % pk;",
		"        }",
		"        res = power(res, n / pk, pk);",
		"        for (ll i = 1; i <= n % pk; i++) {",
		"            if (i % p) res = res * i % pk;",
		"        }",
		"        return res * calc_fac(n / p, p, pk) % pk;",
		"    }",
		"",
		"    ll calc_power(ll n, ll p) {",
		"        ll cnt = 0;",
		"        while (n) {",
		"            n /= p;",
		"            cnt += n;",
		"        }",
		"        return cnt;",
		"    }",
		"",
		"    ll solve(ll n, ll m, ll p, ll pk) {",
		"        ll fac_n = calc_fac(n, p, pk);",
		"        ll fac_m = calc_fac(m, p, pk);",
		"        ll fac_nm = calc_fac(n - m, p, pk);",
		"        ll cnt = calc_power(n, p) - calc_power(m, p) - calc_power(n - m, p);",
		"        ll res = fac_n * inv(fac_m, pk) % pk * inv(fac_nm, pk) % pk;",
		"        return res * power(p, cnt, pk) % pk;",
		"    }",
		"",
		"    ll C(ll n, ll m, ll mod) {",
		"        if (n < m || m < 0) return 0;",
		"",
		"        vector<pair<ll, ll>> factors;",
		"        ll temp = mod;",
		"        for (ll i = 2; i * i <= temp; i++) {",
		"            if (temp % i == 0) {",
		"                ll pk = 1;",
		"                while (temp % i == 0) {",
		"                    temp /= i;",
		"                    pk *= i;",
		"                }",
		"                factors.push_back({i, pk});",
		"            }",
		"        }",
		"        if (temp > 1) factors.push_back({temp, temp});",
		"",
		"        vector<ll> a, m_vec;",
		"        for (auto [p, pk] : factors) {",
		"            a.push_back(solve(n, m, p, pk));",
		"            m_vec.push_back(pk);",
		"        }",
		"",
		"        // 中国剩余定理",
		"        ll res = 0, M = 1;",
		"        for (ll mi : m_vec) M *= mi;",
		"",
		"        for (int i = 0; i < a.size(); i++) {",
		"            ll Mi = M / m_vec[i];",
		"            res = (res + a[i] * Mi % M * inv(Mi, m_vec[i]) % M) % M;",
		"        }",
		"        return (res + M) % M;",
		"    }",
		"};",
		"T res = 0;",
		"while (n) {",
		"    n /= p;",
		"    res += n;",
		"}",
		"return res;",
		"}",
		"",
		"// 计算n! / p^k mod p^alpha",
		"T calc_factorial(T n, T p, T alpha) {",
		"    if (n == 0) return 1;",
		"    T pk = power(p, alpha, LLONG_MAX);",
		"    T res = 1;",
		"",
		"    // 计算不包含p的部分",
		"    for (T i = 1; i <= pk; i++) {",
		"        if (i % p != 0) { res = res * i % pk; }",
		"    }",
		"    res = power(res, n / pk, pk);",
		"",
		"    // 计算剩余部分",
		"    for (T i = 1; i <= n % pk; i++) {",
		"        if (i % p != 0) { res = res * i % pk; }",
		"    }",
		"",
		"    return res * calc_factorial(n / p, p, alpha) % pk;",
		"}",
		"",
		"// 计算C(n, m) mod p^alpha",
		"T calc_comb(T n, T m, T p, T alpha) {",
		"    if (n < m || n < 0 || m < 0) return 0;",
		"",
		"    T pk = power(p, alpha, LLONG_MAX);",
		"    T cnt = calc_power(n, p) - calc_power(m, p) - calc_power(n - m, p);",
		"",
		"    if (cnt >= alpha) return 0;",
		"",
		"    T res = calc_factorial(n, p, alpha);",
		"    res = res * inv(calc_factorial(m, p, alpha), pk) % pk;",
		"    res = res * inv(calc_factorial(n - m, p, alpha), pk) % pk;",
		"    res = res * power(p, cnt, pk) % pk;",
		"",
		"    return res;",
		"}",
		"",
		"// 中国剩余定理合并",
		"T crt(vector<T> &a, vector<T> &m) {",
		"    T res = 0, M = 1;",
		"    for (auto mod : m) M *= mod;",
		"",
		"    for (int i = 0; i < a.size(); i++) {",
		"        T Mi = M / m[i];",
		"        T ti = inv(Mi, m[i]);",
		"        res = (res + a[i] * Mi * ti) % M;",
		"    }",
		"    return (res + M) % M;",
		"}",
		"",
		"// 扩展Lucas定理主函数",
		"T exlucas(T n, T m, T mod) {",
		"    vector<T> primes, alphas;",
		"    T temp = mod;",
		"",
		"    // 分解模数",
		"    for (T i = 2; i * i <= temp; i++) {",
		"        if (temp % i == 0) {",
		"            primes.push_back(i);",
		"            T alpha = 0;",
		"            while (temp % i == 0) {",
		"                temp /= i;",
		"                alpha++;",
		"            }",
		"            alphas.push_back(alpha);",
		"        }",
		"    }",
		"    if (temp > 1) {",
		"        primes.push_back(temp);",
		"        alphas.push_back(1);",
		"    }",
		"",
		"    // 使用CRT合并结果",
		"    vector<T> a, moduli;",
		"    for (int i = 0; i < primes.size(); i++) {",
		"        T pk = power(primes[i], alphas[i], LLONG_MAX);",
		"        a.push_back(calc_comb(n, m, primes[i], alphas[i]));",
		"        moduli.push_back(pk);",
		"    }",
		"",
		"    return crt(a, moduli);",
		"}",
		"}",
		";",
		"",
		"// 使用示例",
		"/*",
		"ExLucas<long long> exlucas;",
		"cout << exlucas.exlucas(1000000, 500000, 999999937) << endl;",
		"*/",
	})
}),

-- 04_Math\Combinatorics\Basic\Factorial.h
s("04_math_combinatorics_basic_factorial_h", {
	t({
		"/**",
		" * 阶乘预处理模板",
		" * 功能：阶乘、阶乘逆元、组合数、排列数",
		" * 时间复杂度：预处理O(n)，查询O(1)",
		" */",
		"",
		"using ll = long long;",
		"",
		"// 阶乘预处理模板",
		"template <int MAXN = 200005, ll MOD = 1e9 + 7>",
		"struct Factorial {",
		"    ll fac[MAXN], inv_fac[MAXN];",
		"",
		"    Factorial() { init(); }",
		"",
		"    ll power(ll a, ll b) {",
		"        ll res = 1;",
		"        a %= MOD;",
		"        while (b) {",
		"            if (b & 1) res = res * a % MOD;",
		"            a = a * a % MOD;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    void init() {",
		"        fac[0] = 1;",
		"        for (int i = 1; i < MAXN; i++) { fac[i] = fac[i - 1] * i % MOD; }",
		"        inv_fac[MAXN - 1] = power(fac[MAXN - 1], MOD - 2);",
		"        for (int i = MAXN - 2; i >= 0; i--) { inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD; }",
		"    }",
		"",
		"    ll factorial(int n) { return n >= MAXN ? 0 : fac[n]; }",
		"",
		"    ll inv_factorial(int n) { return n >= MAXN ? 0 : inv_fac[n]; }",
		"",
		"    ll C(int n, int m) {",
		"        if (n < m || m < 0 || n >= MAXN) return 0;",
		"        return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;",
		"    }",
		"",
		"    ll A(int n, int m) {",
		"        if (n < m || m < 0 || n >= MAXN) return 0;",
		"        return fac[n] * inv_fac[n - m] % MOD;",
		"    }",
		"",
		"    ll inv(int n) { return n >= MAXN ? 0 : fac[n - 1] * inv_fac[n] % MOD; }",
		"};",
		"",
		"// 威尔逊定理相关",
		"struct Wilson {",
		"    // 威尔逊定理：(p-1)! ≡ -1 (mod p) 当且仅当 p 是质数",
		"    bool is_prime_wilson(ll p) {",
		"        if (p <= 1) return false;",
		"        if (p == 2) return true;",
		"",
		"        ll fact = 1;",
		"        for (ll i = 2; i < p; i++) { fact = fact * i % p; }",
		"        return fact == p - 1;",
		"    }",
		"};",
		"",
		"// 排列数 P(n, k) = A(n, k)",
		"ll P(int n, int k) {",
		"    if (k < 0 || k > n) return 0;",
		"    return fact[n] * inv_fact[n - k] % MOD;",
		"}",
		"",
		"// 多重组合数 H(n, k) = C(n+k-1, k)",
		"ll H(int n, int k) { return C(n + k - 1, k); }",
		"",
		"// 卡特兰数 Cat(n) = C(2n, n) / (n+1)",
		"ll catalan(int n) {",
		"    if (n == 0) return 1;",
		"    return C(2 * n, n) * modinv(n + 1) % MOD;",
		"}",
		"",
		"// 斯特林数第一类 s(n, k) - 符号的",
		"// n个不同元素构成k个循环的方案数",
		"vector<vector<ll>> stirling1(int n) {",
		"    vector<vector<ll>> s(n + 1, vector<ll>(n + 1, 0));",
		"    s[0][0] = 1;",
		"",
		"    for (int i = 1; i <= n; i++) {",
		"        for (int j = 1; j <= i; j++) { s[i][j] = ((ll)(i - 1) * s[i - 1][j] % MOD + s[i - 1][j - 1]) % MOD; }",
		"    }",
		"    return s;",
		"}",
		"",
		"// 斯特林数第二类 S(n, k)",
		"// n个不同元素分成k个非空子集的方案数",
		"vector<vector<ll>> stirling2(int n) {",
		"    vector<vector<ll>> S(n + 1, vector<ll>(n + 1, 0));",
		"    S[0][0] = 1;",
		"",
		"    for (int i = 1; i <= n; i++) {",
		"        for (int j = 1; j <= i; j++) { S[i][j] = ((ll)j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD; }",
		"    }",
		"    return S;",
		"}",
		"",
		"// 贝尔数 B(n) - n个元素的所有划分数",
		"ll bell_number(int n) {",
		"    vector<vector<ll>> S = stirling2(n);",
		"    ll result = 0;",
		"    for (int k = 0; k <= n; k++) { result = (result + S[n][k]) % MOD; }",
		"    return result;",
		"}",
		"",
		"// 错排数 D(n)",
		"ll derangement(int n) {",
		"    if (n == 0) return 1;",
		"    if (n == 1) return 0;",
		"",
		"    vector<ll> d(n + 1);",
		"    d[0] = 1;",
		"    d[1] = 0;",
		"",
		"    for (int i = 2; i <= n; i++) { d[i] = ((ll)(i - 1) * (d[i - 1] + d[i - 2])) % MOD; }",
		"    return d[n];",
		"}",
		"",
		"// 分拆数 - 将n分拆成若干正整数之和的方案数",
		"vector<ll> partition_numbers(int n) {",
		"    vector<ll> p(n + 1, 0);",
		"    p[0] = 1;",
		"",
		"    for (int i = 1; i <= n; i++) {",
		"        for (int j = i; j <= n; j++) { p[j] = (p[j] + p[j - i]) % MOD; }",
		"    }",
		"    return p;",
		"}",
		"",
		"// 欧拉函数值的计算（单个）",
		"ll euler_phi(ll n) {",
		"    ll result = n;",
		"    for (ll i = 2; i * i <= n; i++) {",
		"        if (n % i == 0) {",
		"            while (n % i == 0) n /= i;",
		"            result -= result / i;",
		"        }",
		"    }",
		"    if (n > 1) result -= result / n;",
		"    return result;",
		"}",
		"",
		"// 二项式定理展开系数",
		"vector<ll> binomial_expansion(int n) {",
		"    vector<ll> coeffs(n + 1);",
		"    for (int k = 0; k <= n; k++) { coeffs[k] = C(n, k); }",
		"    return coeffs;",
		"}",
	})
}),

-- 04_Math\Combinatorics\Basic\FactorialCombination.h
s("04_math_combinatorics_basic_factorialcombination_h", {
	t({
		"/**",
		" * 阶乘与组合数模板",
		" * 功能：快速幂、阶乘预处理、组合数计算",
		" * 时间复杂度：预处理O(n)，查询O(1)",
		" */",
		"",
		"using ll = long long;",
		"",
		"// 快速幂模板",
		"struct FastPower {",
		"    ll pow(ll a, ll b, ll mod) {",
		"        ll res = 1;",
		"        a %= mod;",
		"        while (b) {",
		"            if (b & 1) res = res * a % mod;",
		"            a = a * a % mod;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"};",
		"",
		"// 阶乘与组合数预处理",
		"template <int MAXN = 200005>",
		"struct FactorialCombination {",
		"    static constexpr ll MOD = 1e9 + 7;",
		"    ll fac[MAXN], inv_fac[MAXN];",
		"    FastPower fp;",
		"",
		"    FactorialCombination() { init(); }",
		"",
		"    void init() {",
		"        fac[0] = 1;",
		"        for (int i = 1; i < MAXN; i++) { fac[i] = fac[i - 1] * i % MOD; }",
		"        inv_fac[MAXN - 1] = fp.pow(fac[MAXN - 1], MOD - 2, MOD);",
		"        for (int i = MAXN - 2; i >= 0; i--) { inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD; }",
		"    }",
		"",
		"    ll C(int n, int m) {",
		"        if (n < m || m < 0) return 0;",
		"        return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;",
		"    }",
		"",
		"    ll A(int n, int m) {",
		"        if (n < m || m < 0) return 0;",
		"        return fac[n] * inv_fac[n - m] % MOD;",
		"    }",
		"",
		"    ll factorial(int n) { return fac[n]; }",
		"    ll inv_factorial(int n) { return inv_fac[n]; }",
		"};",
		"",
		"// 小范围组合数（杨辉三角）",
		"struct SmallCombination {",
		"    vector<vector<ll>> C;",
		"    int n;",
		"    ll mod;",
		"",
		"    SmallCombination(int n, ll mod = 1e9 + 7) : n(n), mod(mod) {",
		"        C.assign(n + 1, vector<ll>(n + 1, 0));",
		"        init();",
		"    }",
		"",
		"    void init() {",
		"        for (int i = 0; i <= n; i++) {",
		"            C[i][0] = C[i][i] = 1;",
		"            for (int j = 1; j < i; j++) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; }",
		"        }",
		"    }",
		"",
		"    ll get(int n, int m) {",
		"        if (n < 0 || m < 0 || n < m) return 0;",
		"        return C[n][m];",
		"    }",
		"};",
	})
}),

-- 04_Math\Combinatorics\Basic\LucasTheorem.h
s("04_math_combinatorics_basic_lucastheorem_h", {
	t({
		"/**",
		" * Lucas定理模板",
		" * 功能：计算C(n,m) mod p，p为质数",
		" * 时间复杂度：O(p + log_p(n))",
		" */",
		"",
		"using ll = long long;",
		"",
		"// Lucas定理",
		"struct Lucas {",
		"    ll p;",
		"    vector<ll> fac, inv_fac;",
		"",
		"    Lucas(ll p) : p(p) { init(); }",
		"",
		"    ll power(ll a, ll b) {",
		"        ll res = 1;",
		"        a %= p;",
		"        while (b) {",
		"            if (b & 1) res = res * a % p;",
		"            a = a * a % p;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    void init() {",
		"        fac.resize(p);",
		"        inv_fac.resize(p);",
		"        fac[0] = 1;",
		"        for (int i = 1; i < p; i++) { fac[i] = fac[i - 1] * i % p; }",
		"        inv_fac[p - 1] = power(fac[p - 1], p - 2);",
		"        for (int i = p - 2; i >= 0; i--) { inv_fac[i] = inv_fac[i + 1] * (i + 1) % p; }",
		"    }",
		"",
		"    ll C(ll n, ll m) {",
		"        if (n < m || m < 0) return 0;",
		"        if (n < p && m < p) { return fac[n] * inv_fac[m] % p * inv_fac[n - m] % p; }",
		"        return C(n / p, m / p) * C(n % p, m % p) % p;",
		"    }",
		"",
		"    // 计算阶乘的最高次幂",
		"    ll factorial_power(ll n, ll prime) {",
		"        ll res = 0;",
		"        while (n) {",
		"            n /= prime;",
		"            res += n;",
		"        }",
		"        return res;",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"Lucas lucas(1000000007);",
		"cout << lucas.C(1000000, 500000) << endl;",
		"cout << lucas.factorial_power(10, 2) << endl; // 计算10!中2的幂次",
		"*/",
	})
}),

-- 04_Math\Combinatorics\Generating_Functions\EGF.h
s("04_math_combinatorics_generating_functions_egf_h", {
	t({
		"// 指数生成函数基础结构",
		"struct EGF {",
		"    static const int MOD = 1e9 + 7;",
		"    static const int MAXN = 100005;",
		"    vector<long long> fact, inv_fact;",
		"",
		"    EGF() { precompute_factorials(); }",
		"",
		"    void precompute_factorials() {",
		"        fact.resize(MAXN);",
		"        inv_fact.resize(MAXN);",
		"        fact[0] = 1;",
		"        for (int i = 1; i < MAXN; i++) { fact[i] = fact[i - 1] * i % MOD; }",
		"        inv_fact[MAXN - 1] = quick_pow(fact[MAXN - 1], MOD - 2);",
		"        for (int i = MAXN - 2; i >= 0; i--) { inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD; }",
		"    }",
		"",
		"    long long quick_pow(long long a, long long b) {",
		"        long long res = 1;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % MOD;",
		"            a = a * a % MOD;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    // EGF基本运算",
		"    vector<long long> add(const vector<long long>& f, const vector<long long>& g) {",
		"        int n = max(f.size(), g.size());",
		"        vector<long long> result(n);",
		"        for (int i = 0; i < n; i++) {",
		"            long long fi = (i < f.size()) ? f[i] : 0;",
		"            long long gi = (i < g.size()) ? g[i] : 0;",
		"            result[i] = (fi + gi) % MOD;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    vector<long long> multiply(const vector<long long>& f, const vector<long long>& g) {",
		"        int n = f.size() + g.size() - 1;",
		"        vector<long long> result(n, 0);",
		"        for (int i = 0; i < f.size(); i++) {",
		"            for (int j = 0; j < g.size(); j++) {",
		"                if (i + j < n) {",
		"                    long long term = f[i] * g[j] % MOD;",
		"                    term = term * fact[i + j] % MOD;",
		"                    term = term * inv_fact[i] % MOD;",
		"                    term = term * inv_fact[j] % MOD;",
		"                    result[i + j] = (result[i + j] + term) % MOD;",
		"                }",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"};  // 常用指数生成函数",
		"struct EGFGenerator {",
		"    EGF egf;",
		"",
		"    // 指数函数 e^x",
		"    vector<long long> exponential(int n) {",
		"        vector<long long> result(n);",
		"        for (int i = 0; i < n; i++) result[i] = egf.inv_fact[i];",
		"        return result;",
		"    }",
		"",
		"    // 三角函数 sin(x)",
		"    vector<long long> sine(int n) {",
		"        vector<long long> result(n, 0);",
		"        long long sign = 1;",
		"        for (int i = 1; i < n; i += 2) {",
		"            result[i] = sign * egf.inv_fact[i] % EGF::MOD;",
		"            if (result[i] < 0) result[i] += EGF::MOD;",
		"            sign = -sign;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 三角函数 cos(x)",
		"    vector<long long> cosine(int n) {",
		"        vector<long long> result(n, 0);",
		"        long long sign = 1;",
		"        for (int i = 0; i < n; i += 2) {",
		"            result[i] = sign * egf.inv_fact[i] % EGF::MOD;",
		"            if (result[i] < 0) result[i] += EGF::MOD;",
		"            sign = -sign;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 二项式 (1+x)^r",
		"    vector<long long> binomial(long long r, int n) {",
		"        vector<long long> result(n);",
		"        result[0] = 1;",
		"        long long coeff = 1;",
		"        for (int i = 1; i < n; i++) {",
		"            coeff = coeff * (r - i + 1) % EGF::MOD;",
		"            coeff = coeff * egf.inv_fact[1] % EGF::MOD;",
		"            result[i] = coeff * egf.inv_fact[i] % EGF::MOD;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 从EGF系数获取原始数列",
		"    vector<long long> get_sequence(const vector<long long>& egf_coeffs) {",
		"        vector<long long> result(egf_coeffs.size());",
		"        for (int i = 0; i < egf_coeffs.size(); i++) { result[i] = egf_coeffs[i] * egf.fact[i] % EGF::MOD; }",
		"        return result;",
		"    }",
		"",
		"    // 从数列生成EGF系数",
		"    vector<long long> from_sequence(const vector<long long>& seq) {",
		"        vector<long long> result(seq.size());",
		"        for (int i = 0; i < seq.size(); i++) { result[i] = seq[i] * egf.inv_fact[i] % EGF::MOD; }",
		"        return result;",
		"    }",
		"};",
	})
}),

-- 04_Math\Combinatorics\Generating_Functions\OGF.h
s("04_math_combinatorics_generating_functions_ogf_h", {
	t({
		"// 普通生成函数基础结构",
		"struct OGF {",
		"    vector<long long> coeffs;",
		"    static const int MOD = 1e9 + 7;",
		"",
		"    OGF(int size = 0) : coeffs(size, 0) {}",
		"    OGF(const vector<long long>& c) : coeffs(c) {}",
		"",
		"    long long operator[](int n) const { return n < coeffs.size() ? coeffs[n] : 0; }",
		"    long long& operator[](int n) {",
		"        if (n >= coeffs.size()) coeffs.resize(n + 1, 0);",
		"        return coeffs[n];",
		"    }",
		"",
		"    OGF operator+(const OGF& other) const {",
		"        int max_size = max(coeffs.size(), other.coeffs.size());",
		"        OGF result(max_size);",
		"        for (int i = 0; i < max_size; i++) { result.coeffs[i] = ((*this)[i] + other[i]) % MOD; }",
		"        return result;",
		"    }",
		"",
		"    OGF operator*(const OGF& other) const {",
		"        if (coeffs.empty() || other.coeffs.empty()) return OGF();",
		"        int result_size = coeffs.size() + other.coeffs.size() - 1;",
		"        OGF result(result_size);",
		"        for (int i = 0; i < coeffs.size(); i++) {",
		"            for (int j = 0; j < other.coeffs.size(); j++) {",
		"                result.coeffs[i + j] = (result.coeffs[i + j] + coeffs[i] * other.coeffs[j]) % MOD;",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"",
		"    static long long quick_pow(long long base, long long exp) {",
		"        long long result = 1;",
		"        while (exp > 0) {",
		"            if (exp & 1) result = (result * base) % MOD;",
		"            base = (base * base) % MOD;",
		"            exp >>= 1;",
		"        }",
		"        return result;",
		"    }",
		"};  // 常用生成函数生成器",
		"struct OGFGenerator {",
		"    static const int MOD = 1e9 + 7;",
		"",
		"    // 几何级数: 1/(1-x) = 1 + x + x^2 + ...",
		"    static OGF geometric_series(int max_degree) {",
		"        OGF result(max_degree + 1);",
		"        for (int i = 0; i <= max_degree; i++) result[i] = 1;",
		"        return result;",
		"    }",
		"",
		"    // 斐波那契数列生成函数",
		"    static OGF fibonacci(int max_degree) {",
		"        vector<long long> fib(max_degree + 1, 0);",
		"        if (max_degree >= 0) fib[0] = 0;",
		"        if (max_degree >= 1) fib[1] = 1;",
		"        for (int i = 2; i <= max_degree; i++) { fib[i] = (fib[i - 1] + fib[i - 2]) % MOD; }",
		"        return OGF(fib);",
		"    }",
		"",
		"    // 卡特兰数生成函数",
		"    static OGF catalan(int max_degree) {",
		"        vector<long long> cat(max_degree + 1, 0);",
		"        if (max_degree >= 0) cat[0] = 1;",
		"        for (int n = 1; n <= max_degree; n++) {",
		"            for (int i = 0; i < n; i++) { cat[n] = (cat[n] + cat[i] * cat[n - 1 - i]) % MOD; }",
		"        }",
		"        return OGF(cat);",
		"    }",
		"",
		"    // 二项式 (1+x)^n",
		"    static OGF binomial(int n, int max_degree) {",
		"        OGF result(min(n + 1, max_degree + 1));",
		"        long long c = 1;",
		"        for (int k = 0; k <= min(n, max_degree); k++) {",
		"            result[k] = c;",
		"            if (k < n) {",
		"                c = c * (n - k) % MOD;",
		"                c = c * OGF::quick_pow(k + 1, MOD - 2) % MOD;",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"};",
	})
}),

-- 04_Math\Combinatorics\Inclusion_Exclusion\InclusionExclusion.h
s("04_math_combinatorics_inclusion_exclusion_inclusionexclusion_h", {
	t({
		"// 容斥原理基础结构",
		"struct InclusionExclusion {",
		"    static const int MOD = 1e9 + 7;",
		"",
		"    // 错位排列：容斥原理经典应用",
		"    long long derangement(int n) {",
		"        if (n == 0) return 1;",
		"        if (n == 1) return 0;",
		"",
		"        vector<long long> fact(n + 1);",
		"        fact[0] = 1;",
		"        for (int i = 1; i <= n; i++) { fact[i] = fact[i - 1] * i % MOD; }",
		"",
		"        long long result = 0;",
		"        long long sign = 1;",
		"        for (int i = 0; i <= n; i++) {",
		"            result = (result + sign * fact[n - i]) % MOD;",
		"            sign = -sign;",
		"            if (result < 0) result += MOD;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // Möbius函数容斥：计算与给定数互质的数",
		"    long long coprime_count(long long n, const vector<int>& primes) {",
		"        long long result = 0;",
		"        int k = primes.size();",
		"",
		"        for (int mask = 0; mask < (1 << k); mask++) {",
		"            long long product = 1;",
		"            int bit_count = 0;",
		"",
		"            for (int i = 0; i < k; i++) {",
		"                if (mask & (1 << i)) {",
		"                    product *= primes[i];",
		"                    bit_count++;",
		"                }",
		"            }",
		"",
		"            long long contribution = n / product;",
		"            if (bit_count & 1) {",
		"                result -= contribution;",
		"            } else {",
		"                result += contribution;",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"",
		"    static long long quick_pow(long long a, long long b) {",
		"        long long res = 1;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % MOD;",
		"            a = a * a % MOD;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"};  // Min-Max容斥结构",
		"struct MinMaxInclusionExclusion {",
		"    // max(S) = Σ(-1)^(|T|-1) * min(T), T⊆S, T≠∅",
		"    template <typename T>",
		"    static T compute_max(const vector<T>& values) {",
		"        int n = values.size();",
		"        T result = 0;",
		"",
		"        for (int mask = 1; mask < (1 << n); mask++) {",
		"            T min_val = numeric_limits<T>::max();",
		"            for (int i = 0; i < n; i++) {",
		"                if (mask & (1 << i)) { min_val = min(min_val, values[i]); }",
		"            }",
		"",
		"            int bit_count = __builtin_popcount(mask);",
		"            if ((bit_count - 1) & 1) {",
		"                result -= min_val;",
		"            } else {",
		"                result += min_val;",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // min(S) = Σ(-1)^(|T|-1) * max(T), T⊆S, T≠∅",
		"    template <typename T>",
		"    static T compute_min(const vector<T>& values) {",
		"        int n = values.size();",
		"        T result = 0;",
		"",
		"        for (int mask = 1; mask < (1 << n); mask++) {",
		"            T max_val = numeric_limits<T>::min();",
		"            for (int i = 0; i < n; i++) {",
		"                if (mask & (1 << i)) { max_val = max(max_val, values[i]); }",
		"            }",
		"",
		"            int bit_count = __builtin_popcount(mask);",
		"            if ((bit_count - 1) & 1) {",
		"                result -= max_val;",
		"            } else {",
		"                result += max_val;",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// 容斥原理应用示例",
		"struct InclusionExclusionApplications {",
		"    static const int MOD = 1e9 + 7;",
		"",
		"    // 计算满足条件的排列数",
		"    static long long valid_permutations(int n, const vector<pair<int, int>>& forbidden) {",
		"        long long total = 1;",
		"        for (int i = 1; i <= n; i++) total = total * i % MOD;",
		"",
		"        long long forbidden_count = 0;",
		"        int k = forbidden.size();",
		"",
		"        for (int mask = 1; mask < (1 << k); mask++) {",
		"            long long remaining = n;",
		"            for (int i = 0; i < k; i++) {",
		"                if (mask & (1 << i)) remaining--;",
		"            }",
		"",
		"            long long ways = 1;",
		"            for (int i = 1; i <= remaining; i++) { ways = ways * i % MOD; }",
		"",
		"            int bit_count = __builtin_popcount(mask);",
		"            if (bit_count & 1) {",
		"                forbidden_count = (forbidden_count + ways) % MOD;",
		"            } else {",
		"                forbidden_count = (forbidden_count - ways + MOD) % MOD;",
		"            }",
		"        }",
		"",
		"        return (total - forbidden_count + MOD) % MOD;",
		"    }",
		"};",
	})
}),

-- 04_Math\Game_Theory\MiniMax.h
s("04_math_game_theory_minimax_h", {
	t({
		"// 基础极小极大算法",
		"template <typename GameState, typename Move>",
		"struct MiniMax {",
		"    static const int INF = 1e9;",
		"",
		"    struct GameResult {",
		"        int score;",
		"        Move best_move;",
		"        bool has_move;",
		"",
		"        GameResult(int s = 0, Move m = Move(), bool h = false) : score(s), best_move(m), has_move(h) {}",
		"    };",
		"",
		"    // 标准MiniMax算法",
		"    static GameResult minimax(const GameState& state,",
		"                              int depth,",
		"                              bool maximizing,",
		"                              function<bool(const GameState&)> is_terminal,",
		"                              function<int(const GameState&)> evaluate,",
		"                              function<vector<pair<Move, GameState>>(const GameState&)> get_moves) {",
		"        if (depth == 0 || is_terminal(state)) { return GameResult(evaluate(state)); }",
		"",
		"        vector<pair<Move, GameState>> moves = get_moves(state);",
		"        if (moves.empty()) return GameResult(evaluate(state));",
		"",
		"        GameResult result;",
		"        result.has_move = true;",
		"        result.best_move = moves[0].first;",
		"",
		"        if (maximizing) {",
		"            result.score = -INF;",
		"            for (const auto& [move, next_state] : moves) {",
		"                GameResult child = minimax(next_state, depth - 1, false, is_terminal, evaluate, get_moves);",
		"                if (child.score > result.score) {",
		"                    result.score = child.score;",
		"                    result.best_move = move;",
		"                }",
		"            }",
		"        } else {",
		"            result.score = INF;",
		"            for (const auto& [move, next_state] : moves) {",
		"                GameResult child = minimax(next_state, depth - 1, true, is_terminal, evaluate, get_moves);",
		"                if (child.score < result.score) {",
		"                    result.score = child.score;",
		"                    result.best_move = move;",
		"                }",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"};  // Alpha-Beta剪枝算法",
		"template <typename GameState, typename Move>",
		"struct AlphaBeta {",
		"    static const int INF = 1e9;",
		"",
		"    struct GameResult {",
		"        int score;",
		"        Move best_move;",
		"        bool has_move;",
		"",
		"        GameResult(int s = 0, Move m = Move(), bool h = false) : score(s), best_move(m), has_move(h) {}",
		"    };",
		"",
		"    // Alpha-Beta剪枝",
		"    static GameResult alpha_beta(const GameState& state,",
		"                                 int depth,",
		"                                 int alpha,",
		"                                 int beta,",
		"                                 bool maximizing,",
		"                                 function<bool(const GameState&)> is_terminal,",
		"                                 function<int(const GameState&)> evaluate,",
		"                                 function<vector<pair<Move, GameState>>(const GameState&)> get_moves) {",
		"        if (depth == 0 || is_terminal(state)) { return GameResult(evaluate(state)); }",
		"",
		"        vector<pair<Move, GameState>> moves = get_moves(state);",
		"        if (moves.empty()) return GameResult(evaluate(state));",
		"",
		"        GameResult result;",
		"        result.has_move = true;",
		"        result.best_move = moves[0].first;",
		"",
		"        if (maximizing) {",
		"            result.score = -INF;",
		"            for (const auto& [move, next_state] : moves) {",
		"                GameResult child =",
		"                    alpha_beta(next_state, depth - 1, alpha, beta, false, is_terminal, evaluate, get_moves);",
		"                if (child.score > result.score) {",
		"                    result.score = child.score;",
		"                    result.best_move = move;",
		"                }",
		"                alpha = max(alpha, child.score);",
		"                if (beta <= alpha) break;  // Beta剪枝",
		"            }",
		"        } else {",
		"            result.score = INF;",
		"            for (const auto& [move, next_state] : moves) {",
		"                GameResult child =",
		"                    alpha_beta(next_state, depth - 1, alpha, beta, true, is_terminal, evaluate, get_moves);",
		"                if (child.score < result.score) {",
		"                    result.score = child.score;",
		"                    result.best_move = move;",
		"                }",
		"                beta = min(beta, child.score);",
		"                if (beta <= alpha) break;  // Alpha剪枝",
		"            }",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 迭代加深搜索",
		"    static GameResult iterative_deepening(const GameState& state,",
		"                                          int max_depth,",
		"                                          bool maximizing,",
		"                                          function<bool(const GameState&)> is_terminal,",
		"                                          function<int(const GameState&)> evaluate,",
		"                                          function<vector<pair<Move, GameState>>(const GameState&)> get_moves) {",
		"        GameResult best_result;",
		"        for (int depth = 1; depth <= max_depth; depth++) {",
		"            GameResult current = alpha_beta(state, depth, -INF, INF, maximizing, is_terminal, evaluate, get_moves);",
		"            if (current.has_move) best_result = current;",
		"            if (abs(current.score) >= INF / 2) break;  // 找到必胜/必败",
		"        }",
		"        return best_result;",
		"    }",
		"};",
		"",
		"// 井字棋示例应用",
		"struct TicTacToe {",
		"    struct State {",
		"        vector<vector<char>> board;",
		"        char player;",
		"        State() : board(3, vector<char>(3, ' ')), player('X') {}",
		"    };",
		"",
		"    struct Move {",
		"        int row, col;",
		"        Move(int r = -1, int c = -1) : row(r), col(c) {}",
		"        bool operator==(const Move& other) const { return row == other.row && col == other.col; }",
		"    };",
		"",
		"    static bool is_terminal(const State& state) { return get_winner(state) != ' ' || is_full(state); }",
		"",
		"    static int evaluate(const State& state) {",
		"        char winner = get_winner(state);",
		"        if (winner == 'X') return 1;",
		"        if (winner == 'O') return -1;",
		"        return 0;",
		"    }",
		"",
		"    static vector<pair<Move, State>> get_moves(const State& state) {",
		"        vector<pair<Move, State>> moves;",
		"        for (int i = 0; i < 3; i++) {",
		"            for (int j = 0; j < 3; j++) {",
		"                if (state.board[i][j] == ' ') {",
		"                    State next = state;",
		"                    next.board[i][j] = state.player;",
		"                    next.player = (state.player == 'X') ? 'O' : 'X';",
		"                    moves.push_back({Move(i, j), next});",
		"                }",
		"            }",
		"        }",
		"        return moves;",
		"    }",
		"",
		"    static Move get_best_move(const State& state) {",
		"        bool maximizing = (state.player == 'X');",
		"        auto result = AlphaBeta<State, Move>::alpha_beta(state,",
		"                                                         9,",
		"                                                         -AlphaBeta<State, Move>::INF,",
		"                                                         AlphaBeta<State, Move>::INF,",
		"                                                         maximizing,",
		"                                                         is_terminal,",
		"                                                         evaluate,",
		"                                                         get_moves);",
		"        return result.best_move;",
		"    }",
		"",
		"   private:",
		"    static char get_winner(const State& state) {",
		"        const auto& board = state.board;",
		"        // 检查行、列、对角线",
		"        for (int i = 0; i < 3; i++) {",
		"            if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) return board[i][0];",
		"            if (board[0][i] != ' ' && board[0][i] == board[1][i] && board[1][i] == board[2][i]) return board[0][i];",
		"        }",
		"        if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) return board[0][0];",
		"        if (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) return board[0][2];",
		"        return ' ';",
		"    }",
		"",
		"    static bool is_full(const State& state) {",
		"        for (int i = 0; i < 3; i++) {",
		"            for (int j = 0; j < 3; j++) {",
		"                if (state.board[i][j] == ' ') return false;",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"};",
	})
}),

-- 04_Math\Game_Theory\Nim.h
s("04_math_game_theory_nim_h", {
	t({
		"// 基础Nim游戏",
		"struct Nim {",
		"    // 基础Nim游戏判断",
		"    static bool is_winning(const vector<int>& piles) {",
		"        int nim_sum = 0;",
		"        for (int pile : piles) nim_sum ^= pile;",
		"        return nim_sum != 0;",
		"    }",
		"    ",
		"    // 计算Nim和",
		"    static int nim_sum(const vector<int>& piles) {",
		"        int result = 0;",
		"        for (int pile : piles) result ^= pile;",
		"        return result;",
		"    }",
		"    ",
		"    // 找到获胜的移动",
		"    static pair<int, int> find_winning_move(const vector<int>& piles) {",
		"        int current_nim = nim_sum(piles);",
		"        if (current_nim == 0) return {-1, -1}; // 已经是必败态",
		"        ",
		"        for (int i = 0; i < piles.size(); i++) {",
		"            int target = piles[i] ^ current_nim;",
		"            if (target < piles[i]) {",
		"                return {i, piles[i] - target}; // 从第i堆取走指定数量",
		"            }",
		"        }",
		"        return {-1, -1};",
		"    }",
		"};",
		"",
		"// Nim游戏变种",
		"struct NimVariants {",
		"    // 反Nim游戏（最后取完者败）",
		"    static bool is_winning_reverse_nim(const vector<int>& piles) {",
		"        int nim_sum_val = Nim::nim_sum(piles);",
		"        bool all_one = true;",
		"        for (int pile : piles) {",
		"            if (pile > 1) {",
		"                all_one = false;",
		"                break;",
		"            }",
		"        }",
		"        if (all_one) return piles.size() % 2 == 0;",
		"        return nim_sum_val != 0;",
		"    }",
		"    ",
		"    // k-Nim游戏（每次最多取k个）",
		"    static bool is_winning_k_nim(const vector<int>& piles, int k) {",
		"        int result = 0;",
		"        for (int pile : piles) result ^= (pile % (k + 1));",
		"        return result != 0;",
		"    }",
		"    ",
		"    // Wythoff游戏",
		"    static bool is_winning_wythoff(int a, int b) {",
		"        if (a > b) swap(a, b);",
		"        int diff = b - a;",
		"        double golden_ratio = (1.0 + sqrt(5.0)) / 2.0;",
		"        return (int)(diff * golden_ratio) != a;",
		"    }",
		"    ",
		"    // 阶梯游戏",
		"    static int staircase_nim_sum(const vector<int>& steps) {",
		"        int result = 0;",
		"        for (int i = 0; i < steps.size(); i += 2) {",
		"            result ^= steps[i];",
		"        }",
		"        return result;",
		"    }",
		"    ",
		"    // Fibonacci Nim",
		"    static bool is_winning_fibonacci_nim(int n) {",
		"        if (n <= 2) return n != 0;",
		"        ",
		"        vector<int> fib = {1, 2};",
		"        while (fib.back() <= n) {",
		"            fib.push_back(fib[fib.size() - 1] + fib[fib.size() - 2]);",
		"        }",
		"        ",
		"        vector<int> sg(n + 1, 0);",
		"        for (int i = 1; i <= n; i++) {",
		"            set<int> reachable;",
		"            for (int f : fib) {",
		"                if (f > i) break;",
		"                reachable.insert(sg[i - f]);",
		"            }",
		"            ",
		"            int mex = 0;",
		"            while (reachable.count(mex)) mex++;",
		"            sg[i] = mex;",
		"        }",
		"        return sg[n] != 0;",
		"    }",
		"};",
		"",
		"// 多种取法的Nim游戏",
		"struct MultiNim {",
		"    // 计算单堆的Grundy数",
		"    static int calculate_grundy_single_pile(int n, const vector<int>& moves) {",
		"        vector<int> grundy(n + 1, 0);",
		"        ",
		"        for (int i = 1; i <= n; i++) {",
		"            set<int> reachable;",
		"            for (int move : moves) {",
		"                if (i >= move) reachable.insert(grundy[i - move]);",
		"            }",
		"            ",
		"            int mex = 0;",
		"            while (reachable.count(mex)) mex++;",
		"            grundy[i] = mex;",
		"        }",
		"        return grundy[n];",
		"    }",
		"    ",
		"    // Multi-Nim（有多种取法的Nim）",
		"    static bool is_winning_multi_nim(const vector<int>& piles, const vector<int>& allowed_moves) {",
		"        int result = 0;",
		"        for (int pile : piles) {",
		"            result ^= calculate_grundy_single_pile(pile, allowed_moves);",
		"        }",
		"        return result != 0;",
		"    }",
		"    ",
		"    // 获取获胜移动",
		"    static tuple<int, int, int> find_winning_move(const vector<int>& piles, const vector<int>& allowed_moves) {",
		"        vector<int> grundy_values;",
		"        for (int pile : piles) {",
		"            grundy_values.push_back(calculate_grundy_single_pile(pile, allowed_moves));",
		"        }",
		"        ",
		"        int xor_sum = 0;",
		"        for (int g : grundy_values) xor_sum ^= g;",
		"        ",
		"        if (xor_sum == 0) return {-1, -1, -1}; // 必败态",
		"        ",
		"        for (int i = 0; i < piles.size(); i++) {",
		"            int target_grundy = grundy_values[i] ^ xor_sum;",
		"            ",
		"            // 找到能使该堆达到目标Grundy值的移动",
		"            for (int move : allowed_moves) {",
		"                if (piles[i] >= move) {",
		"                    int new_pile = piles[i] - move;",
		"                    if (calculate_grundy_single_pile(new_pile, allowed_moves) == target_grundy) {",
		"                        return {i, move, new_pile};",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        return {-1, -1, -1};",
		"    }",
		"};",
	})
}),

-- 04_Math\Game_Theory\SG.h
s("04_math_game_theory_sg_h", {
	t({
		"// 基础SG函数",
		"struct SG {",
		"    // 计算MEX（最小排斥数）",
		"    static int calculate_mex(const set<int>& s) {",
		"        int mex = 0;",
		"        while (s.count(mex)) mex++;",
		"        return mex;",
		"    }",
		"    ",
		"    // 动态规划计算SG函数值",
		"    static vector<int> calculate_sg_dp(int max_state, const function<vector<int>(int)>& get_next_states) {",
		"        vector<int> sg(max_state + 1, 0);",
		"        ",
		"        for (int state = 0; state <= max_state; state++) {",
		"            set<int> reachable;",
		"            vector<int> next_states = get_next_states(state);",
		"            ",
		"            for (int next : next_states) {",
		"                if (next >= 0 && next <= max_state) reachable.insert(sg[next]);",
		"            }",
		"            sg[state] = calculate_mex(reachable);",
		"        }",
		"        return sg;",
		"    }",
		"    ",
		"    // 记忆化搜索计算SG函数值",
		"    static int calculate_sg_memo(int state, const function<vector<int>(int)>& get_next_states, ",
		"                               unordered_map<int, int>& memo) {",
		"        if (memo.count(state)) return memo[state];",
		"        ",
		"        set<int> reachable;",
		"        vector<int> next_states = get_next_states(state);",
		"        ",
		"        for (int next : next_states) {",
		"            reachable.insert(calculate_sg_memo(next, get_next_states, memo));",
		"        }",
		"        return memo[state] = calculate_mex(reachable);",
		"    }",
		"    ",
		"    // 组合游戏的SG值（多个独立子游戏）",
		"    static int combined_sg(const vector<int>& sg_values) {",
		"        int result = 0;",
		"        for (int sg : sg_values) result ^= sg;",
		"        return result;",
		"    }",
		"    ",
		"    // 判断当前位置是否为胜利位置",
		"    static bool is_winning_position(const vector<int>& sg_values) {",
		"        return combined_sg(sg_values) != 0;",
		"    }",
		"};",
		"",
		"// 经典SG游戏",
		"struct SGGames {",
		"    // Subtraction游戏的SG函数",
		"    static vector<int> subtraction_game_sg(const vector<int>& subtraction_set, int max_n) {",
		"        vector<int> sg(max_n + 1, 0);",
		"        ",
		"        for (int i = 1; i <= max_n; i++) {",
		"            set<int> reachable;",
		"            for (int sub : subtraction_set) {",
		"                if (i >= sub) reachable.insert(sg[i - sub]);",
		"            }",
		"            sg[i] = SG::calculate_mex(reachable);",
		"        }",
		"        return sg;",
		"    }",
		"    ",
		"    // Dawson's Chess游戏",
		"    static vector<int> dawson_chess_sg(int max_n) {",
		"        vector<int> sg(max_n + 1, 0);",
		"        ",
		"        for (int i = 2; i <= max_n; i++) {",
		"            set<int> reachable;",
		"            ",
		"            // 可以在任意位置放置一个棋子，将区间分割",
		"            for (int j = 0; j < i; j++) {",
		"                int left = j;",
		"                int right = i - j - 1;",
		"                reachable.insert(sg[left] ^ sg[right]);",
		"            }",
		"            sg[i] = SG::calculate_mex(reachable);",
		"        }",
		"        return sg;",
		"    }",
		"    ",
		"    // Kayles游戏的SG函数",
		"    static vector<int> kayles_sg(int max_n) {",
		"        vector<int> sg(max_n + 1, 0);",
		"        ",
		"        for (int i = 1; i <= max_n; i++) {",
		"            set<int> reachable;",
		"            ",
		"            // 移除一个pin",
		"            for (int j = 0; j < i; j++) {",
		"                int left = j;",
		"                int right = i - j - 1;",
		"                reachable.insert(sg[left] ^ sg[right]);",
		"            }",
		"            ",
		"            // 移除相邻的两个pins",
		"            for (int j = 0; j < i - 1; j++) {",
		"                int left = j;",
		"                int right = i - j - 2;",
		"                reachable.insert(sg[left] ^ sg[right]);",
		"            }",
		"            sg[i] = SG::calculate_mex(reachable);",
		"        }",
		"        return sg;",
		"    }",
		"    ",
		"    // Green Hackenbush的SG函数（树上博弈）",
		"    static int green_hackenbush_sg(const vector<vector<int>>& tree, int root) {",
		"        function<int(int, int)> dfs = [&](int u, int parent) -> int {",
		"            int sg = 0;",
		"            for (int v : tree[u]) {",
		"                if (v != parent) sg ^= (dfs(v, u) + 1);",
		"            }",
		"            return sg;",
		"        };",
		"        return dfs(root, -1);",
		"    }",
		"    ",
		"    // 翻硬币游戏",
		"    static int coin_flipping_sg(const vector<bool>& coins) {",
		"        int n = coins.size();",
		"        int sg = 0;",
		"        ",
		"        // 找出所有正面朝上的硬币位置",
		"        vector<int> heads;",
		"        for (int i = 0; i < n; i++) {",
		"            if (coins[i]) heads.push_back(i);",
		"        }",
		"        ",
		"        // 计算相邻正面硬币之间的距离",
		"        for (int i = 0; i < heads.size(); i += 2) {",
		"            if (i + 1 < heads.size()) {",
		"                int distance = heads[i + 1] - heads[i] - 1;",
		"                sg ^= distance;",
		"            }",
		"        }",
		"        return sg;",
		"    }",
		"};",
		"",
		"// 两堆石子游戏",
		"struct TwoPileGame {",
		"    map<pair<int, int>, int> memo;",
		"    function<vector<pair<int, int>>(int, int)> get_moves;",
		"    ",
		"    TwoPileGame(const function<vector<pair<int, int>>(int, int)>& moves) : get_moves(moves) {}",
		"    ",
		"    int calculate_sg(int a, int b) {",
		"        if (a > b) swap(a, b);",
		"        pair<int, int> state = {a, b};",
		"        ",
		"        if (memo.count(state)) return memo[state];",
		"        ",
		"        set<int> reachable;",
		"        vector<pair<int, int>> next_states = get_moves(a, b);",
		"        ",
		"        for (auto [na, nb] : next_states) {",
		"            if (na >= 0 && nb >= 0) reachable.insert(calculate_sg(na, nb));",
		"        }",
		"        return memo[state] = SG::calculate_mex(reachable);",
		"    }",
		"    ",
		"    // Wythoff游戏的移动",
		"    static vector<pair<int, int>> wythoff_moves(int a, int b) {",
		"        vector<pair<int, int>> moves;",
		"        ",
		"        // 从第一堆取任意个",
		"        for (int i = 1; i <= a; i++) moves.push_back({a - i, b});",
		"        ",
		"        // 从第二堆取任意个",
		"        for (int i = 1; i <= b; i++) moves.push_back({a, b - i});",
		"        ",
		"        // 从两堆取相同个数",
		"        for (int i = 1; i <= min(a, b); i++) moves.push_back({a - i, b - i});",
		"        ",
		"        return moves;",
		"    }",
		"};",
	})
}),

-- 04_Math\Linear_Algebra\GaussianElimination.h
s("04_math_linear_algebra_gaussianelimination_h", {
	t({
		"using ll = long long;",
		"",
		"// 实数高斯消元",
		"struct RealGauss {",
		"    static constexpr double EPS = 1e-9;",
		"    ",
		"    // 求解线性方程组 Ax = b，返回值：0-无解，1-唯一解，2-无穷多解",
		"    int solve(vector<vector<double>>& A, vector<double>& b, vector<double>& x) {",
		"        int n = A.size(), m = A[0].size();",
		"        vector<vector<double>> aug(n, vector<double>(m + 1));",
		"        ",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) aug[i][j] = A[i][j];",
		"            aug[i][m] = b[i];",
		"        }",
		"        ",
		"        vector<int> pivot_col(n, -1);",
		"        int rank = 0;",
		"        ",
		"        for (int col = 0; col < m && rank < n; col++) {",
		"            int pivot_row = -1;",
		"            for (int row = rank; row < n; row++) {",
		"                if (abs(aug[row][col]) > EPS) {",
		"                    if (pivot_row == -1 || abs(aug[row][col]) > abs(aug[pivot_row][col])) ",
		"                        pivot_row = row;",
		"                }",
		"            }",
		"            ",
		"            if (pivot_row == -1) continue;",
		"            if (pivot_row != rank) swap(aug[rank], aug[pivot_row]);",
		"            ",
		"            pivot_col[rank] = col;",
		"            for (int row = 0; row < n; row++) {",
		"                if (row != rank && abs(aug[row][col]) > EPS) {",
		"                    double factor = aug[row][col] / aug[rank][col];",
		"                    for (int j = col; j <= m; j++) aug[row][j] -= factor * aug[rank][j];",
		"                }",
		"            }",
		"            rank++;",
		"        }",
		"        ",
		"        for (int i = rank; i < n; i++) {",
		"            if (abs(aug[i][m]) > EPS) return 0;",
		"        }",
		"        ",
		"        x.assign(m, 0);",
		"        for (int i = rank - 1; i >= 0; i--) {",
		"            if (pivot_col[i] != -1) x[pivot_col[i]] = aug[i][m] / aug[i][pivot_col[i]];",
		"        }",
		"        ",
		"        return rank == m ? 1 : 2;",
		"    }",
		"    ",
		"    // 计算矩阵的秩",
		"    int rank(vector<vector<double>>& A) {",
		"        int n = A.size(), m = A[0].size();",
		"        vector<vector<double>> mat = A;",
		"        int rank = 0;",
		"        ",
		"        for (int col = 0; col < m && rank < n; col++) {",
		"            int pivot_row = -1;",
		"            for (int row = rank; row < n; row++) {",
		"                if (abs(mat[row][col]) > EPS) {",
		"                    if (pivot_row == -1 || abs(mat[row][col]) > abs(mat[pivot_row][col]))",
		"                        pivot_row = row;",
		"                }",
		"            }",
		"            ",
		"            if (pivot_row == -1) continue;",
		"            if (pivot_row != rank) swap(mat[rank], mat[pivot_row]);",
		"            ",
		"            for (int row = rank + 1; row < n; row++) {",
		"                if (abs(mat[row][col]) > EPS) {",
		"                    double factor = mat[row][col] / mat[rank][col];",
		"                    for (int j = col; j < m; j++) mat[row][j] -= factor * mat[rank][j];",
		"                }",
		"            }",
		"            rank++;",
		"        }",
		"        ",
		"        return rank;",
		"    }",
		"};",
		"",
		"// 模运算高斯消元",
		"struct ModGauss {",
		"    static constexpr ll MOD = 1e9 + 7;",
		"    ",
		"    ll power(ll a, ll b) {",
		"        ll res = 1;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % MOD;",
		"            a = a * a % MOD;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    ll inv(ll a) { return power(a, MOD - 2); }",
		"    ",
		"    // 求解模运算线性方程组",
		"    int solve(vector<vector<ll>>& A, vector<ll>& b, vector<ll>& x) {",
		"        int n = A.size(), m = A[0].size();",
		"        vector<vector<ll>> aug(n, vector<ll>(m + 1));",
		"        ",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) aug[i][j] = ((A[i][j] % MOD) + MOD) % MOD;",
		"            aug[i][m] = ((b[i] % MOD) + MOD) % MOD;",
		"        }",
		"        ",
		"        vector<int> pivot_col(n, -1);",
		"        int rank = 0;",
		"        ",
		"        for (int col = 0; col < m && rank < n; col++) {",
		"            int pivot_row = -1;",
		"            for (int row = rank; row < n; row++) {",
		"                if (aug[row][col] != 0) {",
		"                    pivot_row = row;",
		"                    break;",
		"                }",
		"            }",
		"            ",
		"            if (pivot_row == -1) continue;",
		"            if (pivot_row != rank) swap(aug[rank], aug[pivot_row]);",
		"            ",
		"            pivot_col[rank] = col;",
		"            ll inv_pivot = inv(aug[rank][col]);",
		"            for (int row = 0; row < n; row++) {",
		"                if (row != rank && aug[row][col] != 0) {",
		"                    ll factor = aug[row][col] * inv_pivot % MOD;",
		"                    for (int j = col; j <= m; j++) {",
		"                        aug[row][j] = (aug[row][j] - factor * aug[rank][j] % MOD + MOD) % MOD;",
		"                    }",
		"                }",
		"            }",
		"            rank++;",
		"        }",
		"        ",
		"        for (int i = rank; i < n; i++) {",
		"            if (aug[i][m] != 0) return 0;",
		"        }",
		"        ",
		"        x.assign(m, 0);",
		"        for (int i = rank - 1; i >= 0; i--) {",
		"            if (pivot_col[i] != -1) x[pivot_col[i]] = aug[i][m] * inv(aug[i][pivot_col[i]]) % MOD;",
		"        }",
		"        ",
		"        return rank == m ? 1 : 2;",
		"    }",
		"};",
		"",
		"// 矩阵求逆",
		"struct MatrixInverse {",
		"    static constexpr double EPS = 1e-9;",
		"    ",
		"    // 求矩阵的逆",
		"    bool inverse(vector<vector<double>>& A, vector<vector<double>>& inv_A) {",
		"        int n = A.size();",
		"        if (A[0].size() != n) return false;",
		"        ",
		"        vector<vector<double>> aug(n, vector<double>(2 * n));",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < n; j++) {",
		"                aug[i][j] = A[i][j];",
		"                aug[i][j + n] = (i == j) ? 1 : 0;",
		"            }",
		"        }",
		"        ",
		"        for (int i = 0; i < n; i++) {",
		"            int pivot = -1;",
		"            for (int j = i; j < n; j++) {",
		"                if (abs(aug[j][i]) > EPS) {",
		"                    if (pivot == -1 || abs(aug[j][i]) > abs(aug[pivot][i])) pivot = j;",
		"                }",
		"            }",
		"            ",
		"            if (pivot == -1) return false;",
		"            if (pivot != i) swap(aug[i], aug[pivot]);",
		"            ",
		"            double pivot_val = aug[i][i];",
		"            for (int j = 0; j < 2 * n; j++) aug[i][j] /= pivot_val;",
		"            ",
		"            for (int j = 0; j < n; j++) {",
		"                if (j != i && abs(aug[j][i]) > EPS) {",
		"                    double factor = aug[j][i];",
		"                    for (int k = 0; k < 2 * n; k++) aug[j][k] -= factor * aug[i][k];",
		"                }",
		"            }",
		"        }",
		"        ",
		"        inv_A.assign(n, vector<double>(n));",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < n; j++) inv_A[i][j] = aug[i][j + n];",
		"        }",
		"        ",
		"        return true;",
		"    }",
		"};",
		"",
	})
}),

-- 04_Math\Linear_Algebra\LinearSystem2D.h
s("04_math_linear_algebra_linearsystem2d_h", {
	t({
		"using ll = long long;",
		"",
		"// 二元一次方程组求解器",
		"struct LinearSystem2D {",
		"    // 求解二元一次方程组",
		"    // a1*x + b1*y = c1",
		"    // a2*x + b2*y = c2",
		"    struct Solution {",
		"        bool has_solution;",
		"        bool unique;",
		"        double x, y;  // 唯一解的情况",
		"        // 对于无穷解的情况，可以用参数方程表示",
		"    };",
		"",
		"    Solution solve(double a1, double b1, double c1, double a2, double b2, double c2) {",
		"        Solution result;",
		"",
		"        // 计算行列式",
		"        double det = a1 * b2 - a2 * b1;",
		"",
		"        if (abs(det) < 1e-9) {  // 行列式为0",
		"            // 检查是否有解",
		"            if (abs(a1 * c2 - a2 * c1) < 1e-9 && abs(b1 * c2 - b2 * c1) < 1e-9) {",
		"                result.has_solution = true;",
		"                result.unique = false;  // 无穷多解",
		"            } else {",
		"                result.has_solution = false;  // 无解",
		"            }",
		"        } else {  // 有唯一解",
		"            result.has_solution = true;",
		"            result.unique = true;",
		"            result.x = (c1 * b2 - c2 * b1) / det;",
		"            result.y = (a1 * c2 - a2 * c1) / det;",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 整数版本（使用分数避免精度问题）",
		"    struct Fraction {",
		"        ll num, den;",
		"        Fraction(ll n = 0, ll d = 1) : num(n), den(d) {",
		"            if (den < 0) {",
		"                num = -num;",
		"                den = -den;",
		"            }",
		"            ll g = gcd(abs(num), abs(den));",
		"            num /= g;",
		"            den /= g;",
		"        }",
		"",
		"        Fraction operator+(const Fraction& other) const {",
		"            return Fraction(num * other.den + other.num * den, den * other.den);",
		"        }",
		"",
		"        Fraction operator-(const Fraction& other) const {",
		"            return Fraction(num * other.den - other.num * den, den * other.den);",
		"        }",
		"",
		"        Fraction operator*(const Fraction& other) const { return Fraction(num * other.num, den * other.den); }",
		"",
		"        Fraction operator/(const Fraction& other) const { return Fraction(num * other.den, den * other.num); }",
		"",
		"        bool is_zero() const { return num == 0; }",
		"",
		"        double to_double() const { return (double)num / den; }",
		"    };",
		"",
		"    struct IntSolution {",
		"        bool has_solution;",
		"        bool unique;",
		"        Fraction x, y;",
		"    };",
		"",
		"    IntSolution solve_int(ll a1, ll b1, ll c1, ll a2, ll b2, ll c2) {",
		"        IntSolution result;",
		"",
		"        // 计算行列式",
		"        ll det = a1 * b2 - a2 * b1;",
		"",
		"        if (det == 0) {",
		"            // 检查是否有解",
		"            if (a1 * c2 == a2 * c1 && b1 * c2 == b2 * c1) {",
		"                result.has_solution = true;",
		"                result.unique = false;",
		"            } else {",
		"                result.has_solution = false;",
		"            }",
		"        } else {",
		"            result.has_solution = true;",
		"            result.unique = true;",
		"            result.x = Fraction(c1 * b2 - c2 * b1, det);",
		"            result.y = Fraction(a1 * c2 - a2 * c1, det);",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
		"",
		"// 二元一次方程组整数解求解器",
		"struct LinearSystem2DInt {",
		"    struct IntSolution {",
		"        bool has_solution;",
		"        bool unique;",
		"        ll x, y;  // 整数解",
		"    };",
		"",
		"    IntSolution solve_int_only(ll a1, ll b1, ll c1, ll a2, ll b2, ll c2) {",
		"        IntSolution result;",
		"        result.has_solution = false;",
		"        result.unique = false;",
		"",
		"        // 计算行列式",
		"        ll det = a1 * b2 - a2 * b1;",
		"",
		"        if (det == 0) {",
		"            // 系数矩阵奇异，需要特殊处理",
		"            // 这里先简单返回无解",
		"            return result;",
		"        }",
		"",
		"        // 计算解的分子",
		"        ll x_num = c1 * b2 - c2 * b1;",
		"        ll y_num = a1 * c2 - a2 * c1;",
		"",
		"        // 检查是否能整除（即解是否为整数）",
		"        if (x_num % det == 0 && y_num % det == 0) {",
		"            result.has_solution = true;",
		"            result.unique = true;",
		"            result.x = x_num / det;",
		"            result.y = y_num / det;",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
	})
}),

-- 04_Math\Linear_Algebra\Matrix.h
s("04_math_linear_algebra_matrix_h", {
	t({
		"using ll = long long;",
		"",
		"// 基础矩阵运算",
		"struct Matrix {",
		"    static constexpr ll MOD = 1e9 + 7;",
		"    int n, m;",
		"    vector<vector<ll>> a;",
		"    ",
		"    Matrix(int r = 0, int c = 0) : n(r), m(c), a(r, vector<ll>(c, 0)) {}",
		"    Matrix(vector<vector<ll>>& mat) : n(mat.size()), m(mat.size() ? mat[0].size() : 0), a(mat) {}",
		"    ",
		"    vector<ll>& operator[](int i) { return a[i]; }",
		"    const vector<ll>& operator[](int i) const { return a[i]; }",
		"    ",
		"    Matrix operator+(const Matrix& b) const {",
		"        Matrix res(n, m);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) res[i][j] = (a[i][j] + b[i][j]) % MOD;",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    Matrix operator-(const Matrix& b) const {",
		"        Matrix res(n, m);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) res[i][j] = (a[i][j] - b[i][j] + MOD) % MOD;",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    Matrix operator*(const Matrix& b) const {",
		"        Matrix res(n, b.m);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < b.m; j++) {",
		"                for (int k = 0; k < m; k++) res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;",
		"            }",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    Matrix power(ll k) const {",
		"        Matrix res = identity(n), base = *this;",
		"        while (k > 0) {",
		"            if (k & 1) res = res * base;",
		"            base = base * base;",
		"            k >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    static Matrix identity(int sz) {",
		"        Matrix res(sz, sz);",
		"        for (int i = 0; i < sz; i++) res[i][i] = 1;",
		"        return res;",
		"    }",
		"    ",
		"    Matrix transpose() const {",
		"        Matrix res(m, n);",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) res[j][i] = a[i][j];",
		"        }",
		"        return res;",
		"    }",
		"};",
		"",
		"// 矩阵行列式和逆",
		"struct MatrixDet {",
		"    static constexpr ll MOD = 1e9 + 7;",
		"    ",
		"    ll power(ll a, ll b) {",
		"        ll res = 1;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % MOD;",
		"            a = a * a % MOD;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    ll inv(ll a) { return power(a, MOD - 2); }",
		"    ",
		"    // 计算行列式",
		"    ll determinant(vector<vector<ll>> a) {",
		"        int n = a.size();",
		"        ll det = 1;",
		"        ",
		"        for (int i = 0; i < n; i++) {",
		"            int pivot = -1;",
		"            for (int j = i; j < n; j++) {",
		"                if (a[j][i] != 0) {",
		"                    pivot = j;",
		"                    break;",
		"                }",
		"            }",
		"            ",
		"            if (pivot == -1) return 0;",
		"            ",
		"            if (pivot != i) {",
		"                swap(a[i], a[pivot]);",
		"                det = (MOD - det) % MOD;",
		"            }",
		"            ",
		"            det = det * a[i][i] % MOD;",
		"            ll inv_pivot = inv(a[i][i]);",
		"            ",
		"            for (int j = i + 1; j < n; j++) {",
		"                if (a[j][i] != 0) {",
		"                    ll factor = a[j][i] * inv_pivot % MOD;",
		"                    for (int k = i; k < n; k++) {",
		"                        a[j][k] = (a[j][k] - factor * a[i][k] % MOD + MOD) % MOD;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"        ",
		"        return det;",
		"    }",
		"    ",
		"    // 计算矩阵的秩",
		"    int rank(vector<vector<ll>> a) {",
		"        int n = a.size(), m = a[0].size();",
		"        int rank = 0;",
		"        ",
		"        for (int col = 0; col < m && rank < n; col++) {",
		"            int pivot = -1;",
		"            for (int row = rank; row < n; row++) {",
		"                if (a[row][col] != 0) {",
		"                    pivot = row;",
		"                    break;",
		"                }",
		"            }",
		"            ",
		"            if (pivot == -1) continue;",
		"            if (pivot != rank) swap(a[rank], a[pivot]);",
		"            ",
		"            ll inv_pivot = inv(a[rank][col]);",
		"            for (int row = rank + 1; row < n; row++) {",
		"                if (a[row][col] != 0) {",
		"                    ll factor = a[row][col] * inv_pivot % MOD;",
		"                    for (int j = col; j < m; j++) {",
		"                        a[row][j] = (a[row][j] - factor * a[rank][j] % MOD + MOD) % MOD;",
		"                    }",
		"                }",
		"            }",
		"            rank++;",
		"        }",
		"        ",
		"        return rank;",
		"    }",
		"};",
		"",
		"// 矩阵特殊操作",
		"struct MatrixOps {",
		"    // 检查对称矩阵",
		"    bool isSymmetric(const vector<vector<ll>>& a) {",
		"        int n = a.size();",
		"        if (a[0].size() != n) return false;",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < n; j++) {",
		"                if (a[i][j] != a[j][i]) return false;",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"    ",
		"    // 检查上三角矩阵",
		"    bool isUpperTriangular(const vector<vector<ll>>& a) {",
		"        int n = a.size();",
		"        if (a[0].size() != n) return false;",
		"        for (int i = 1; i < n; i++) {",
		"            for (int j = 0; j < i; j++) {",
		"                if (a[i][j] != 0) return false;",
		"            }",
		"        }",
		"        return true;",
		"    }",
		"    ",
		"    // 矩阵的迹",
		"    ll trace(const vector<vector<ll>>& a) {",
		"        ll res = 0;",
		"        int n = a.size();",
		"        for (int i = 0; i < n; i++) res = (res + a[i][i]) % Matrix::MOD;",
		"        return res;",
		"    }",
		"    ",
		"    // 生成随机矩阵",
		"    Matrix random(int n, int m, ll maxVal = 100) {",
		"        Matrix res(n, m);",
		"        srand(time(nullptr));",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = 0; j < m; j++) res[i][j] = rand() % maxVal;",
		"        }",
		"        return res;",
		"    }",
		"};",
		"",
		"",
	})
}),

-- 04_Math\Number_Theory\Advanced\MobiusFunction.h
s("04_math_number_theory_advanced_mobiusfunction_h", {
	t({
		"// 莫比乌斯函数与相关应用",
		"template <typename T = int>",
		"struct MobiusFunction {",
		"    vector<T> mu, primes;",
		"    vector<bool> is_prime;",
		"    vector<T> phi;  // 欧拉函数",
		"    int n;",
		"",
		"    MobiusFunction(int _n) : n(_n) {",
		"        mu.resize(n + 1);",
		"        phi.resize(n + 1);",
		"        is_prime.resize(n + 1, true);",
		"        calculate_mobius();",
		"    }",
		"",
		"    // 线性筛计算莫比乌斯函数",
		"    void calculate_mobius() {",
		"        mu[1] = phi[1] = 1;",
		"        is_prime[0] = is_prime[1] = false;",
		"",
		"        for (int i = 2; i <= n; i++) {",
		"            if (is_prime[i]) {",
		"                primes.push_back(i);",
		"                mu[i] = -1;",
		"                phi[i] = i - 1;",
		"            }",
		"",
		"            for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {",
		"                int next = i * primes[j];",
		"                is_prime[next] = false;",
		"",
		"                if (i % primes[j] == 0) {",
		"                    mu[next] = 0;",
		"                    phi[next] = phi[i] * primes[j];",
		"                    break;",
		"                } else {",
		"                    mu[next] = -mu[i];",
		"                    phi[next] = phi[i] * (primes[j] - 1);",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    // 获取莫比乌斯函数值",
		"    T get_mu(int x) { return x <= n ? mu[x] : calculate_single_mu(x); }",
		"",
		"    // 计算单个数的莫比乌斯函数值",
		"    T calculate_single_mu(long long x) {",
		"        if (x == 1) return 1;",
		"",
		"        int cnt = 0;",
		"        for (long long i = 2; i * i <= x; i++) {",
		"            if (x % i == 0) {",
		"                cnt++;",
		"                x /= i;",
		"                if (x % i == 0) return 0;  // 有平方因子",
		"            }",
		"        }",
		"        if (x > 1) cnt++;",
		"",
		"        return (cnt & 1) ? -1 : 1;",
		"    }",
		"",
		"    // 莫比乌斯函数前缀和（杜教筛）",
		"    map<long long, long long> mu_sum_cache;",
		"",
		"    long long mu_sum(long long x) {",
		"        if (x <= n) {",
		"            long long res = 0;",
		"            for (int i = 1; i <= x; i++) { res += mu[i]; }",
		"            return res;",
		"        }",
		"",
		"        if (mu_sum_cache.count(x)) { return mu_sum_cache[x]; }",
		"",
		"        long long res = 1;  // mu[1] = 1",
		"        for (long long i = 2, j; i <= x; i = j + 1) {",
		"            j = x / (x / i);",
		"            res -= (j - i + 1) * mu_sum(x / i);",
		"        }",
		"",
		"        return mu_sum_cache[x] = res;",
		"    }",
		"",
		"    // 欧拉函数前缀和（杜教筛）",
		"    map<long long, long long> phi_sum_cache;",
		"",
		"    long long phi_sum(long long x) {",
		"        if (x <= n) {",
		"            long long res = 0;",
		"            for (int i = 1; i <= x; i++) { res += phi[i]; }",
		"            return res;",
		"        }",
		"",
		"        if (phi_sum_cache.count(x)) { return phi_sum_cache[x]; }",
		"",
		"        long long res = x * (x + 1) / 2;",
		"        for (long long i = 2, j; i <= x; i = j + 1) {",
		"            j = x / (x / i);",
		"            res -= (j - i + 1) * phi_sum(x / i);",
		"        }",
		"",
		"        return phi_sum_cache[x] = res;",
		"    }",
		"",
		"    // 计算gcd(i,n)=1的i的个数（1<=i<=m）",
		"    long long count_coprime(long long m, long long n) {",
		"        if (m == 0) return 0;",
		"        if (n == 1) return m;",
		"",
		"        vector<long long> factors;",
		"        long long temp = n;",
		"        for (long long i = 2; i * i <= temp; i++) {",
		"            if (temp % i == 0) {",
		"                factors.push_back(i);",
		"                while (temp % i == 0) temp /= i;",
		"            }",
		"        }",
		"        if (temp > 1) factors.push_back(temp);",
		"",
		"        long long res = 0;",
		"        int sz = factors.size();",
		"",
		"        // 容斥原理",
		"        for (int mask = 0; mask < (1 << sz); mask++) {",
		"            long long prod = 1;",
		"            int bits = 0;",
		"",
		"            for (int i = 0; i < sz; i++) {",
		"                if (mask & (1 << i)) {",
		"                    prod *= factors[i];",
		"                    bits++;",
		"                }",
		"            }",
		"",
		"            if (bits & 1) {",
		"                res -= m / prod;",
		"            } else {",
		"                res += m / prod;",
		"            }",
		"        }",
		"",
		"        return res;",
		"    }",
		"",
		"    // 莫比乌斯反演求解经典问题",
		"    // 求sum_{i=1}^n sum_{j=1}^m [gcd(i,j)=1]",
		"    long long count_coprime_pairs(long long n, long long m) {",
		"        if (n > m) swap(n, m);",
		"        long long res = 0;",
		"",
		"        for (int d = 1; d <= n; d++) { res += mu[d] * (n / d) * (m / d); }",
		"",
		"        return res;",
		"    }",
		"",
		"    // 求sum_{i=1}^n sum_{j=1}^m gcd(i,j)",
		"    long long sum_gcd(long long n, long long m) {",
		"        if (n > m) swap(n, m);",
		"        long long res = 0;",
		"",
		"        for (int d = 1; d <= n; d++) { res += d * phi[d] * (n / d) * (m / d); }",
		"",
		"        return res;",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"MobiusFunction<int> mf(100000);",
		"cout << mf.get_mu(30) << endl; // 输出-1",
		"cout << mf.mu_sum(100) << endl; // 输出莫比乌斯函数前100项和",
		"cout << mf.count_coprime_pairs(100, 100) << endl; // 计算互质对数",
		"*/",
	})
}),

-- 04_Math\Number_Theory\Advanced\PrimitiveRoot.h
s("04_math_number_theory_advanced_primitiveroot_h", {
	t({
		"using ll = long long;",
		"",
		"struct PrimitiveRoot {",
		"    ll power(ll a, ll b, ll m) {",
		"        ll res = 1;",
		"        a %= m;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % m;",
		"            a = a * a % m;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }",
		"",
		"    vector<ll> factorize(ll n) {",
		"        vector<ll> factors;",
		"        for (ll i = 2; i * i <= n; i++) {",
		"            if (n % i == 0) {",
		"                factors.push_back(i);",
		"                while (n % i == 0) n /= i;",
		"            }",
		"        }",
		"        if (n > 1) factors.push_back(n);",
		"        return factors;",
		"    }",
		"",
		"    ll euler_phi(ll n) {",
		"        ll res = n;",
		"        for (ll i = 2; i * i <= n; i++) {",
		"            if (n % i == 0) {",
		"                while (n % i == 0) n /= i;",
		"                res -= res / i;",
		"            }",
		"        }",
		"        if (n > 1) res -= res / n;",
		"        return res;",
		"    }",
		"",
		"    bool is_primitive_root(ll g, ll m) {",
		"        if (gcd(g, m) != 1) return false;",
		"        ll phi = euler_phi(m);",
		"        vector<ll> factors = factorize(phi);",
		"        for (ll factor : factors) {",
		"            if (power(g, phi / factor, m) == 1) return false;",
		"        }",
		"        return true;",
		"    }",
		"",
		"    ll find_primitive_root(ll m) {",
		"        if (m == 1) return 0;",
		"        if (m == 2) return 1;",
		"        if (m == 4) return 3;",
		"",
		"        for (ll g = 1; g < m; g++) {",
		"            if (is_primitive_root(g, m)) return g;",
		"        }",
		"        return -1;",
		"    }",
		"",
		"    vector<ll> all_primitive_roots(ll m) {",
		"        vector<ll> roots;",
		"        ll g = find_primitive_root(m);",
		"        if (g == -1) return roots;",
		"",
		"        ll phi = euler_phi(m);",
		"        for (ll i = 1; i < phi; i++) {",
		"            if (gcd(i, phi) == 1) {",
		"                roots.push_back(power(g, i, m));",
		"            }",
		"        }",
		"        sort(roots.begin(), roots.end());",
		"        return roots;",
		"    }",
		"};",
	})
}),

-- 04_Math\Number_Theory\Advanced\QuadraticResidue.h
s("04_math_number_theory_advanced_quadraticresidue_h", {
	t({
		"using ll = long long;",
		"",
		"struct QuadraticResidue {",
		"    ll power(ll a, ll b, ll p) {",
		"        ll res = 1;",
		"        a %= p;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % p;",
		"            a = a * a % p;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    ll legendre(ll a, ll p) { return power(a, (p - 1) / 2, p); }",
		"",
		"    bool is_residue(ll a, ll p) {",
		"        if (p == 2) return true;",
		"        return legendre(a, p) == 1;",
		"    }",
		"",
		"    ll solve(ll n, ll p) {",
		"        if (p == 2) return n % 2;",
		"        if (legendre(n, p) != 1) return -1;",
		"",
		"        if (p % 4 == 3) return power(n, (p + 1) / 4, p);",
		"",
		"        ll s = 0, q = p - 1;",
		"        while (q % 2 == 0) {",
		"            q /= 2;",
		"            s++;",
		"        }",
		"",
		"        ll z = 2;",
		"        while (legendre(z, p) != p - 1) z++;",
		"",
		"        ll m = s, c = power(z, q, p);",
		"        ll t = power(n, q, p);",
		"        ll r = power(n, (q + 1) / 2, p);",
		"",
		"        while (t != 1) {",
		"            ll i = 1, temp = t * t % p;",
		"            while (temp != 1 && i < m) {",
		"                temp = temp * temp % p;",
		"                i++;",
		"            }",
		"",
		"            ll b = power(c, 1LL << (m - i - 1), p);",
		"            m = i;",
		"            c = b * b % p;",
		"            t = t * c % p;",
		"            r = r * b % p;",
		"        }",
		"",
		"        return r;",
		"    }",
		"",
		"    vector<ll> all_solutions(ll n, ll p) {",
		"        ll x = solve(n, p);",
		"        if (x == -1) return {};",
		"        if (x == 0) return {0};",
		"        return {x, p - x};",
		"    }",
		"};",
	})
}),

-- 04_Math\Number_Theory\Basic\Euler.h
s("04_math_number_theory_basic_euler_h", {
	t({
		"using ll = long long;",
		"",
		"// 基础欧拉函数",
		"struct EulerPhi {",
		"    // 单个数的欧拉函数 φ(n)",
		"    ll phi(ll n) {",
		"        ll res = n;",
		"        for (ll i = 2; i * i <= n; i++) {",
		"            if (n % i == 0) {",
		"                res = res / i * (i - 1);",
		"                while (n % i == 0) n /= i;",
		"            }",
		"        }",
		"        if (n > 1) res = res / n * (n - 1);",
		"        return res;",
		"    }",
		"    ",
		"    // 快速幂",
		"    ll power(ll a, ll b, ll mod) {",
		"        ll res = 1;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % mod;",
		"            a = a * a % mod;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    // 欧拉定理：a^φ(m) ≡ 1 (mod m) when gcd(a,m)=1",
		"    ll euler_theorem(ll a, ll m) {",
		"        if (__gcd(a, m) != 1) return -1;",
		"        return power(a, phi(m), m);",
		"    }",
		"    ",
		"    // 模逆元（使用欧拉定理）",
		"    ll mod_inverse(ll a, ll m) {",
		"        if (__gcd(a, m) != 1) return -1;",
		"        return power(a, phi(m) - 1, m);",
		"    }",
		"};",
		"",
		"// 线性筛欧拉函数",
		"struct LinearEuler {",
		"    vector<ll> phi, primes;",
		"    vector<bool> is_prime;",
		"    int n;",
		"    ",
		"    LinearEuler(int maxn) : n(maxn) {",
		"        phi.resize(n + 1);",
		"        is_prime.resize(n + 1, true);",
		"        ",
		"        phi[1] = 1;",
		"        is_prime[0] = is_prime[1] = false;",
		"        ",
		"        for (int i = 2; i <= n; i++) {",
		"            if (is_prime[i]) {",
		"                primes.push_back(i);",
		"                phi[i] = i - 1;",
		"            }",
		"            ",
		"            for (ll p : primes) {",
		"                if (i * p > n) break;",
		"                is_prime[i * p] = false;",
		"                ",
		"                if (i % p == 0) {",
		"                    phi[i * p] = phi[i] * p;",
		"                    break;",
		"                } else {",
		"                    phi[i * p] = phi[i] * (p - 1);",
		"                }",
		"            }",
		"        }",
		"    }",
		"    ",
		"    ll get_phi(int x) {",
		"        if (x <= n) return phi[x];",
		"        EulerPhi ep;",
		"        return ep.phi(x);",
		"    }",
		"    ",
		"    vector<ll> get_primes() { return primes; }",
		"};",
		"",
		"// 欧拉函数性质和应用",
		"struct EulerApps {",
		"    // 欧拉函数的因子和性质：∑φ(d) = n (d|n)",
		"    ll sum_phi_divisors(ll n) {",
		"        ll sum = 0;",
		"        for (ll i = 1; i * i <= n; i++) {",
		"            if (n % i == 0) {",
		"                EulerPhi ep;",
		"                sum += ep.phi(i);",
		"                if (i != n / i) sum += ep.phi(n / i);",
		"            }",
		"        }",
		"        return sum;",
		"    }",
		"    ",
		"    // 扩展欧拉定理",
		"    ll extended_euler(ll a, ll n, ll m) {",
		"        EulerPhi ep;",
		"        ll phi_m = ep.phi(m);",
		"        if (n < 32) return ep.power(a, n, m);",
		"        return ep.power(a, n % phi_m + phi_m, m);",
		"    }",
		"    ",
		"    // 寻找φ(x) = n的所有x",
		"    vector<ll> inverse_phi(ll n) {",
		"        vector<ll> res;",
		"        if (n == 1) {",
		"            res.push_back(1);",
		"            res.push_back(2);",
		"            return res;",
		"        }",
		"        ",
		"        EulerPhi ep;",
		"        for (ll x = n; x <= 2 * n; x++) {",
		"            if (ep.phi(x) == n) res.push_back(x);",
		"        }",
		"        return res;",
		"    }",
		"};",
		"",
		"",
	})
}),

-- 04_Math\Number_Theory\Basic\ExtendedGCD.h
s("04_math_number_theory_basic_extendedgcd_h", {
	t({
		"using ll = long long;",
		"using pll = pair<ll, ll>;",
		"",
		"// 扩展欧几里得算法",
		"struct ExtGCD {",
		"    // 返回 {gcd(a,b), x, y} 使得 ax + by = gcd(a,b)",
		"    array<ll, 3> exgcd(ll a, ll b) {",
		"        if (!b) return {a, 1, 0};",
		"        auto [g, x, y] = exgcd(b, a % b);",
		"        return {g, y, x - a / b * y};",
		"    }",
		"    ",
		"    // 模逆元计算",
		"    ll inv(ll a, ll m) {",
		"        auto [g, x, y] = exgcd(a, m);",
		"        if (g != 1) return -1;",
		"        return (x % m + m) % m;",
		"    }",
		"    ",
		"    // 线性同余方程 ax ≡ b (mod m)",
		"    pair<bool, ll> solve_congruence(ll a, ll b, ll m) {",
		"        auto [g, x, y] = exgcd(a, m);",
		"        if (b % g) return {false, 0};",
		"        x = x * (b / g) % (m / g);",
		"        if (x < 0) x += m / g;",
		"        return {true, x};",
		"    }",
		"};",
		"",
		"// 批量模逆元",
		"struct BatchInverse {",
		"    vector<ll> batch_inv(vector<ll> a, ll mod) {",
		"        int n = a.size();",
		"        vector<ll> s(n + 1, 1);",
		"        for (int i = 0; i < n; i++) s[i + 1] = s[i] * a[i] % mod;",
		"        ",
		"        ExtGCD egcd;",
		"        ll inv_all = egcd.inv(s[n], mod);",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            a[i] = s[i] * inv_all % mod;",
		"            inv_all = inv_all * (a[i] * s[i] % mod) % mod;",
		"        }",
		"        return a;",
		"    }",
		"};",
		"",
		"// 不定方程求解器",
		"struct DiophantineEq {",
		"    ll x, y, g;",
		"    ",
		"    // 求解 ax + by = c",
		"    bool solve(ll a, ll b, ll c) {",
		"        ExtGCD egcd;",
		"        auto [gcd, px, py] = egcd.exgcd(a, b);",
		"        g = gcd;",
		"        if (c % g) return false;",
		"        x = px * (c / g);",
		"        y = py * (c / g);",
		"        return true;",
		"    }",
		"    ",
		"    // 通解：x = x0 + k*(b/g), y = y0 - k*(a/g)",
		"    pair<ll, ll> general_solution(ll k, ll a, ll b) {",
		"        return {x + k * (b / g), y - k * (a / g)};",
		"    }",
		"    ",
		"    // 最小正整数解",
		"    ll min_positive_x(ll a, ll b) {",
		"        ll step = abs(b / g);",
		"        ll res = ((x % step) + step) % step;",
		"        return res == 0 ? step : res;",
		"    }",
		"};",
	})
}),

-- 04_Math\Number_Theory\Basic\GCD_LCM.h
s("04_math_number_theory_basic_gcd_lcm_h", {
	t({
		"using ll = long long;",
		"",
		"// 基础GCD和LCM",
		"struct BasicGCD {",
		"    ll gcd(ll a, ll b) {",
		"        while (b) {",
		"            a %= b;",
		"            swap(a, b);",
		"        }",
		"        return a;",
		"    }",
		"    ",
		"    ll lcm(ll a, ll b) {",
		"        return a / gcd(a, b) * b;",
		"    }",
		"    ",
		"    ll gcd_multiple(const vector<ll>& arr) {",
		"        ll res = arr[0];",
		"        for (int i = 1; i < arr.size(); i++) {",
		"            res = gcd(res, arr[i]);",
		"            if (res == 1) break;",
		"        }",
		"        return res;",
		"    }",
		"    ",
		"    ll lcm_multiple(const vector<ll>& arr) {",
		"        ll res = arr[0];",
		"        for (int i = 1; i < arr.size(); i++) res = lcm(res, arr[i]);",
		"        return res;",
		"    }",
		"};",
		"",
		"// 二进制GCD（Stein算法）",
		"struct BinaryGCD {",
		"    ll gcd(ll a, ll b) {",
		"        if (a == 0) return b;",
		"        if (b == 0) return a;",
		"        ",
		"        int shift = 0;",
		"        while (((a | b) & 1) == 0) {",
		"            shift++;",
		"            a >>= 1;",
		"            b >>= 1;",
		"        }",
		"        ",
		"        while ((a & 1) == 0) a >>= 1;",
		"        ",
		"        do {",
		"            while ((b & 1) == 0) b >>= 1;",
		"            if (a > b) swap(a, b);",
		"            b -= a;",
		"        } while (b != 0);",
		"        ",
		"        return a << shift;",
		"    }",
		"};",
		"",
		"// 分数运算",
		"struct Fraction {",
		"    ll num, den;",
		"    ",
		"    Fraction(ll n = 0, ll d = 1) {",
		"        if (d < 0) {",
		"            n = -n;",
		"            d = -d;",
		"        }",
		"        ll g = __gcd(abs(n), abs(d));",
		"        num = n / g;",
		"        den = d / g;",
		"    }",
		"    ",
		"    Fraction operator+(const Fraction& b) const {",
		"        return Fraction(num * b.den + b.num * den, den * b.den);",
		"    }",
		"    ",
		"    Fraction operator-(const Fraction& b) const {",
		"        return Fraction(num * b.den - b.num * den, den * b.den);",
		"    }",
		"    ",
		"    Fraction operator*(const Fraction& b) const {",
		"        return Fraction(num * b.num, den * b.den);",
		"    }",
		"    ",
		"    Fraction operator/(const Fraction& b) const {",
		"        return Fraction(num * b.den, den * b.num);",
		"    }",
		"    ",
		"    bool operator<(const Fraction& b) const {",
		"        return num * b.den < b.num * den;",
		"    }",
		"    ",
		"    bool operator==(const Fraction& b) const {",
		"        return num == b.num && den == b.den;",
		"    }",
		"    ",
		"    string toString() const {",
		"        if (den == 1) return to_string(num);",
		"        return to_string(num) + \"/\" + to_string(den);",
		"    }",
		"};",
		"",
		"// 范围GCD查询（稀疏表）",
		"struct RangeGCD {",
		"    vector<vector<ll>> st;",
		"    vector<int> lg;",
		"    ",
		"    RangeGCD(const vector<ll>& arr) {",
		"        int n = arr.size();",
		"        lg.resize(n + 1);",
		"        lg[1] = 0;",
		"        for (int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;",
		"        ",
		"        int k = lg[n] + 1;",
		"        st.assign(k, vector<ll>(n));",
		"        ",
		"        for (int i = 0; i < n; i++) st[0][i] = arr[i];",
		"        ",
		"        for (int j = 1; j < k; j++) {",
		"            for (int i = 0; i + (1 << j) <= n; i++) {",
		"                st[j][i] = __gcd(st[j-1][i], st[j-1][i + (1 << (j-1))]);",
		"            }",
		"        }",
		"    }",
		"    ",
		"    ll query(int l, int r) {",
		"        int j = lg[r - l + 1];",
		"        return __gcd(st[j][l], st[j][r - (1 << j) + 1]);",
		"    }",
		"};",
		"",
		"",
	})
}),

-- 04_Math\Number_Theory\Basic\LinearSieve.h
s("04_math_number_theory_basic_linearsieve_h", {
	t({
		"using ll = long long;",
		"",
		"struct LinearSieve {",
		"    vector<int> primes;",
		"    vector<bool> is_prime;",
		"    int n;",
		"",
		"    LinearSieve(int limit) : n(limit) {",
		"        is_prime.assign(n + 1, true);",
		"        is_prime[0] = is_prime[1] = false;",
		"        ",
		"        for (int i = 2; i <= n; i++) {",
		"            if (is_prime[i]) primes.push_back(i);",
		"            for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {",
		"                is_prime[i * primes[j]] = false;",
		"                if (i % primes[j] == 0) break;",
		"            }",
		"        }",
		"    }",
		"",
		"    bool check(int x) { return x <= n && is_prime[x]; }",
		"    vector<int> get_primes() { return primes; }",
		"};",
		"",
		"struct EulerSieve {",
		"    vector<int> primes, phi;",
		"    int n;",
		"",
		"    EulerSieve(int limit) : n(limit) {",
		"        phi.assign(n + 1, 0);",
		"        phi[1] = 1;",
		"        vector<bool> is_prime(n + 1, true);",
		"        is_prime[0] = is_prime[1] = false;",
		"",
		"        for (int i = 2; i <= n; i++) {",
		"            if (is_prime[i]) {",
		"                primes.push_back(i);",
		"                phi[i] = i - 1;",
		"            }",
		"            for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {",
		"                int ip = i * primes[j];",
		"                is_prime[ip] = false;",
		"                if (i % primes[j] == 0) {",
		"                    phi[ip] = phi[i] * primes[j];",
		"                    break;",
		"                } else {",
		"                    phi[ip] = phi[i] * (primes[j] - 1);",
		"                }",
		"            }",
		"        }",
		"    }",
		"};",
		"",
		"struct MobiusSieve {",
		"    vector<int> primes, mu;",
		"    int n;",
		"",
		"    MobiusSieve(int limit) : n(limit) {",
		"        mu.assign(n + 1, 0);",
		"        mu[1] = 1;",
		"        vector<bool> is_prime(n + 1, true);",
		"        is_prime[0] = is_prime[1] = false;",
		"",
		"        for (int i = 2; i <= n; i++) {",
		"            if (is_prime[i]) {",
		"                primes.push_back(i);",
		"                mu[i] = -1;",
		"            }",
		"            for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {",
		"                int ip = i * primes[j];",
		"                is_prime[ip] = false;",
		"                if (i % primes[j] == 0) {",
		"                    mu[ip] = 0;",
		"                    break;",
		"                } else {",
		"                    mu[ip] = -mu[i];",
		"                }",
		"            }",
		"        }",
		"    }",
		"};",
	})
}),

-- 04_Math\Number_Theory\Basic\Sieve.h
s("04_math_number_theory_basic_sieve_h", {
	t({
		"using ll = long long;",
		"",
		"// 埃拉托斯特尼筛法",
		"struct Sieve {",
		"    vector<bool> is_prime;",
		"    vector<int> primes;",
		"    int n;",
		"    ",
		"    Sieve(int limit) : n(limit) {",
		"        is_prime.assign(n + 1, true);",
		"        is_prime[0] = is_prime[1] = false;",
		"        ",
		"        for (int i = 2; i * i <= n; i++) {",
		"            if (is_prime[i]) {",
		"                for (int j = i * i; j <= n; j += i) is_prime[j] = false;",
		"            }",
		"        }",
		"        ",
		"        for (int i = 2; i <= n; i++) {",
		"            if (is_prime[i]) primes.push_back(i);",
		"        }",
		"    }",
		"    ",
		"    bool check(int x) { return x <= n && is_prime[x]; }",
		"    vector<int> get_primes() { return primes; }",
		"    int count() { return primes.size(); }",
		"};",
		"",
		"// 区间筛",
		"struct SegmentSieve {",
		"    vector<bool> sieve(ll L, ll R) {",
		"        vector<bool> is_prime(R - L + 1, true);",
		"        for (ll p = 2; p * p <= R; p++) {",
		"            ll start = max(p * p, (L + p - 1) / p * p);",
		"            for (ll j = start; j <= R; j += p) is_prime[j - L] = false;",
		"        }",
		"        if (L == 1) is_prime[0] = false;",
		"        return is_prime;",
		"    }",
		"};",
	})
}),

-- 04_Math\Number_Theory\Congruences\CRT.h
s("04_math_number_theory_congruences_crt_h", {
	t({
		"// 中国剩余定理 (Chinese Remainder Theorem)",
		"using ll = long long;",
		"",
		"// 扩展欧几里得算法",
		"ll exgcd(ll a, ll b, ll &x, ll &y) {",
		"    if (b == 0) {",
		"        x = 1, y = 0;",
		"        return a;",
		"    }",
		"    ll d = exgcd(b, a % b, y, x);",
		"    y -= a / b * x;",
		"    return d;",
		"}",
		"",
		"// 求逆元",
		"ll inv(ll a, ll m) {",
		"    ll x, y;",
		"    ll d = exgcd(a, m, x, y);",
		"    if (d != 1) return -1;  // 不存在逆元",
		"    return (x % m + m) % m;",
		"}",
		"",
		"// 中国剩余定理（模数互质）",
		"// 解方程组: x ≡ a[i] (mod m[i])",
		"ll crt(vector<ll> a, vector<ll> m) {",
		"    int n = a.size();",
		"    ll M = 1;",
		"    for (int i = 0; i < n; i++) { M *= m[i]; }",
		"",
		"    ll ans = 0;",
		"    for (int i = 0; i < n; i++) {",
		"        ll Mi = M / m[i];",
		"        ll yi = inv(Mi, m[i]);",
		"        if (yi == -1) return -1;  // 模数不互质",
		"        ans = (ans + a[i] * Mi % M * yi) % M;",
		"    }",
		"    return (ans % M + M) % M;",
		"}",
		"",
		"// 扩展中国剩余定理（模数不要求互质）",
		"// 解方程组: x ≡ a[i] (mod m[i])",
		"ll excrt(vector<ll> a, vector<ll> m) {",
		"    int n = a.size();",
		"    ll x = a[0], lcm = m[0];",
		"",
		"    for (int i = 1; i < n; i++) {",
		"        ll A = lcm, B = m[i], C = (a[i] - x % B + B) % B;",
		"        ll p, q;",
		"        ll d = exgcd(A, B, p, q);",
		"",
		"        if (C % d != 0) return -1;  // 无解",
		"",
		"        ll t = C / d;",
		"        p = (p * t % (B / d) + B / d) % (B / d);",
		"        x += A * p;",
		"        lcm = lcm / d * B;",
		"    }",
		"    return (x % lcm + lcm) % lcm;",
		"}",
		"",
		"// 解单个线性同余方程 ax ≡ b (mod m)",
		"vector<ll> linear_congruence(ll a, ll b, ll m) {",
		"    ll x, y;",
		"    ll d = exgcd(a, m, x, y);",
		"",
		"    if (b % d != 0) return {};  // 无解",
		"",
		"    ll x0 = (x * (b / d) % m + m) % m;",
		"    ll step = m / d;",
		"",
		"    vector<ll> solutions;",
		"    for (int i = 0; i < d; i++) { solutions.push_back((x0 + i * step) % m); }",
		"    return solutions;",
		"}",
		"",
		"// Wilson定理：(p-1)! ≡ -1 (mod p) 当且仅当p是质数",
		"bool wilson_test(ll p) {",
		"    if (p <= 1) return false;",
		"    if (p == 2) return true;",
		"    if (p % 2 == 0) return false;",
		"",
		"    ll fact = 1;",
		"    for (ll i = 1; i < p; i++) { fact = (fact * i) % p; }",
		"    return fact == p - 1;",
		"}",
		"",
		"// 快速幂",
		"ll binpower(ll a, ll b, ll m) {",
		"    ll res = 1;",
		"    a %= m;",
		"    while (b > 0) {",
		"        if (b & 1) res = (res * a) % m;",
		"        a = (a * a) % m;",
		"        b >>= 1;",
		"    }",
		"    return res;",
		"}",
		"",
		"// 求解二次同余方程 x² ≡ n (mod p)，p为奇质数",
		"vector<ll> quadratic_residue(ll n, ll p) {",
		"    n %= p;",
		"    if (n == 0) return {0};",
		"",
		"    // 勒让德符号判断",
		"    if (binpower(n, (p - 1) / 2, p) != 1) return {};  // n不是二次剩余",
		"",
		"    // Tonelli-Shanks算法",
		"    ll q = p - 1, s = 0;",
		"    while (q % 2 == 0) {",
		"        q /= 2;",
		"        s++;",
		"    }",
		"",
		"    if (s == 1) {",
		"        ll x = binpower(n, (p + 1) / 4, p);",
		"        return {x, p - x};",
		"    }",
		"",
		"    // 找一个二次非剩余z",
		"    ll z = 2;",
		"    while (binpower(z, (p - 1) / 2, p) != p - 1) z++;",
		"",
		"    ll m = s, c = binpower(z, q, p);",
		"    ll t = binpower(n, q, p), r = binpower(n, (q + 1) / 2, p);",
		"",
		"    while (t != 1) {",
		"        ll i = 1;",
		"        ll temp = (t * t) % p;",
		"        while (temp != 1) {",
		"            temp = (temp * temp) % p;",
		"            i++;",
		"        }",
		"",
		"        ll b = binpower(c, 1LL << (m - i - 1), p);",
		"        m = i;",
		"        c = (b * b) % p;",
		"        t = (t * c) % p;",
		"        r = (r * b) % p;",
		"    }",
		"",
		"    return {r, p - r};",
		"}",
	})
}),

-- 04_Math\Number_Theory\Congruences\DiscreteLog.h
s("04_math_number_theory_congruences_discretelog_h", {
	t({
		"// 离散对数 (Discrete Logarithm)",
		"using ll = long long;",
		"",
		"// 快速幂",
		"ll binpower(ll base, ll exp, ll mod) {",
		"    ll result = 1;",
		"    base %= mod;",
		"    while (exp > 0) {",
		"        if (exp & 1) result = (result * base) % mod;",
		"        base = (base * base) % mod;",
		"        exp >>= 1;",
		"    }",
		"    return result;",
		"}",
		"",
		"// Baby-step Giant-step 算法",
		"// 求解 a^x ≡ b (mod m)，返回最小的非负整数x",
		"ll bsgs(ll a, ll b, ll m) {",
		"    if (b == 1) return 0;",
		"",
		"    a %= m;",
		"    b %= m;",
		"",
		"    int n = sqrt(m) + 1;",
		"",
		"    // Baby steps: 计算 a^j mod m, j = 0, 1, ..., n-1",
		"    unordered_map<ll, int> baby_steps;",
		"    ll gamma = 1;",
		"    for (int j = 0; j < n; j++) {",
		"        if (baby_steps.find(gamma) == baby_steps.end()) { baby_steps[gamma] = j; }",
		"        gamma = (gamma * a) % m;",
		"    }",
		"",
		"    // Giant steps: 计算 b * (a^n)^(-i) mod m, i = 0, 1, ..., n-1",
		"    ll an = binpower(a, n, m);",
		"    ll inv_an = binpower(an, m - 2, m);  // 费马小定理求逆元（假设m是质数）",
		"",
		"    ll y = b;",
		"    for (int i = 0; i < n; i++) {",
		"        if (baby_steps.find(y) != baby_steps.end()) {",
		"            ll ans = i * n + baby_steps[y];",
		"            if (ans > 0) return ans;",
		"        }",
		"        y = (y * inv_an) % m;",
		"    }",
		"",
		"    return -1;  // 无解",
		"}",
		"",
		"// 扩展欧几里得算法",
		"ll exgcd(ll a, ll b, ll &x, ll &y) {",
		"    if (b == 0) {",
		"        x = 1, y = 0;",
		"        return a;",
		"    }",
		"    ll d = exgcd(b, a % b, y, x);",
		"    y -= a / b * x;",
		"    return d;",
		"}",
		"",
		"// 求模逆元",
		"ll modinv(ll a, ll m) {",
		"    ll x, y;",
		"    ll d = exgcd(a, m, x, y);",
		"    if (d != 1) return -1;",
		"    return (x % m + m) % m;",
		"}",
		"",
		"// 处理gcd(a,m) > 1的情况的BSGS",
		"ll exbsgs(ll a, ll b, ll m) {",
		"    a %= m;",
		"    b %= m;",
		"    if (b == 1) return 0;",
		"",
		"    ll d, k = 0, ak = 1;",
		"",
		"    // 处理gcd(a,m) > 1的情况",
		"    while ((d = __gcd(a, m)) > 1) {",
		"        if (b % d != 0) return -1;",
		"        b /= d;",
		"        m /= d;",
		"        k++;",
		"        ak = (ak * (a / d)) % m;",
		"        if (b == ak) return k;",
		"    }",
		"",
		"    // 现在gcd(a,m) = 1，可以用标准BSGS",
		"    int n = sqrt(m) + 1;",
		"",
		"    unordered_map<ll, int> baby_steps;",
		"    ll gamma = 1;",
		"    for (int j = 0; j < n; j++) {",
		"        if (baby_steps.find(gamma) == baby_steps.end()) { baby_steps[gamma] = j; }",
		"        gamma = (gamma * a) % m;",
		"    }",
		"",
		"    ll an = binpower(a, n, m);",
		"    ll inv_an = modinv(an, m);",
		"    if (inv_an == -1) return -1;",
		"",
		"    ll y = (b * modinv(ak, m)) % m;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        if (baby_steps.find(y) != baby_steps.end()) {",
		"            ll ans = k + i * n + baby_steps[y];",
		"            return ans;",
		"        }",
		"        y = (y * inv_an) % m;",
		"    }",
		"",
		"    return -1;",
		"}",
		"",
		"// Pohlig-Hellman算法（当模数p-1有小的质因数时）",
		"ll pohlig_hellman(ll a, ll b, ll p) {",
		"    // 对于素数p，求解 a^x ≡ b (mod p)",
		"    ll order = p - 1;",
		"    vector<pair<ll, int>> factors;",
		"",
		"    // 分解order = p-1",
		"    ll temp = order;",
		"    for (ll i = 2; i * i <= temp; i++) {",
		"        if (temp % i == 0) {",
		"            int cnt = 0;",
		"            while (temp % i == 0) {",
		"                temp /= i;",
		"                cnt++;",
		"            }",
		"            factors.push_back({i, cnt});",
		"        }",
		"    }",
		"    if (temp > 1) factors.push_back({temp, 1});",
		"",
		"    vector<ll> remainders, moduli;",
		"",
		"    for (auto [q, e] : factors) {",
		"        ll qe = 1;",
		"        for (int i = 0; i < e; i++) qe *= q;",
		"",
		"        ll a_reduced = binpower(a, order / qe, p);",
		"        ll b_reduced = binpower(b, order / qe, p);",
		"",
		"        ll x_mod_qe = bsgs(a_reduced, b_reduced, p);",
		"        if (x_mod_qe == -1) return -1;",
		"",
		"        remainders.push_back(x_mod_qe);",
		"        moduli.push_back(qe);",
		"    }",
		"",
		"    // 使用中国剩余定理合并结果",
		"    ll result = remainders[0], lcm = moduli[0];",
		"    for (int i = 1; i < remainders.size(); i++) {",
		"        ll a1 = lcm, b1 = moduli[i], c = (remainders[i] - result % b1 + b1) % b1;",
		"        ll x, y;",
		"        ll d = exgcd(a1, b1, x, y);",
		"        if (c % d != 0) return -1;",
		"        ll t = c / d;",
		"        x = (x * t % (b1 / d) + b1 / d) % (b1 / d);",
		"        result += a1 * x;",
		"        lcm = lcm / d * b1;",
		"    }",
		"",
		"    return (result % order + order) % order;",
		"}",
	})
}),

-- 04_Math\Number_Theory\Congruences\ExCRT.h
s("04_math_number_theory_congruences_excrt_h", {
	t({
		"// 扩展中国剩余定理",
		"using ll = long long;",
		"",
		"// 扩展欧几里得算法",
		"ll exgcd(ll a, ll b, ll &x, ll &y) {",
		"    if (b == 0) {",
		"        x = 1, y = 0;",
		"        return a;",
		"    }",
		"    ll d = exgcd(b, a % b, y, x);",
		"    y -= a / b * x;",
		"    return d;",
		"}",
		"",
		"// 扩展中国剩余定理：解方程组 x ≡ a[i] (mod m[i])",
		"// 不要求模数互质",
		"struct ExCRT {",
		"    vector<ll> a, m;",
		"",
		"    void add_congruence(ll ai, ll mi) {",
		"        a.push_back(ai);",
		"        m.push_back(mi);",
		"    }",
		"",
		"    ll solve() {",
		"        if (a.empty()) return 0;",
		"",
		"        ll x = a[0], lcm = m[0];",
		"",
		"        for (int i = 1; i < a.size(); i++) {",
		"            ll A = lcm, B = m[i], C = (a[i] - x % B + B) % B;",
		"            ll p, q;",
		"            ll d = exgcd(A, B, p, q);",
		"",
		"            if (C % d != 0) return -1;  // 无解",
		"",
		"            ll t = C / d;",
		"            p = (p * t % (B / d) + B / d) % (B / d);",
		"            x += A * p;",
		"            lcm = lcm / d * B;",
		"        }",
		"",
		"        return (x % lcm + lcm) % lcm;",
		"    }",
		"",
		"    // 检查解的存在性",
		"    bool has_solution() {",
		"        if (a.empty()) return true;",
		"",
		"        ll x = a[0], lcm = m[0];",
		"",
		"        for (int i = 1; i < a.size(); i++) {",
		"            ll A = lcm, B = m[i], C = (a[i] - x % B + B) % B;",
		"            ll p, q;",
		"            ll d = exgcd(A, B, p, q);",
		"",
		"            if (C % d != 0) return false;",
		"",
		"            ll t = C / d;",
		"            p = (p * t % (B / d) + B / d) % (B / d);",
		"            x += A * p;",
		"            lcm = lcm / d * B;",
		"        }",
		"",
		"        return true;",
		"    }",
		"",
		"    // 获取解的模数",
		"    ll get_modulus() {",
		"        if (a.empty()) return 1;",
		"",
		"        ll lcm = m[0];",
		"        for (int i = 1; i < m.size(); i++) {",
		"            ll d = __gcd(lcm, m[i]);",
		"            lcm = lcm / d * m[i];",
		"        }",
		"        return lcm;",
		"    }",
		"",
		"    void clear() {",
		"        a.clear();",
		"        m.clear();",
		"    }",
		"};",
		"",
		"// 直接求解函数版本",
		"ll excrt(vector<ll> a, vector<ll> m) {",
		"    if (a.empty()) return 0;",
		"",
		"    ll x = a[0], lcm = m[0];",
		"",
		"    for (int i = 1; i < a.size(); i++) {",
		"        ll A = lcm, B = m[i], C = (a[i] - x % B + B) % B;",
		"        ll p, q;",
		"        ll d = exgcd(A, B, p, q);",
		"",
		"        if (C % d != 0) return -1;  // 无解",
		"",
		"        ll t = C / d;",
		"        p = (p * t % (B / d) + B / d) % (B / d);",
		"        x += A * p;",
		"        lcm = lcm / d * B;",
		"    }",
		"",
		"    return (x % lcm + lcm) % lcm;",
		"}",
		"",
		"// 二元线性同余方程组求解",
		"pair<ll, ll> solve_binary_system(ll a1, ll b1, ll m1, ll a2, ll b2, ll m2) {",
		"    // 求解: a1*x + b1*y ≡ 0 (mod m1)",
		"    //       a2*x + b2*y ≡ 0 (mod m2)",
		"",
		"    ll x, y;",
		"    ll d = exgcd(m1, m2, x, y);",
		"",
		"    if ((a1 * b2 - a2 * b1) % d != 0) {",
		"        return {-1, -1};  // 无解",
		"    }",
		"",
		"    ll lcm = m1 / d * m2;",
		"    ll sol_x = (x * (a1 * b2 - a2 * b1) / d) % lcm;",
		"    ll sol_y = (a1 == 0 ? 0 : (-a1 * sol_x - b1) / m1);",
		"",
		"    return {(sol_x % lcm + lcm) % lcm, sol_y};",
		"}",
	})
}),

-- 04_Math\Number_Theory\Factorization\PollardRho.h
s("04_math_number_theory_factorization_pollardrho_h", {
	t({
		"// Pollard-Rho 算法进行大数因数分解",
		"using u64 = uint64_t;",
		"using u128 = __uint128_t;",
		"",
		"u64 mulmod(u64 a, u64 b, u64 mod) { return ((u128)a * b) % mod; }",
		"",
		"u64 binpower(u64 base, u64 e, u64 mod) {",
		"    u64 result = 1;",
		"    base %= mod;",
		"    while (e) {",
		"        if (e & 1) result = mulmod(result, base, mod);",
		"        base = mulmod(base, base, mod);",
		"        e >>= 1;",
		"    }",
		"    return result;",
		"}",
		"",
		"bool miller_rabin(u64 n, u64 a) {",
		"    if (n == a) return true;",
		"    if (n % 2 == 0) return false;",
		"",
		"    u64 d = n - 1;",
		"    int r = 0;",
		"    while (d % 2 == 0) {",
		"        d /= 2;",
		"        r++;",
		"    }",
		"",
		"    u64 x = binpower(a, d, n);",
		"    if (x == 1 || x == n - 1) return true;",
		"",
		"    for (int i = 0; i < r - 1; i++) {",
		"        x = mulmod(x, x, n);",
		"        if (x == n - 1) return true;",
		"    }",
		"    return false;",
		"}",
		"",
		"bool is_prime(u64 n) {",
		"    if (n < 2) return false;",
		"    static const u64 bases[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};",
		"    for (u64 a : bases) {",
		"        if (n == a) return true;",
		"        if (!miller_rabin(n, a)) return false;",
		"    }",
		"    return true;",
		"}",
		"",
		"u64 f(u64 x, u64 c, u64 mod) { return (mulmod(x, x, mod) + c) % mod; }",
		"",
		"u64 rho(u64 n) {",
		"    if (n % 2 == 0) return 2;",
		"",
		"    u64 x = 2, y = 2, c = 1;",
		"    u64 d = 1;",
		"",
		"    while (d == 1) {",
		"        x = f(x, c, n);",
		"        y = f(f(y, c, n), c, n);",
		"        d = gcd(abs((long long)(x - y)), n);",
		"        if (d == n) {",
		"            c++;",
		"            x = y = 2;",
		"            d = 1;",
		"        }",
		"    }",
		"    return d;",
		"}",
		"",
		"vector<u64> factorize(u64 n) {",
		"    if (n == 1) return {};",
		"    if (is_prime(n)) return {n};",
		"",
		"    u64 factor = rho(n);",
		"    auto left = factorize(factor);",
		"    auto right = factorize(n / factor);",
		"",
		"    left.insert(left.end(), right.begin(), right.end());",
		"    return left;",
		"}",
		"",
		"// 返回质因数及其指数",
		"map<u64, int> factor_count(u64 n) {",
		"    auto factors = factorize(n);",
		"    map<u64, int> count;",
		"    for (u64 p : factors) { count[p]++; }",
		"    return count;",
		"}",
		"",
		"// 获取所有因数",
		"vector<u64> get_divisors(u64 n) {",
		"    auto factor_map = factor_count(n);",
		"    vector<u64> divisors = {1};",
		"",
		"    for (auto [p, cnt] : factor_map) {",
		"        int old_size = divisors.size();",
		"        u64 power = 1;",
		"        for (int i = 0; i < cnt; i++) {",
		"            power *= p;",
		"            for (int j = 0; j < old_size; j++) { divisors.push_back(divisors[j] * power); }",
		"        }",
		"    }",
		"",
		"    sort(divisors.begin(), divisors.end());",
		"    return divisors;",
		"}",
	})
}),

-- 04_Math\Number_Theory\Factorization\QuadraticSieve.h
s("04_math_number_theory_factorization_quadraticsieve_h", {
	t({
		"// 二次筛法（Quadratic Sieve）- 大整数因式分解",
		"struct QuadraticSieve {",
		"    static vector<long long> small_primes;",
		"    static bool primes_initialized;",
		"",
		"    static void init_primes(int limit = 10000) {",
		"        if (primes_initialized) return;",
		"",
		"        vector<bool> is_prime(limit + 1, true);",
		"        is_prime[0] = is_prime[1] = false;",
		"",
		"        for (int i = 2; i * i <= limit; i++) {",
		"            if (is_prime[i]) {",
		"                for (int j = i * i; j <= limit; j += i) { is_prime[j] = false; }",
		"            }",
		"        }",
		"",
		"        for (int i = 2; i <= limit; i++) {",
		"            if (is_prime[i]) { small_primes.push_back(i); }",
		"        }",
		"",
		"        primes_initialized = true;",
		"    }",
		"",
		"    // 计算勒让德符号 (a/p)",
		"    static int legendre_symbol(long long a, long long p) {",
		"        if (a % p == 0) return 0;",
		"",
		"        long long result = 1;",
		"        a %= p;",
		"",
		"        while (a != 0) {",
		"            while (a % 2 == 0) {",
		"                a /= 2;",
		"                if ((p * p - 1) / 8 % 2 == 1) { result = -result; }",
		"            }",
		"",
		"            swap(a, p);",
		"            if ((a - 1) / 2 % 2 == 1 && (p - 1) / 2 % 2 == 1) { result = -result; }",
		"            a %= p;",
		"        }",
		"",
		"        return p == 1 ? result : 0;",
		"    }",
		"",
		"    // 生成因子基",
		"    static vector<long long> generate_factor_base(long long n, int base_size) {",
		"        init_primes();",
		"        vector<long long> factor_base;",
		"        factor_base.push_back(-1);  // 包含-1",
		"",
		"        for (long long p : small_primes) {",
		"            if (factor_base.size() >= base_size) break;",
		"            if (legendre_symbol(n, p) != -1) { factor_base.push_back(p); }",
		"        }",
		"",
		"        return factor_base;",
		"    }",
		"",
		"    // 计算模平方根（Tonelli-Shanks算法的简化版本）",
		"    static long long mod_sqrt(long long n, long long p) {",
		"        if (p == 2) return n % 2;",
		"        if (legendre_symbol(n, p) != 1) return -1;",
		"",
		"        // 简单情况：p ≡ 3 (mod 4)",
		"        if (p % 4 == 3) {",
		"            long long r = 1;",
		"            long long exp = (p + 1) / 4;",
		"            long long base = n % p;",
		"",
		"            while (exp > 0) {",
		"                if (exp & 1) r = r * base % p;",
		"                base = base * base % p;",
		"                exp >>= 1;",
		"            }",
		"            return r;",
		"        }",
		"",
		"        // 更复杂的情况需要Tonelli-Shanks算法",
		"        // 这里简化实现",
		"        for (long long i = 1; i < p; i++) {",
		"            if (i * i % p == n % p) { return i; }",
		"        }",
		"",
		"        return -1;",
		"    }",
		"",
		"    // 筛选平滑数",
		"    static vector<pair<long long, vector<int>>> sieve_smooth_numbers(long long n,",
		"                                                                     const vector<long long>& factor_base,",
		"                                                                     int sieve_interval) {",
		"        vector<pair<long long, vector<int>>> smooth_numbers;",
		"        long long sqrt_n = (long long)sqrt(n);",
		"",
		"        for (long long x = sqrt_n; x < sqrt_n + sieve_interval; x++) {",
		"            long long val = x * x - n;",
		"            if (val <= 0) continue;",
		"",
		"            vector<int> exponents(factor_base.size(), 0);",
		"            long long temp = val;",
		"            bool is_smooth = true;",
		"",
		"            // 处理-1",
		"            if (temp < 0) {",
		"                exponents[0] = 1;",
		"                temp = -temp;",
		"            }",
		"",
		"            // 试除因子基中的素数",
		"            for (int i = 1; i < factor_base.size() && is_smooth; i++) {",
		"                long long p = factor_base[i];",
		"                while (temp % p == 0) {",
		"                    exponents[i]++;",
		"                    temp /= p;",
		"                }",
		"            }",
		"",
		"            if (temp == 1) { smooth_numbers.push_back({x, exponents}); }",
		"        }",
		"",
		"        return smooth_numbers;",
		"    }",
		"",
		"    // 高斯消元求解线性方程组（模2）",
		"    static vector<vector<int>> gaussian_elimination_mod2(vector<vector<int>>& matrix) {",
		"        int rows = matrix.size();",
		"        if (rows == 0) return {};",
		"        int cols = matrix[0].size();",
		"",
		"        vector<vector<int>> solutions;",
		"        vector<int> pivot_col(rows, -1);",
		"",
		"        for (int col = 0, row = 0; col < cols && row < rows; col++) {",
		"            // 找到主元",
		"            int pivot_row = -1;",
		"            for (int i = row; i < rows; i++) {",
		"                if (matrix[i][col] == 1) {",
		"                    pivot_row = i;",
		"                    break;",
		"                }",
		"            }",
		"",
		"            if (pivot_row == -1) continue;",
		"",
		"            // 交换行",
		"            if (pivot_row != row) { swap(matrix[row], matrix[pivot_row]); }",
		"",
		"            pivot_col[row] = col;",
		"",
		"            // 消元",
		"            for (int i = 0; i < rows; i++) {",
		"                if (i != row && matrix[i][col] == 1) {",
		"                    for (int j = 0; j < cols; j++) { matrix[i][j] ^= matrix[row][j]; }",
		"                }",
		"            }",
		"",
		"            row++;",
		"        }",
		"",
		"        return solutions;",
		"    }",
		"",
		"    // 主要的二次筛法函数",
		"    static vector<long long> factorize(long long n) {",
		"        if (n <= 1) return {};",
		"        if (n <= 3) return {n};",
		"",
		"        // 先用试除法处理小因子",
		"        vector<long long> factors;",
		"        for (long long p = 2; p * p <= n && p <= 1000; p++) {",
		"            while (n % p == 0) {",
		"                factors.push_back(p);",
		"                n /= p;",
		"            }",
		"        }",
		"",
		"        if (n == 1) return factors;",
		"        if (n <= 1000000) {",
		"            factors.push_back(n);",
		"            return factors;",
		"        }",
		"",
		"        // 对于大数使用二次筛法",
		"        init_primes();",
		"",
		"        // 生成因子基",
		"        int base_size = min(100, (int)small_primes.size());",
		"        vector<long long> factor_base = generate_factor_base(n, base_size);",
		"",
		"        // 筛选平滑数",
		"        vector<pair<long long, vector<int>>> smooth_numbers = sieve_smooth_numbers(n, factor_base, 1000);",
		"",
		"        if (smooth_numbers.size() < factor_base.size() + 1) {",
		"            // 如果平滑数不够，回退到其他方法",
		"            factors.push_back(n);",
		"            return factors;",
		"        }",
		"",
		"        // 构建矩阵并求解",
		"        vector<vector<int>> matrix;",
		"        for (const auto& [x, exponents] : smooth_numbers) {",
		"            vector<int> row;",
		"            for (int exp : exponents) { row.push_back(exp % 2); }",
		"            matrix.push_back(row);",
		"        }",
		"",
		"        // 这里简化处理，实际应该求解线性方程组",
		"        // 如果找到了非平凡因子，返回它",
		"",
		"        factors.push_back(n);",
		"        return factors;",
		"    }",
		"};",
		"",
		"vector<long long> QuadraticSieve::small_primes;",
		"bool QuadraticSieve::primes_initialized = false;",
	})
}),

-- 04_Math\Number_Theory\Factorization\TrialDivision.h
s("04_math_number_theory_factorization_trialdivision_h", {
	t({
		"// 试除法进行因数分解",
		"using ll = long long;",
		"",
		"// 基础试除法",
		"vector<pair<ll, int>> factorize(ll n) {",
		"    vector<pair<ll, int>> factors;",
		"",
		"    // 处理2的因子",
		"    if (n % 2 == 0) {",
		"        int cnt = 0;",
		"        while (n % 2 == 0) {",
		"            n /= 2;",
		"            cnt++;",
		"        }",
		"        factors.push_back({2, cnt});",
		"    }",
		"",
		"    // 处理奇数因子",
		"    for (ll i = 3; i * i <= n; i += 2) {",
		"        if (n % i == 0) {",
		"            int cnt = 0;",
		"            while (n % i == 0) {",
		"                n /= i;",
		"                cnt++;",
		"            }",
		"            factors.push_back({i, cnt});",
		"        }",
		"    }",
		"",
		"    // 如果n仍大于1，说明它是一个质数",
		"    if (n > 1) { factors.push_back({n, 1}); }",
		"",
		"    return factors;",
		"}",
		"",
		"// 获取所有因数",
		"vector<ll> get_divisors(ll n) {",
		"    auto factors = factorize(n);",
		"    vector<ll> divisors = {1};",
		"",
		"    for (auto [p, cnt] : factors) {",
		"        int old_size = divisors.size();",
		"        ll power = 1;",
		"        for (int i = 0; i < cnt; i++) {",
		"            power *= p;",
		"            for (int j = 0; j < old_size; j++) { divisors.push_back(divisors[j] * power); }",
		"        }",
		"    }",
		"",
		"    sort(divisors.begin(), divisors.end());",
		"    return divisors;",
		"}",
		"",
		"// 计算因数个数",
		"ll count_divisors(ll n) {",
		"    auto factors = factorize(n);",
		"    ll count = 1;",
		"    for (auto [p, cnt] : factors) { count *= (cnt + 1); }",
		"    return count;",
		"}",
		"",
		"// 计算因数和",
		"ll sum_of_divisors(ll n) {",
		"    auto factors = factorize(n);",
		"    ll sum = 1;",
		"    for (auto [p, cnt] : factors) {",
		"        ll power_sum = 0;",
		"        ll power = 1;",
		"        for (int i = 0; i <= cnt; i++) {",
		"            power_sum += power;",
		"            power *= p;",
		"        }",
		"        sum *= power_sum;",
		"    }",
		"    return sum;",
		"}",
		"",
		"// 判断是否为完全数",
		"bool is_perfect(ll n) { return sum_of_divisors(n) == 2 * n; }",
		"",
		"// 判断是否为亏数",
		"bool is_deficient(ll n) { return sum_of_divisors(n) < 2 * n; }",
		"",
		"// 判断是否为过剩数",
		"bool is_abundant(ll n) { return sum_of_divisors(n) > 2 * n; }",
	})
}),

-- 04_Math\Number_Theory\Primality\Fermat.h
s("04_math_number_theory_primality_fermat_h", {
	t({
		"// 费马素性测试",
		"using u64 = uint64_t;",
		"using u128 = __uint128_t;",
		"",
		"u64 binpower(u64 base, u64 e, u64 mod) {",
		"    u64 result = 1;",
		"    base %= mod;",
		"    while (e) {",
		"        if (e & 1) result = (u128)result * base % mod;",
		"        base = (u128)base * base % mod;",
		"        e >>= 1;",
		"    }",
		"    return result;",
		"}",
		"",
		"// 基础费马测试",
		"bool fermat_test(u64 n, u64 a) {",
		"    if (n <= 1) return false;",
		"    if (n == 2) return true;",
		"    if (n % 2 == 0) return false;",
		"    return binpower(a, n - 1, n) == 1;",
		"}",
		"",
		"// 使用多个基数的费马测试",
		"bool is_prime(u64 n, int k = 10) {",
		"    if (n <= 1) return false;",
		"    if (n <= 3) return true;",
		"    if (n % 2 == 0) return false;",
		"",
		"    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
		"",
		"    for (int i = 0; i < k; i++) {",
		"        u64 a = uniform_int_distribution<u64>(2, n - 2)(rng);",
		"        if (!fermat_test(n, a)) return false;",
		"    }",
		"    return true;",
		"}",
		"",
		"// 检测卡迈克尔数（费马伪素数）",
		"bool is_carmichael(u64 n) {",
		"    if (n <= 1 || n % 2 == 0) return false;",
		"",
		"    // 简单检测：对多个基数进行费马测试",
		"    vector<u64> bases = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
		"    for (u64 a : bases) {",
		"        if (a >= n) break;",
		"        if (__gcd(a, n) != 1) return false;",
		"        if (binpower(a, n - 1, n) != 1) return false;",
		"    }",
		"",
		"    // 检查是否确实是合数",
		"    for (u64 i = 2; i * i <= n; i++) {",
		"        if (n % i == 0) return true;",
		"    }",
		"    return false;",
		"}",
	})
}),

-- 04_Math\Number_Theory\Primality\MillerRabin.h
s("04_math_number_theory_primality_millerrabin_h", {
	t({
		"// Miller-Rabin 素性测试",
		"using u64 = uint64_t;",
		"using u128 = __uint128_t;",
		"",
		"u64 binpower(u64 base, u64 e, u64 mod) {",
		"    u64 result = 1;",
		"    base %= mod;",
		"    while (e) {",
		"        if (e & 1) result = (u128)result * base % mod;",
		"        base = (u128)base * base % mod;",
		"        e >>= 1;",
		"    }",
		"    return result;",
		"}",
		"",
		"bool check_composite(u64 n, u64 a, u64 d, int s) {",
		"    u64 x = binpower(a, d, n);",
		"    if (x == 1 || x == n - 1) return false;",
		"    for (int r = 1; r < s; r++) {",
		"        x = (u128)x * x % n;",
		"        if (x == n - 1) return false;",
		"    }",
		"    return true;",
		"}",
		"",
		"bool is_prime(u64 n) {",
		"    if (n < 2) return false;",
		"",
		"    int r = 0;",
		"    u64 d = n - 1;",
		"    while ((d & 1) == 0) {",
		"        d >>= 1;",
		"        r++;",
		"    }",
		"",
		"    // 测试基底，对于64位数这些基底足够",
		"    for (u64 a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
		"        if (n == a) return true;",
		"        if (check_composite(n, a, d, r)) return false;",
		"    }",
		"    return true;",
		"}",
		"",
		"// 使用示例",
		"bool isPrime(long long n) { return is_prime(n); }",
	})
}),

-- 04_Math\Number_Theory\Primality\SolovayStrassen.h
s("04_math_number_theory_primality_solovaystrassen_h", {
	t({
		"// Solovay-Strassen 素性测试",
		"using u64 = uint64_t;",
		"using u128 = __uint128_t;",
		"",
		"u64 binpower(u64 base, u64 e, u64 mod) {",
		"    u64 result = 1;",
		"    base %= mod;",
		"    while (e) {",
		"        if (e & 1) result = (u128)result * base % mod;",
		"        base = (u128)base * base % mod;",
		"        e >>= 1;",
		"    }",
		"    return result;",
		"}",
		"",
		"// 计算雅可比符号 (a/n)",
		"int jacobi_symbol(u64 a, u64 n) {",
		"    if (n <= 0 || n % 2 == 0) return 0;",
		"",
		"    int result = 1;",
		"    a %= n;",
		"",
		"    while (a != 0) {",
		"        while (a % 2 == 0) {",
		"            a /= 2;",
		"            if (n % 8 == 3 || n % 8 == 5) result = -result;",
		"        }",
		"        swap(a, n);",
		"        if (a % 4 == 3 && n % 4 == 3) result = -result;",
		"        a %= n;",
		"    }",
		"",
		"    return (n == 1) ? result : 0;",
		"}",
		"",
		"// Solovay-Strassen 测试",
		"bool solovay_strassen_test(u64 n, u64 a) {",
		"    if (n <= 1) return false;",
		"    if (n == 2) return true;",
		"    if (n % 2 == 0) return false;",
		"",
		"    if (__gcd(a, n) != 1) return false;",
		"",
		"    int jacobi = jacobi_symbol(a, n);",
		"    if (jacobi == 0) return false;",
		"",
		"    u64 exp = (n - 1) / 2;",
		"    u64 mod_result = binpower(a, exp, n);",
		"",
		"    // 将雅可比符号转换为模n的值",
		"    if (jacobi == -1) jacobi = n - 1;",
		"",
		"    return mod_result == jacobi;",
		"}",
		"",
		"// 使用多次随机测试",
		"bool is_prime(u64 n, int k = 10) {",
		"    if (n <= 1) return false;",
		"    if (n <= 3) return true;",
		"    if (n % 2 == 0) return false;",
		"",
		"    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
		"",
		"    for (int i = 0; i < k; i++) {",
		"        u64 a = uniform_int_distribution<u64>(2, n - 2)(rng);",
		"        if (!solovay_strassen_test(n, a)) return false;",
		"    }",
		"    return true;",
		"}",
	})
}),

-- 04_Math\Polynomial\FFT.h
s("04_math_polynomial_fft_h", {
	t({
		"// 快速傅里叶变换 (FFT) 模板",
		"template <typename T = double>",
		"struct FFT {",
		"    const double PI = acos(-1.0);",
		"",
		"    struct Complex {",
		"        T real, imag;",
		"",
		"        Complex(T r = 0, T i = 0) : real(r), imag(i) {}",
		"",
		"        Complex operator+(const Complex& other) const { return Complex(real + other.real, imag + other.imag); }",
		"",
		"        Complex operator-(const Complex& other) const { return Complex(real - other.real, imag - other.imag); }",
		"",
		"        Complex operator*(const Complex& other) const {",
		"            return Complex(real * other.real - imag * other.imag, real * other.imag + imag * other.real);",
		"        }",
		"",
		"        Complex conj() const { return Complex(real, -imag); }",
		"",
		"        T norm() const { return real * real + imag * imag; }",
		"",
		"        T abs() const { return sqrt(norm()); }",
		"    };",
		"",
		"    // 位逆序置换",
		"    void bit_reverse(vector<Complex>& a) {",
		"        int n = a.size();",
		"        for (int i = 1, j = 0; i < n; i++) {",
		"            int bit = n >> 1;",
		"            for (; j & bit; bit >>= 1) { j ^= bit; }",
		"            j ^= bit;",
		"            if (i < j) swap(a[i], a[j]);",
		"        }",
		"    }",
		"",
		"    // FFT主函数",
		"    void fft(vector<Complex>& a, bool invert = false) {",
		"        bit_reverse(a);",
		"        int n = a.size();",
		"",
		"        for (int len = 2; len <= n; len <<= 1) {",
		"            T angle = 2 * PI / len * (invert ? -1 : 1);",
		"            Complex wlen(cos(angle), sin(angle));",
		"",
		"            for (int i = 0; i < n; i += len) {",
		"                Complex w(1);",
		"                for (int j = 0; j < len / 2; j++) {",
		"                    Complex u = a[i + j];",
		"                    Complex v = a[i + j + len / 2] * w;",
		"                    a[i + j] = u + v;",
		"                    a[i + j + len / 2] = u - v;",
		"                    w = w * wlen;",
		"                }",
		"            }",
		"        }",
		"",
		"        if (invert) {",
		"            for (Complex& x : a) {",
		"                x.real /= n;",
		"                x.imag /= n;",
		"            }",
		"        }",
		"    }",
		"",
		"    // 多项式乘法",
		"    vector<T> multiply(vector<T>& a, vector<T>& b) {",
		"        vector<Complex> fa(a.begin(), a.end());",
		"        vector<Complex> fb(b.begin(), b.end());",
		"",
		"        int n = 1;",
		"        while (n < a.size() + b.size()) n <<= 1;",
		"",
		"        fa.resize(n);",
		"        fb.resize(n);",
		"",
		"        fft(fa);",
		"        fft(fb);",
		"",
		"        for (int i = 0; i < n; i++) { fa[i] = fa[i] * fb[i]; }",
		"",
		"        fft(fa, true);",
		"",
		"        vector<T> result(a.size() + b.size() - 1);",
		"        for (int i = 0; i < result.size(); i++) { result[i] = round(fa[i].real); }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 大整数乘法",
		"    string multiply_bigint(string num1, string num2) {",
		"        vector<T> a, b;",
		"",
		"        for (int i = num1.length() - 1; i >= 0; i--) { a.push_back(num1[i] - '0'); }",
		"        for (int i = num2.length() - 1; i >= 0; i--) { b.push_back(num2[i] - '0'); }",
		"",
		"        vector<T> c = multiply(a, b);",
		"",
		"        // 处理进位",
		"        long long carry = 0;",
		"        for (int i = 0; i < c.size(); i++) {",
		"            long long val = (long long)round(c[i]) + carry;",
		"            carry = val / 10;",
		"            c[i] = val % 10;",
		"        }",
		"",
		"        while (carry) {",
		"            c.push_back(carry % 10);",
		"            carry /= 10;",
		"        }",
		"",
		"        // 去除前导零",
		"        while (c.size() > 1 && c.back() == 0) { c.pop_back(); }",
		"",
		"        string result;",
		"        for (int i = c.size() - 1; i >= 0; i--) { result += char('0' + (int)round(c[i])); }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 多项式求逆（模x^n）",
		"    vector<Complex> polynomial_inverse(vector<Complex>& a, int n) {",
		"        if (n == 1) { return {Complex(1.0 / a[0].real)}; }",
		"",
		"        vector<Complex> b = polynomial_inverse(a, (n + 1) / 2);",
		"",
		"        int size = 1;",
		"        while (size < 2 * n) size <<= 1;",
		"",
		"        vector<Complex> fa(a.begin(), a.begin() + min(n, (int)a.size()));",
		"        fa.resize(size);",
		"        b.resize(size);",
		"",
		"        fft(fa);",
		"        fft(b);",
		"",
		"        for (int i = 0; i < size; i++) { fa[i] = b[i] * (Complex(2) - fa[i] * b[i]); }",
		"",
		"        fft(fa, true);",
		"        fa.resize(n);",
		"",
		"        return fa;",
		"    }",
		"",
		"    // 多项式除法",
		"    pair<vector<T>, vector<T>> polynomial_division(vector<T>& dividend, vector<T>& divisor) {",
		"        int n = dividend.size(), m = divisor.size();",
		"        if (n < m) { return {{0}, dividend}; }",
		"",
		"        // 计算商",
		"        vector<T> rev_dividend(dividend.rbegin(), dividend.rend());",
		"        vector<T> rev_divisor(divisor.rbegin(), divisor.rend());",
		"",
		"        rev_dividend.resize(n - m + 1);",
		"        rev_divisor.resize(n - m + 1);",
		"",
		"        vector<T> quotient = multiply(rev_dividend, rev_divisor);",
		"        quotient.resize(n - m + 1);",
		"        reverse(quotient.begin(), quotient.end());",
		"",
		"        // 计算余数",
		"        vector<T> product = multiply(quotient, divisor);",
		"        vector<T> remainder(max(0, m - 1));",
		"",
		"        for (int i = 0; i < remainder.size(); i++) {",
		"            remainder[i] = dividend[i] - (i < product.size() ? product[i] : 0);",
		"        }",
		"",
		"        // 去除前导零",
		"        while (remainder.size() > 1 && remainder.back() == 0) { remainder.pop_back(); }",
		"",
		"        return {quotient, remainder};",
		"    }",
		"",
		"    // 点值插值（拉格朗日插值）",
		"    vector<T> lagrange_interpolation(vector<pair<T, T>>& points) {",
		"        int n = points.size();",
		"        vector<T> result(n, 0);",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            vector<T> term = {1};",
		"            T denominator = 1;",
		"",
		"            for (int j = 0; j < n; j++) {",
		"                if (i != j) {",
		"                    // term *= (x - points[j].first)",
		"                    vector<T> factor = {-points[j].first, 1};",
		"                    term = multiply(term, factor);",
		"",
		"                    denominator *= (points[i].first - points[j].first);",
		"                }",
		"            }",
		"",
		"            // term *= points[i].second / denominator",
		"            for (T& coeff : term) { coeff *= points[i].second / denominator; }",
		"",
		"            // result += term",
		"            result.resize(max(result.size(), term.size()));",
		"            for (int k = 0; k < term.size(); k++) { result[k] += term[k]; }",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"FFT<double> fft;",
		"",
		"// 多项式乘法",
		"vector<double> a = {1, 2, 3};  // 1 + 2x + 3x^2",
		"vector<double> b = {4, 5};     // 4 + 5x",
		"vector<double> c = fft.multiply(a, b);  // 结果: 4 + 13x + 22x^2 + 15x^3",
		"",
		"// 大整数乘法",
		"string result = fft.multiply_bigint(\"123456789\", \"987654321\");",
		"cout << result << endl;",
		"*/",
	})
}),

-- 04_Math\Polynomial\NTT.h
s("04_math_polynomial_ntt_h", {
	t({
		"// 数论变换 (NTT) 模板",
		"template <long long MOD = 998244353, long long G = 3>",
		"struct NTT {",
		"    static constexpr long long mod = MOD;",
		"    static constexpr long long g = G;",
		"",
		"    // 快速幂",
		"    long long power(long long a, long long b, long long m = mod) {",
		"        long long res = 1;",
		"        a %= m;",
		"        while (b > 0) {",
		"            if (b & 1) res = res * a % m;",
		"            a = a * a % m;",
		"            b >>= 1;",
		"        }",
		"        return res;",
		"    }",
		"",
		"    // 位逆序置换",
		"    void bit_reverse(vector<long long>& a) {",
		"        int n = a.size();",
		"        for (int i = 1, j = 0; i < n; i++) {",
		"            int bit = n >> 1;",
		"            for (; j & bit; bit >>= 1) { j ^= bit; }",
		"            j ^= bit;",
		"            if (i < j) swap(a[i], a[j]);",
		"        }",
		"    }",
		"",
		"    // NTT主函数",
		"    void ntt(vector<long long>& a, bool invert = false) {",
		"        bit_reverse(a);",
		"        int n = a.size();",
		"",
		"        for (int len = 2; len <= n; len <<= 1) {",
		"            long long wlen = power(g, (mod - 1) / len);",
		"            if (invert) wlen = power(wlen, mod - 2);",
		"",
		"            for (int i = 0; i < n; i += len) {",
		"                long long w = 1;",
		"                for (int j = 0; j < len / 2; j++) {",
		"                    long long u = a[i + j];",
		"                    long long v = a[i + j + len / 2] * w % mod;",
		"                    a[i + j] = (u + v) % mod;",
		"                    a[i + j + len / 2] = (u - v + mod) % mod;",
		"                    w = w * wlen % mod;",
		"                }",
		"            }",
		"        }",
		"",
		"        if (invert) {",
		"            long long inv_n = power(n, mod - 2);",
		"            for (long long& x : a) { x = x * inv_n % mod; }",
		"        }",
		"    }",
		"",
		"    // 多项式乘法",
		"    vector<long long> multiply(vector<long long> a, vector<long long> b) {",
		"        if (a.empty() || b.empty()) return {};",
		"",
		"        int n = 1;",
		"        while (n < a.size() + b.size()) n <<= 1;",
		"",
		"        a.resize(n);",
		"        b.resize(n);",
		"",
		"        ntt(a);",
		"        ntt(b);",
		"",
		"        for (int i = 0; i < n; i++) { a[i] = a[i] * b[i] % mod; }",
		"",
		"        ntt(a, true);",
		"",
		"        vector<long long> result(a.size() + b.size() - 1);",
		"        for (int i = 0; i < result.size(); i++) { result[i] = a[i]; }",
		"",
		"        // 去除前导零",
		"        while (result.size() > 1 && result.back() == 0) { result.pop_back(); }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 多项式快速幂",
		"    vector<long long> polynomial_power(vector<long long> a, long long k, int n) {",
		"        vector<long long> result = {1};",
		"        a.resize(n);",
		"",
		"        while (k > 0) {",
		"            if (k & 1) {",
		"                result = multiply(result, a);",
		"                result.resize(n);",
		"            }",
		"            a = multiply(a, a);",
		"            a.resize(n);",
		"            k >>= 1;",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 多项式求逆（模x^n）",
		"    vector<long long> polynomial_inverse(vector<long long> a, int n) {",
		"        if (n == 1) { return {power(a[0], mod - 2)}; }",
		"",
		"        vector<long long> b = polynomial_inverse(a, (n + 1) / 2);",
		"",
		"        int size = 1;",
		"        while (size < 2 * n) size <<= 1;",
		"",
		"        vector<long long> fa(a.begin(), a.begin() + min(n, (int)a.size()));",
		"        fa.resize(size);",
		"        b.resize(size);",
		"",
		"        ntt(fa);",
		"        ntt(b);",
		"",
		"        for (int i = 0; i < size; i++) { fa[i] = b[i] * (2 - fa[i] * b[i] % mod + mod) % mod; }",
		"",
		"        ntt(fa, true);",
		"        fa.resize(n);",
		"",
		"        return fa;",
		"    }",
		"",
		"    // 多项式除法",
		"    pair<vector<long long>, vector<long long>> polynomial_division(vector<long long> dividend,",
		"                                                                   vector<long long> divisor) {",
		"        int n = dividend.size(), m = divisor.size();",
		"        if (n < m) { return {{0}, dividend}; }",
		"",
		"        // 计算商",
		"        vector<long long> rev_dividend(dividend.rbegin(), dividend.rend());",
		"        vector<long long> rev_divisor(divisor.rbegin(), divisor.rend());",
		"",
		"        vector<long long> inv_divisor = polynomial_inverse(rev_divisor, n - m + 1);",
		"        vector<long long> quotient = multiply(rev_dividend, inv_divisor);",
		"        quotient.resize(n - m + 1);",
		"        reverse(quotient.begin(), quotient.end());",
		"",
		"        // 计算余数",
		"        vector<long long> product = multiply(quotient, divisor);",
		"        vector<long long> remainder(max(0, m - 1));",
		"",
		"        for (int i = 0; i < remainder.size(); i++) {",
		"            remainder[i] = (dividend[i] - (i < product.size() ? product[i] : 0) + mod) % mod;",
		"        }",
		"",
		"        // 去除前导零",
		"        while (remainder.size() > 1 && remainder.back() == 0) { remainder.pop_back(); }",
		"",
		"        return {quotient, remainder};",
		"    }",
		"",
		"    // 多项式对数",
		"    vector<long long> polynomial_log(vector<long long> a, int n) {",
		"        if (a[0] != 1) return {};  // 要求常数项为1",
		"",
		"        // ln(a) = ∫(a'/a)dx",
		"        vector<long long> a_derivative(n - 1);",
		"        for (int i = 1; i < n; i++) { a_derivative[i - 1] = a[i] * i % mod; }",
		"",
		"        vector<long long> a_inv = polynomial_inverse(a, n - 1);",
		"        vector<long long> result = multiply(a_derivative, a_inv);",
		"        result.resize(n - 1);",
		"",
		"        // 积分",
		"        vector<long long> log_a(n);",
		"        for (int i = 1; i < n; i++) { log_a[i] = result[i - 1] * power(i, mod - 2) % mod; }",
		"",
		"        return log_a;",
		"    }",
		"",
		"    // 多项式指数",
		"    vector<long long> polynomial_exp(vector<long long> a, int n) {",
		"        if (a[0] != 0) return {};  // 要求常数项为0",
		"",
		"        vector<long long> result = {1};",
		"",
		"        for (int len = 1; len < n; len <<= 1) {",
		"            vector<long long> log_result = polynomial_log(result, 2 * len);",
		"",
		"            for (int i = 0; i < 2 * len; i++) { log_result[i] = (a[i] - log_result[i] + mod) % mod; }",
		"            log_result[0] = (log_result[0] + 1) % mod;",
		"",
		"            result = multiply(result, log_result);",
		"            result.resize(2 * len);",
		"        }",
		"",
		"        result.resize(n);",
		"        return result;",
		"    }",
		"",
		"    // 多项式开根",
		"    vector<long long> polynomial_sqrt(vector<long long> a, int n) {",
		"        if (a[0] != 1) return {};  // 这里简化为常数项为1的情况",
		"",
		"        vector<long long> result = {1};",
		"        long long inv2 = power(2, mod - 2);",
		"",
		"        for (int len = 1; len < n; len <<= 1) {",
		"            vector<long long> inv_result = polynomial_inverse(result, 2 * len);",
		"",
		"            vector<long long> temp(a.begin(), a.begin() + min(2 * len, (int)a.size()));",
		"            temp.resize(2 * len);",
		"",
		"            temp = multiply(temp, inv_result);",
		"            temp.resize(2 * len);",
		"",
		"            for (int i = 0; i < 2 * len; i++) { temp[i] = (temp[i] + result[i]) * inv2 % mod; }",
		"",
		"            result = temp;",
		"        }",
		"",
		"        result.resize(n);",
		"        return result;",
		"    }",
		"",
		"    // 多点求值",
		"    vector<long long> multipoint_evaluation(vector<long long>& poly, vector<long long>& points) {",
		"        int n = points.size();",
		"        if (n == 0) return {};",
		"",
		"        // 构建子积树",
		"        vector<vector<vector<long long>>> tree(4 * n);",
		"        function<void(int, int, int)> build = [&](int v, int tl, int tr) {",
		"            if (tl == tr) {",
		"                tree[v] = {(mod - points[tl]) % mod, 1};",
		"            } else {",
		"                int tm = (tl + tr) / 2;",
		"                build(2 * v, tl, tm);",
		"                build(2 * v + 1, tm + 1, tr);",
		"                tree[v] = multiply(tree[2 * v], tree[2 * v + 1]);",
		"            }",
		"        };",
		"",
		"        build(1, 0, n - 1);",
		"",
		"        // 递归求值",
		"        vector<long long> result(n);",
		"        function<void(int, int, int, vector<long long>)> evaluate =",
		"            [&](int v, int tl, int tr, vector<long long> remainder) {",
		"                if (tl == tr) {",
		"                    result[tl] = remainder.empty() ? 0 : remainder[0];",
		"                } else {",
		"                    int tm = (tl + tr) / 2;",
		"",
		"                    auto [q1, r1] = polynomial_division(remainder, tree[2 * v]);",
		"                    auto [q2, r2] = polynomial_division(remainder, tree[2 * v + 1]);",
		"",
		"                    evaluate(2 * v, tl, tm, r1);",
		"                    evaluate(2 * v + 1, tm + 1, tr, r2);",
		"                }",
		"            };",
		"",
		"        evaluate(1, 0, n - 1, poly);",
		"        return result;",
		"    }",
		"};",
		"",
		"using NTT998 = NTT<998244353, 3>;",
		"using NTT1004 = NTT<1004535809, 3>;",
		"using NTT469 = NTT<469762049, 3>;",
		"",
		"// 使用示例",
		"/*",
		"NTT998 ntt;",
		"",
		"// 多项式乘法",
		"vector<long long> a = {1, 2, 3};  // 1 + 2x + 3x^2",
		"vector<long long> b = {4, 5};     // 4 + 5x",
		"vector<long long> c = ntt.multiply(a, b);  // 结果: 4 + 13x + 22x^2 + 15x^3",
		"",
		"// 多项式求逆",
		"vector<long long> inv_a = ntt.polynomial_inverse(a, 10);",
		"*/",
	})
}),

-- 05_Geometry\2D\Circle.h
s("05_geometry_2d_circle_h", {
	t({
		"/**",
		" * 二维圆类模板",
		" * 时间复杂度：各操作均为 O(1)，求圆交点为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：圆相关的几何计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 使用Point类（需要包含Point.h）",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"struct Line {",
		"    Point a, b;",
		"    Line() {}",
		"    Line(const Point& a, const Point& b) : a(a), b(b) {}",
		"    Point direction() const { return b - a; }",
		"    Point point_at(double t) const { return a + direction() * t; }",
		"};",
		"",
		"// 圆类",
		"struct Circle {",
		"    Point center;   // 圆心",
		"    double radius;  // 半径",
		"",
		"    // 构造函数",
		"    Circle() : radius(0) {}",
		"    Circle(const Point& c, double r) : center(c), radius(r) {}",
		"    Circle(double x, double y, double r) : center(Point(x, y)), radius(r) {}",
		"",
		"    // 比较运算符",
		"    bool operator==(const Circle& other) const { return center == other.center && abs(radius - other.radius) < EPS; }",
		"",
		"    // 圆的基本属性",
		"    double area() const { return PI * radius * radius; }",
		"    double circumference() const { return 2 * PI * radius; }",
		"    double diameter() const { return 2 * radius; }",
		"",
		"    // 点与圆的关系",
		"    // 返回值：-1内部，0边界，1外部",
		"    int point_relation(const Point& p) const {",
		"        double d = center.distance(p);",
		"        if (d < radius - EPS) return -1;  // 内部",
		"        if (d > radius + EPS) return 1;   // 外部",
		"        return 0;                         // 边界",
		"    }",
		"",
		"    bool contains(const Point& p) const { return point_relation(p) <= 0; }",
		"    bool contains_strictly(const Point& p) const { return point_relation(p) < 0; }",
		"    bool on_circle(const Point& p) const { return point_relation(p) == 0; }",
		"",
		"    // 点到圆的最近距离",
		"    double distance_to_point(const Point& p) const { return max(0.0, center.distance(p) - radius); }",
		"",
		"    // 直线与圆的关系",
		"    // 返回值：-1相离，0相切，1相交",
		"    int line_relation(const Line& line) const {",
		"        Point dir = line.direction();",
		"        Point to_center = center - line.a;",
		"        double d = abs(dir.cross(to_center)) / dir.norm();  // 圆心到直线距离",
		"",
		"        if (d > radius + EPS) return -1;  // 相离",
		"        if (d < radius - EPS) return 1;   // 相交",
		"        return 0;                         // 相切",
		"    }",
		"",
		"    // 直线与圆的交点",
		"    vector<Point> line_intersection(const Line& line) const {",
		"        vector<Point> result;",
		"",
		"        Point dir = line.direction();",
		"        Point to_center = center - line.a;",
		"        double d = abs(dir.cross(to_center)) / dir.norm();  // 圆心到直线距离",
		"",
		"        if (d > radius + EPS) return result;  // 无交点",
		"",
		"        // 圆心在直线上的投影",
		"        double t = dir.dot(to_center) / dir.norm2();",
		"        Point proj = line.point_at(t);",
		"",
		"        if (abs(d - radius) < EPS) {",
		"            // 相切，一个交点",
		"            result.push_back(proj);",
		"        } else {",
		"            // 相交，两个交点",
		"            double delta = sqrt(radius * radius - d * d);",
		"            Point unit_dir = dir / dir.norm();",
		"            result.push_back(proj + unit_dir * delta);",
		"            result.push_back(proj - unit_dir * delta);",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 两圆关系",
		"    // 返回值：-1外离，0外切，1相交，2内切，3内含",
		"    int circle_relation(const Circle& other) const {",
		"        double d = center.distance(other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        if (d > r1 + r2 + EPS) return -1;           // 外离",
		"        if (abs(d - r1 - r2) < EPS) return 0;       // 外切",
		"        if (abs(d - abs(r1 - r2)) < EPS) return 2;  // 内切",
		"        if (d < abs(r1 - r2) - EPS) return 3;       // 内含",
		"        return 1;                                   // 相交",
		"    }",
		"",
		"    // 两圆交点",
		"    vector<Point> circle_intersection(const Circle& other) const {",
		"        vector<Point> result;",
		"",
		"        double d = center.distance(other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        // 无交点的情况",
		"        if (d > r1 + r2 + EPS || d < abs(r1 - r2) - EPS || d < EPS) { return result; }",
		"",
		"        // 计算交点",
		"        double a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);",
		"        double h = sqrt(r1 * r1 - a * a);",
		"",
		"        Point mid = center + (other.center - center) * (a / d);",
		"",
		"        if (abs(h) < EPS) {",
		"            // 一个交点（相切）",
		"            result.push_back(mid);",
		"        } else {",
		"            // 两个交点",
		"            Point dir = (other.center - center) / d;",
		"            Point perp(-dir.y, dir.x);  // 垂直方向",
		"            result.push_back(mid + perp * h);",
		"            result.push_back(mid - perp * h);",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 过圆外一点的切线",
		"    vector<Line> tangent_lines(const Point& p) const {",
		"        vector<Line> result;",
		"",
		"        if (contains_strictly(p)) return result;  // 点在圆内无切线",
		"",
		"        double d = center.distance(p);",
		"        if (on_circle(p)) {",
		"            // 点在圆上，一条切线",
		"            Point to_p = p - center;",
		"            Point tangent_dir(-to_p.y, to_p.x);  // 垂直方向",
		"            result.push_back(Line(p, p + tangent_dir));",
		"            return result;",
		"        }",
		"",
		"        // 点在圆外，两条切线",
		"        double angle = asin(radius / d);",
		"        Point to_p = p - center;",
		"        double base_angle = atan2(to_p.y, to_p.x);",
		"",
		"        // 两个切点方向",
		"        double angle1 = base_angle + angle;",
		"        double angle2 = base_angle - angle;",
		"",
		"        Point tangent1 = center + Point(cos(angle1), sin(angle1)) * radius;",
		"        Point tangent2 = center + Point(cos(angle2), sin(angle2)) * radius;",
		"",
		"        result.push_back(Line(p, tangent1));",
		"        result.push_back(Line(p, tangent2));",
		"",
		"        return result;",
		"    }",
		"};",
		"",
		"// 三点确定圆（外接圆或内切圆）",
		"Circle triangle_circle(const Point& a, const Point& b, const Point& c, bool circumcircle = true) {",
		"    if (circumcircle) {",
		"        // 外接圆",
		"        double d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));",
		"        if (abs(d) < EPS) return Circle(Point(0, 0), -1);  // 三点共线",
		"",
		"        double ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) +",
		"                     (c.x * c.x + c.y * c.y) * (a.y - b.y)) /",
		"                    d;",
		"        double uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) +",
		"                     (c.x * c.x + c.y * c.y) * (b.x - a.x)) /",
		"                    d;",
		"",
		"        Point center(ux, uy);",
		"        double radius = center.distance(a);",
		"        return Circle(center, radius);",
		"    } else {",
		"        // 内切圆",
		"        double side_a = b.distance(c);  // BC边长",
		"        double side_b = a.distance(c);  // AC边长",
		"        double side_c = a.distance(b);  // AB边长",
		"        double perimeter = side_a + side_b + side_c;",
		"",
		"        if (perimeter < EPS) return Circle(Point(0, 0), -1);  // 退化三角形",
		"",
		"        // 内心坐标（重心坐标）",
		"        double cx = (side_a * a.x + side_b * b.x + side_c * c.x) / perimeter;",
		"        double cy = (side_a * a.y + side_b * b.y + side_c * c.y) / perimeter;",
		"        Point center(cx, cy);",
		"",
		"        // 半周长",
		"        double s = perimeter / 2.0;",
		"",
		"        // 内切圆半径：面积/半周长",
		"        double area = abs((b - a).cross(c - a)) / 2.0;",
		"        double radius = area / s;",
		"",
		"        return Circle(center, radius);",
		"    }",
		"}",
		"",
		"// 三点确定圆（外接圆）- 保持向后兼容",
		"Circle circumcircle(const Point& a, const Point& b, const Point& c) { return triangle_circle(a, b, c, true); }",
		"",
		"// 三点确定内切圆",
		"Circle incircle(const Point& a, const Point& b, const Point& c) { return triangle_circle(a, b, c, false); }",
		"",
		"// 两点间距离的圆（以两点连线为直径）",
		"Circle diameter_circle(const Point& a, const Point& b) {",
		"    Point center = (a + b) * 0.5;",
		"    double radius = a.distance(b) * 0.5;",
		"    return Circle(center, radius);",
		"}",
		"",
		"// 最小圆覆盖（增量算法）",
		"Circle min_enclosing_circle(vector<Point> points) {",
		"    if (points.empty()) return Circle();",
		"    if (points.size() == 1) return Circle(points[0], 0);",
		"",
		"    random_shuffle(points.begin(), points.end());",
		"",
		"    Circle circle = diameter_circle(points[0], points[1]);",
		"",
		"    for (int i = 2; i < points.size(); i++) {",
		"        if (!circle.contains(points[i])) {",
		"            circle = diameter_circle(points[0], points[i]);",
		"            for (int j = 1; j < i; j++) {",
		"                if (!circle.contains(points[j])) {",
		"                    circle = diameter_circle(points[i], points[j]);",
		"                    for (int k = 0; k < j; k++) {",
		"                        if (!circle.contains(points[k])) { circle = circumcircle(points[i], points[j], points[k]); }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    return circle;",
		"}",
	})
}),

-- 05_Geometry\2D\ConvexHull.h
s("05_geometry_2d_convexhull_h", {
	t({
		"/**",
		" * 二维凸包算法模板",
		" * 时间复杂度：O(n log n)",
		" * 空间复杂度：O(n)",
		" * 适用场景：求点集的凸包，凸包相关计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 使用Point类（需要包含Point.h）",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator<(const Point& p) const { return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"// Andrew算法求凸包",
		"vector<Point> convex_hull(vector<Point> points) {",
		"    int n = points.size();",
		"    if (n <= 1) return points;",
		"",
		"    sort(points.begin(), points.end());",
		"",
		"    // 构建下凸包",
		"    vector<Point> hull;",
		"    for (int i = 0; i < n; i++) {",
		"        while (hull.size() >= 2 &&",
		"               (hull[hull.size() - 1] - hull[hull.size() - 2]).cross(points[i] - hull[hull.size() - 2]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    // 构建上凸包",
		"    int lower_size = hull.size();",
		"    for (int i = n - 2; i >= 0; i--) {",
		"        while (hull.size() > lower_size &&",
		"               (hull[hull.size() - 1] - hull[hull.size() - 2]).cross(points[i] - hull[hull.size() - 2]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    if (hull.size() > 1) hull.pop_back();  // 移除重复的起点",
		"    return hull;",
		"}",
		"",
		"// Graham扫描法求凸包",
		"vector<Point> graham_scan(vector<Point> points) {",
		"    int n = points.size();",
		"    if (n <= 1) return points;",
		"",
		"    // 找到最下方的点（y坐标最小，相同时x坐标最小）",
		"    int bottom = 0;",
		"    for (int i = 1; i < n; i++) {",
		"        if (points[i].y < points[bottom].y ||",
		"            (abs(points[i].y - points[bottom].y) < EPS && points[i].x < points[bottom].x)) {",
		"            bottom = i;",
		"        }",
		"    }",
		"    swap(points[0], points[bottom]);",
		"",
		"    Point pivot = points[0];",
		"",
		"    // 按极角排序",
		"    sort(points.begin() + 1, points.end(), [&](const Point& a, const Point& b) {",
		"        double cross_val = (a - pivot).cross(b - pivot);",
		"        if (abs(cross_val) > EPS) return cross_val > 0;",
		"        return pivot.distance(a) < pivot.distance(b);",
		"    });",
		"",
		"    vector<Point> hull;",
		"    for (const Point& p : points) {",
		"        while (hull.size() >= 2 &&",
		"               (hull[hull.size() - 1] - hull[hull.size() - 2]).cross(p - hull[hull.size() - 2]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(p);",
		"    }",
		"",
		"    return hull;",
		"}",
		"",
		"// 判断点是否在凸多边形内（射线法）",
		"bool point_in_convex_polygon(const Point& p, const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    if (n < 3) return false;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        Point a = poly[i];",
		"        Point b = poly[(i + 1) % n];",
		"        if ((b - a).cross(p - a) < -EPS) {",
		"            return false;  // 在边的右侧，不在凸包内",
		"        }",
		"    }",
		"    return true;",
		"}",
		"",
		"// 判断点是否在任意多边形内（射线法）",
		"bool point_in_polygon(const Point& p, const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    bool inside = false;",
		"",
		"    for (int i = 0, j = n - 1; i < n; j = i++) {",
		"        if (((poly[i].y > p.y) != (poly[j].y > p.y)) &&",
		"            (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) {",
		"            inside = !inside;",
		"        }",
		"    }",
		"    return inside;",
		"}",
		"",
		"// 多边形面积（有向面积，逆时针为正）",
		"double polygon_area(const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    if (n < 3) return 0;",
		"",
		"    double area = 0;",
		"    for (int i = 0; i < n; i++) { area += poly[i].cross(poly[(i + 1) % n]); }",
		"    return area / 2.0;",
		"}",
		"",
		"// 多边形周长",
		"double polygon_perimeter(const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    if (n < 2) return 0;",
		"",
		"    double perimeter = 0;",
		"    for (int i = 0; i < n; i++) { perimeter += poly[i].distance(poly[(i + 1) % n]); }",
		"    return perimeter;",
		"}",
		"",
		"// 凸包直径（旋转卡壳算法）",
		"double convex_hull_diameter(const vector<Point>& hull) {",
		"    int n = hull.size();",
		"    if (n <= 1) return 0;",
		"    if (n == 2) return hull[0].distance(hull[1]);",
		"",
		"    double max_dist = 0;",
		"    int j = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        Point edge = hull[(i + 1) % n] - hull[i];",
		"",
		"        // 找到与当前边距离最大的点",
		"        while (true) {",
		"            int next_j = (j + 1) % n;",
		"            Point to_j = hull[j] - hull[i];",
		"            Point to_next_j = hull[next_j] - hull[i];",
		"",
		"            if (edge.cross(to_next_j) > edge.cross(to_j)) {",
		"                j = next_j;",
		"            } else {",
		"                break;",
		"            }",
		"        }",
		"",
		"        max_dist = max(max_dist, hull[i].distance(hull[j]));",
		"        max_dist = max(max_dist, hull[(i + 1) % n].distance(hull[j]));",
		"    }",
		"",
		"    return max_dist;",
		"}",
		"",
		"// 最小外接矩形面积（旋转卡壳）",
		"double min_bounding_rectangle_area(const vector<Point>& hull) {",
		"    int n = hull.size();",
		"    if (n <= 2) return 0;",
		"",
		"    double min_area = 1e18;",
		"    int right = 1, top = 1, left = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        Point edge = hull[(i + 1) % n] - hull[i];",
		"        Point normal(-edge.y, edge.x);  // 法向量",
		"",
		"        // 找到四个方向的极值点",
		"        while ((hull[(right + 1) % n] - hull[right]).dot(edge) > EPS) { right = (right + 1) % n; }",
		"        while ((hull[(top + 1) % n] - hull[top]).dot(normal) > EPS) { top = (top + 1) % n; }",
		"        while ((hull[(left + 1) % n] - hull[left]).dot(edge) < -EPS) { left = (left + 1) % n; }",
		"",
		"        // 计算矩形面积",
		"        double width = (hull[right] - hull[left]).dot(edge) / edge.norm();",
		"        double height = (hull[top] - hull[i]).dot(normal) / normal.norm();",
		"        min_area = min(min_area, width * height);",
		"    }",
		"",
		"    return min_area;",
		"}",
		"",
		"// 最小外接圆（Welzl算法的简化版本）",
		"struct Circle {",
		"    Point center;",
		"    double radius;",
		"    Circle() : radius(0) {}",
		"    Circle(const Point& c, double r) : center(c), radius(r) {}",
		"    bool contains(const Point& p) const { return center.distance(p) <= radius + EPS; }",
		"};",
		"",
		"Circle smallest_enclosing_circle(vector<Point> points) {",
		"    random_shuffle(points.begin(), points.end());",
		"",
		"    Circle circle;",
		"    int n = points.size();",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        if (!circle.contains(points[i])) {",
		"            circle = Circle(points[i], 0);",
		"            for (int j = 0; j < i; j++) {",
		"                if (!circle.contains(points[j])) {",
		"                    circle = Circle((points[i] + points[j]) * 0.5, points[i].distance(points[j]) * 0.5);",
		"                    for (int k = 0; k < j; k++) {",
		"                        if (!circle.contains(points[k])) {",
		"                            // 三点确定圆",
		"                            Point a = points[i], b = points[j], c = points[k];",
		"                            double d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));",
		"                            if (abs(d) > EPS) {",
		"                                double ux =",
		"                                    ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) +",
		"                                     (c.x * c.x + c.y * c.y) * (a.y - b.y)) /",
		"                                    d;",
		"                                double uy =",
		"                                    ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) +",
		"                                     (c.x * c.x + c.y * c.y) * (b.x - a.x)) /",
		"                                    d;",
		"                                Point center(ux, uy);",
		"                                circle = Circle(center, center.distance(a));",
		"                            }",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    return circle;",
		"}",
	})
}),

-- 05_Geometry\2D\Geometry2D.h
s("05_geometry_2d_geometry2d_h", {
	t({
		"/**",
		" * 完整的二维几何模板",
		" * 包含：点、向量、直线、线段、圆、多边形等所有基本几何类型和算法",
		" * 时间复杂度：各操作复杂度见具体函数注释",
		" * 空间复杂度：O(1) 到 O(n)",
		" * 适用场景：各种二维几何问题的完整解决方案",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 精度比较函数",
		"int sgn(double x) { return (x > EPS) - (x < -EPS); }",
		"",
		"// 二维点/向量类",
		"struct Point {",
		"    double x, y;",
		"",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"",
		"    // 基本运算",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    Point operator-() const { return Point(-x, -y); }",
		"",
		"    Point& operator+=(const Point& p) {",
		"        x += p.x;",
		"        y += p.y;",
		"        return *this;",
		"    }",
		"    Point& operator-=(const Point& p) {",
		"        x -= p.x;",
		"        y -= p.y;",
		"        return *this;",
		"    }",
		"    Point& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        return *this;",
		"    }",
		"    Point& operator/=(double t) {",
		"        x /= t;",
		"        y /= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算",
		"    bool operator<(const Point& p) const { return sgn(x - p.x) ? x < p.x : y < p.y; }",
		"    bool operator==(const Point& p) const { return !sgn(x - p.x) && !sgn(y - p.y); }",
		"    bool operator!=(const Point& p) const { return !(*this == p); }",
		"",
		"    // 向量运算",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"",
		"    // 长度和距离",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point& p) const { return (*this - p).norm2(); }",
		"",
		"    // 角度和旋转",
		"    double angle() const { return atan2(y, x); }",
		"    Point rotate(double theta) const {",
		"        double c = cos(theta), s = sin(theta);",
		"        return Point(x * c - y * s, x * s + y * c);",
		"    }",
		"    Point rotate90() const { return Point(-y, x); }",
		"    Point normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point() : *this / len;",
		"    }",
		"",
		"    // 输入输出",
		"    void read() { cin >> x >> y; }",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \"\\n\"; }",
		"};",
		"",
		"using Vector = Point;",
		"",
		"// 全局几何函数",
		"double cross(const Point& a, const Point& b) { return a.cross(b); }",
		"double dot(const Point& a, const Point& b) { return a.dot(b); }",
		"double distance(const Point& a, const Point& b) { return a.distance(b); }",
		"",
		"// 三点关系判断",
		"double orientation(const Point& a, const Point& b, const Point& c) { return cross(b - a, c - a); }",
		"",
		"// 二维直线类",
		"struct Line {",
		"    Point a, b;",
		"",
		"    Line() {}",
		"    Line(const Point& a, const Point& b) : a(a), b(b) {}",
		"    Line(double x1, double y1, double x2, double y2) : a(x1, y1), b(x2, y2) {}",
		"",
		"    // 从一般式方程构造 Ax + By + C = 0",
		"    Line(double A, double B, double C) {",
		"        if (abs(A) < EPS) {",
		"            a = Point(0, -C / B);",
		"            b = Point(1, -C / B);",
		"        } else if (abs(B) < EPS) {",
		"            a = Point(-C / A, 0);",
		"            b = Point(-C / A, 1);",
		"        } else {",
		"            a = Point(0, -C / B);",
		"            b = Point(1, (-C - A) / B);",
		"        }",
		"    }",
		"",
		"    Point direction() const { return b - a; }",
		"    Point normal() const { return (b - a).rotate90(); }",
		"    Point point_at(double t) const { return a + direction() * t; }",
		"",
		"    // 点到直线距离",
		"    double distance_to_point(const Point& p) const { return abs(cross(p - a, direction())) / direction().norm(); }",
		"",
		"    // 点在直线上的投影",
		"    Point project_point(const Point& p) const {",
		"        Vector dir = direction();",
		"        double t = dot(p - a, dir) / dir.norm2();",
		"        return point_at(t);",
		"    }",
		"",
		"    // 直线交点",
		"    Point intersection(const Line& other) const {",
		"        Vector d1 = direction(), d2 = other.direction();",
		"        double det = cross(d1, d2);",
		"        if (abs(det) < EPS) return Point(1e18, 1e18);  // 平行",
		"        double t = cross(other.a - a, d2) / det;",
		"        return point_at(t);",
		"    }",
		"",
		"    bool is_parallel(const Line& other) const { return abs(cross(direction(), other.direction())) < EPS; }",
		"};",
		"",
		"// 线段类",
		"struct Segment {",
		"    Point a, b;",
		"",
		"    Segment() {}",
		"    Segment(const Point& a, const Point& b) : a(a), b(b) {}",
		"",
		"    double length() const { return distance(a, b); }",
		"    Point midpoint() const { return (a + b) * 0.5; }",
		"    Line to_line() const { return Line(a, b); }",
		"",
		"    // 点到线段距离",
		"    double distance_to_point(const Point& p) const {",
		"        Vector ap = p - a, ab = b - a;",
		"        double t = dot(ap, ab) / ab.norm2();",
		"        if (t < 0) return distance(p, a);",
		"        if (t > 1) return distance(p, b);",
		"        return distance(p, a + ab * t);",
		"    }",
		"",
		"    // 判断点是否在线段上",
		"    bool contains_point(const Point& p) const { return abs(cross(p - a, b - a)) < EPS && dot(p - a, p - b) <= EPS; }",
		"",
		"    // 线段相交判断",
		"    bool intersects(const Segment& other) const {",
		"        Point A = a, B = b, C = other.a, D = other.b;",
		"        double c1 = cross(B - A, C - A);",
		"        double c2 = cross(B - A, D - A);",
		"        double c3 = cross(D - C, A - C);",
		"        double c4 = cross(D - C, B - C);",
		"",
		"        if (abs(c1) < EPS && abs(c2) < EPS) {  // 共线",
		"            return max(min(A.x, B.x), min(C.x, D.x)) <= min(max(A.x, B.x), max(C.x, D.x)) + EPS &&",
		"                   max(min(A.y, B.y), min(C.y, D.y)) <= min(max(A.y, B.y), max(C.y, D.y)) + EPS;",
		"        }",
		"",
		"        return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0;",
		"    }",
		"",
		"    // 线段交点",
		"    Point intersection(const Segment& other) const {",
		"        Line l1 = to_line(), l2 = other.to_line();",
		"        Point inter = l1.intersection(l2);",
		"        if (inter.x > 1e17) return inter;",
		"        if (contains_point(inter) && other.contains_point(inter)) return inter;",
		"        return Point(1e18, 1e18);",
		"    }",
		"};",
		"",
		"// 圆类",
		"struct Circle {",
		"    Point center;",
		"    double radius;",
		"",
		"    Circle() : radius(0) {}",
		"    Circle(const Point& c, double r) : center(c), radius(r) {}",
		"    Circle(double x, double y, double r) : center(x, y), radius(r) {}",
		"",
		"    double area() const { return PI * radius * radius; }",
		"    double circumference() const { return 2 * PI * radius; }",
		"",
		"    // 点与圆的关系：-1内部，0边界，1外部",
		"    int point_relation(const Point& p) const {",
		"        double d = distance(center, p);",
		"        return sgn(d - radius);",
		"    }",
		"",
		"    bool contains(const Point& p) const { return point_relation(p) <= 0; }",
		"    bool on_circle(const Point& p) const { return point_relation(p) == 0; }",
		"",
		"    // 直线与圆的交点",
		"    vector<Point> line_intersection(const Line& line) const {",
		"        vector<Point> result;",
		"        double d = line.distance_to_point(center);",
		"        if (d > radius + EPS) return result;",
		"",
		"        Point proj = line.project_point(center);",
		"        if (abs(d - radius) < EPS) {",
		"            result.push_back(proj);",
		"        } else {",
		"            double delta = sqrt(radius * radius - d * d);",
		"            Vector unit_dir = line.direction().normalize();",
		"            result.push_back(proj + unit_dir * delta);",
		"            result.push_back(proj - unit_dir * delta);",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 两圆交点",
		"    vector<Point> circle_intersection(const Circle& other) const {",
		"        vector<Point> result;",
		"        double d = distance(center, other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        if (d > r1 + r2 + EPS || d < abs(r1 - r2) - EPS || d < EPS) return result;",
		"",
		"        double a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);",
		"        double h = sqrt(r1 * r1 - a * a);",
		"        Point mid = center + (other.center - center) * (a / d);",
		"",
		"        if (abs(h) < EPS) {",
		"            result.push_back(mid);",
		"        } else {",
		"            Vector perp = ((other.center - center) / d).rotate90();",
		"            result.push_back(mid + perp * h);",
		"            result.push_back(mid - perp * h);",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// 三点确定圆",
		"Circle circumcircle(const Point& a, const Point& b, const Point& c) {",
		"    double d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));",
		"    if (abs(d) < EPS) return Circle(Point(0, 0), -1);",
		"",
		"    double ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) +",
		"                 (c.x * c.x + c.y * c.y) * (a.y - b.y)) /",
		"                d;",
		"    double uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) +",
		"                 (c.x * c.x + c.y * c.y) * (b.x - a.x)) /",
		"                d;",
		"",
		"    Point center(ux, uy);",
		"    return Circle(center, distance(center, a));",
		"}",
		"",
		"// 多边形类",
		"struct Polygon {",
		"    vector<Point> vertices;",
		"",
		"    Polygon() {}",
		"    Polygon(const vector<Point>& v) : vertices(v) {}",
		"",
		"    int size() const { return vertices.size(); }",
		"    Point& operator[](int i) { return vertices[i]; }",
		"    const Point& operator[](int i) const { return vertices[i]; }",
		"",
		"    // 多边形面积（有向面积）",
		"    double area() const {",
		"        double res = 0;",
		"        int n = size();",
		"        for (int i = 0; i < n; i++) { res += cross(vertices[i], vertices[(i + 1) % n]); }",
		"        return res / 2;",
		"    }",
		"",
		"    // 多边形周长",
		"    double perimeter() const {",
		"        double res = 0;",
		"        int n = size();",
		"        for (int i = 0; i < n; i++) { res += distance(vertices[i], vertices[(i + 1) % n]); }",
		"        return res;",
		"    }",
		"",
		"    // 判断点是否在多边形内（射线法）",
		"    bool contains_point(const Point& p) const {",
		"        int n = size();",
		"        bool inside = false;",
		"        for (int i = 0, j = n - 1; i < n; j = i++) {",
		"            if (((vertices[i].y > p.y) != (vertices[j].y > p.y)) &&",
		"                (p.x < (vertices[j].x - vertices[i].x) * (p.y - vertices[i].y) / (vertices[j].y - vertices[i].y) +",
		"                           vertices[i].x)) {",
		"                inside = !inside;",
		"            }",
		"        }",
		"        return inside;",
		"    }",
		"};",
		"",
		"// 凸包算法（Andrew算法）",
		"vector<Point> convex_hull(vector<Point> points) {",
		"    sort(points.begin(), points.end());",
		"    int n = points.size();",
		"    if (n <= 1) return points;",
		"",
		"    vector<Point> hull;",
		"    // 下凸包",
		"    for (int i = 0; i < n; i++) {",
		"        while (hull.size() >= 2 && orientation(hull[hull.size() - 2], hull[hull.size() - 1], points[i]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    // 上凸包",
		"    int lower_size = hull.size();",
		"    for (int i = n - 2; i >= 0; i--) {",
		"        while (hull.size() > lower_size &&",
		"               orientation(hull[hull.size() - 2], hull[hull.size() - 1], points[i]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    if (hull.size() > 1) hull.pop_back();",
		"    return hull;",
		"}",
		"",
		"// 判断点是否在凸多边形内",
		"bool point_in_convex_polygon(const Point& p, const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    for (int i = 0; i < n; i++) {",
		"        if (cross(poly[(i + 1) % n] - poly[i], p - poly[i]) < -EPS) { return false; }",
		"    }",
		"    return true;",
		"}",
		"",
		"// 旋转卡壳求凸包直径",
		"double convex_diameter(const vector<Point>& hull) {",
		"    int n = hull.size();",
		"    if (n <= 1) return 0;",
		"    if (n == 2) return distance(hull[0], hull[1]);",
		"",
		"    double max_dist = 0;",
		"    int j = 1;",
		"    for (int i = 0; i < n; i++) {",
		"        Vector edge = hull[(i + 1) % n] - hull[i];",
		"        while (cross(edge, hull[(j + 1) % n] - hull[i]) > cross(edge, hull[j] - hull[i])) { j = (j + 1) % n; }",
		"        max_dist = max(max_dist, max(distance(hull[i], hull[j]), distance(hull[(i + 1) % n], hull[j])));",
		"    }",
		"    return max_dist;",
		"}",
	})
}),

-- 05_Geometry\2D\HalfPlaneIntersection.h
s("05_geometry_2d_halfplaneintersection_h", {
	t({
		"/*",
		" * 半平面交算法",
		" * 时间复杂度: O(n log n)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 求多个半平面的交集",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double angle() const { return atan2(y, x); }",
		"};",
		"",
		"struct Line {",
		"    Point a, b;    // 直线上两点",
		"    double angle;  // 直线方向角",
		"",
		"    Line() {}",
		"    Line(const Point& a, const Point& b) : a(a), b(b) { angle = (b - a).angle(); }",
		"    Line(const Point& p, double theta) : a(p) {",
		"        b = a + Point(cos(theta), sin(theta));",
		"        angle = theta;",
		"    }",
		"",
		"    // 判断点在直线左侧（半平面内）",
		"    bool on_left(const Point& p) const { return (b - a).cross(p - a) > EPS; }",
		"",
		"    // 两直线交点",
		"    Point intersection(const Line& other) const {",
		"        Point u = a - other.a;",
		"        Point v1 = b - a;",
		"        Point v2 = other.b - other.a;",
		"        double t = (u ^ v2) / (v1 ^ v2);",
		"        return a + v1 * t;",
		"    }",
		"",
		"    // 用于排序的比较函数",
		"    bool operator<(const Line& other) const {",
		"        if (abs(angle - other.angle) < EPS) { return on_left(other.a); }",
		"        return angle < other.angle;",
		"    }",
		"};",
		"",
		"// 半平面交",
		"vector<Point> half_plane_intersection(vector<Line> lines) {",
		"    // 按极角排序",
		"    sort(lines.begin(), lines.end());",
		"",
		"    // 去除重复半平面",
		"    int m = 0;",
		"    for (int i = 0; i < lines.size(); i++) {",
		"        if (i == 0 || abs(lines[i].angle - lines[i - 1].angle) > EPS) {",
		"            lines[m++] = lines[i];",
		"        } else if (lines[i].on_left(lines[i - 1].a)) {",
		"            lines[m - 1] = lines[i];",
		"        }",
		"    }",
		"    lines.resize(m);",
		"",
		"    deque<Line> dq;",
		"    deque<Point> pts;",
		"",
		"    for (const Line& line : lines) {",
		"        // 删除队尾无用半平面",
		"        while (dq.size() >= 2 && !line.on_left(pts.back())) {",
		"            dq.pop_back();",
		"            pts.pop_back();",
		"        }",
		"",
		"        // 删除队首无用半平面",
		"        while (dq.size() >= 2 && !line.on_left(pts.front())) {",
		"            dq.pop_front();",
		"            pts.pop_front();",
		"        }",
		"",
		"        dq.push_back(line);",
		"",
		"        // 计算新的交点",
		"        if (dq.size() >= 2) { pts.push_back(dq[dq.size() - 2].intersection(dq[dq.size() - 1])); }",
		"    }",
		"",
		"    // 最后清理",
		"    while (dq.size() >= 3 && !dq.front().on_left(pts.back())) {",
		"        dq.pop_back();",
		"        pts.pop_back();",
		"    }",
		"",
		"    if (dq.size() >= 3) { pts.push_back(dq.back().intersection(dq.front())); }",
		"",
		"    return vector<Point>(pts.begin(), pts.end());",
		"}",
		"",
		"// 创建半平面（点在直线左侧）",
		"Line make_half_plane(const Point& a, const Point& b) { return Line(a, b); }",
		"",
		"// 多边形的半平面表示",
		"vector<Line> polygon_to_half_planes(const vector<Point>& polygon) {",
		"    vector<Line> lines;",
		"    int n = polygon.size();",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int j = (i + 1) % n;",
		"        lines.push_back(Line(polygon[i], polygon[j]));",
		"    }",
		"",
		"    return lines;",
		"}",
		"",
		"// 求凸多边形的核",
		"vector<Point> convex_polygon_kernel(const vector<Point>& polygon) {",
		"    vector<Line> lines = polygon_to_half_planes(polygon);",
		"    return half_plane_intersection(lines);",
		"}",
	})
}),

-- 05_Geometry\2D\Line.h
s("05_geometry_2d_line_h", {
	t({
		"/**",
		" * 二维直线类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：直线相关的几何计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 使用Point类（需要包含Point.h）",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"};",
		"",
		"// 直线类",
		"struct Line {",
		"    Point a, b;  // 直线上的两点",
		"",
		"    // 构造函数",
		"    Line() {}",
		"    Line(const Point& a, const Point& b) : a(a), b(b) {}",
		"    Line(double x1, double y1, double x2, double y2) : a(x1, y1), b(x2, y2) {}",
		"",
		"    // 从点和方向向量构造",
		"    Line(const Point& p, const Point& dir, bool is_direction) {",
		"        a = p;",
		"        b = p + dir;",
		"    }",
		"",
		"    // 从一般式方程 ax + by + c = 0 构造",
		"    Line(double A, double B, double C) {",
		"        if (abs(A) < EPS) {",
		"            // B != 0",
		"            a = Point(0, -C / B);",
		"            b = Point(1, -C / B);",
		"        } else if (abs(B) < EPS) {",
		"            // A != 0",
		"            a = Point(-C / A, 0);",
		"            b = Point(-C / A, 1);",
		"        } else {",
		"            a = Point(0, -C / B);",
		"            b = Point(1, (-C - A) / B);",
		"        }",
		"    }",
		"",
		"    // 获取方向向量",
		"    Point direction() const { return b - a; }",
		"",
		"    // 获取单位方向向量",
		"    Point unit_direction() const {",
		"        Point dir = direction();",
		"        return dir / dir.norm();",
		"    }",
		"",
		"    // 获取法向量",
		"    Point normal() const {",
		"        Point dir = direction();",
		"        return Point(-dir.y, dir.x);  // 逆时针旋转90度",
		"    }",
		"",
		"    // 获取单位法向量",
		"    Point unit_normal() const {",
		"        Point n = normal();",
		"        return n / n.norm();",
		"    }",
		"",
		"    // 直线参数方程：a + t * (b - a)",
		"    Point point_at(double t) const { return a + direction() * t; }",
		"",
		"    // 获取一般式方程系数 Ax + By + C = 0",
		"    struct LineEquation {",
		"        double A, B, C;",
		"        LineEquation(double A, double B, double C) : A(A), B(B), C(C) {}",
		"    };",
		"",
		"    LineEquation get_equation() const {",
		"        Point dir = direction();",
		"        Point norm = normal();",
		"        double len = norm.norm();",
		"        norm = norm / len;",
		"        double C = -norm.dot(a);",
		"        return LineEquation(norm.x, norm.y, C);",
		"    }",
		"",
		"    // 点到直线的距离",
		"    double distance_to_point(const Point& p) const {",
		"        Point ap = p - a;",
		"        Point ab = direction();",
		"        return abs(ap.cross(ab)) / ab.norm();",
		"    }",
		"",
		"    // 点到直线的有向距离（正数表示在法向量方向一侧）",
		"    double signed_distance_to_point(const Point& p) const {",
		"        Point ap = p - a;",
		"        Point ab = direction();",
		"        return ap.cross(ab) / ab.norm();",
		"    }",
		"",
		"    // 点在直线上的投影",
		"    Point project_point(const Point& p) const {",
		"        Point ap = p - a;",
		"        Point ab = direction();",
		"        double t = ap.dot(ab) / ab.norm2();",
		"        return a + ab * t;",
		"    }",
		"",
		"    // 点关于直线的对称点",
		"    Point reflect_point(const Point& p) const {",
		"        Point proj = project_point(p);",
		"        return proj * 2 - p;",
		"    }",
		"",
		"    // 判断点是否在直线上",
		"    bool contains_point(const Point& p) const { return abs(distance_to_point(p)) < EPS; }",
		"",
		"    // 判断两直线是否平行",
		"    bool is_parallel(const Line& other) const { return abs(direction().cross(other.direction())) < EPS; }",
		"",
		"    // 判断两直线是否垂直",
		"    bool is_perpendicular(const Line& other) const { return abs(direction().dot(other.direction())) < EPS; }",
		"",
		"    // 直线交点（平行时返回无穷远点）",
		"    Point intersection(const Line& other) const {",
		"        Point d1 = direction(), d2 = other.direction();",
		"        double det = d1.cross(d2);",
		"        if (abs(det) < EPS) return Point(1e18, 1e18);  // 平行",
		"",
		"        double t = (other.a - a).cross(d2) / det;",
		"        return point_at(t);",
		"    }",
		"};",
		"",
		"// 全局函数",
		"double point_to_line_distance(const Point& p, const Line& l) { return l.distance_to_point(p); }",
	})
}),

-- 05_Geometry\2D\Point.h
s("05_geometry_2d_point_h", {
	t({
		"/**",
		" * 二维点/向量类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：二维几何计算的基础类",
		" */",
		"",
		"const double EPS = 1e-9;  // 精度控制",
		"const double PI = acos(-1.0);",
		"",
		"struct Point {",
		"    double x, y;",
		"",
		"    // 构造函数",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"",
		"    // 基本运算符重载",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    Point operator-() const { return Point(-x, -y); }",
		"",
		"    Point& operator+=(const Point& p) {",
		"        x += p.x;",
		"        y += p.y;",
		"        return *this;",
		"    }",
		"    Point& operator-=(const Point& p) {",
		"        x -= p.x;",
		"        y -= p.y;",
		"        return *this;",
		"    }",
		"    Point& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        return *this;",
		"    }",
		"    Point& operator/=(double t) {",
		"        x /= t;",
		"        y /= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算符",
		"    bool operator<(const Point& p) const { return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    bool operator!=(const Point& p) const { return !(*this == p); }   // 向量基本运算",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }    // 点积",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }  // 叉积",
		"",
		"    // 运算符重载：点乘和叉乘",
		"    double operator*(const Point& p) const { return dot(p); }    // 点乘重载",
		"    double operator^(const Point& p) const { return cross(p); }  // 叉乘重载",
		"",
		"    // 长度相关",
		"    double norm() const { return sqrt(x * x + y * y); }  // 向量长度",
		"    double norm2() const { return x * x + y * y; }       // 长度平方",
		"",
		"    // 单位化",
		"    Point normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point(0, 0) : Point(x / len, y / len);",
		"    }",
		"",
		"    // 旋转变换",
		"    Point rotate(double theta) const {",
		"        double c = cos(theta), s = sin(theta);",
		"        return Point(x * c - y * s, x * s + y * c);",
		"    }",
		"",
		"    Point rotate90() const { return Point(-y, x); }   // 逆时针旋转90度",
		"    Point rotate270() const { return Point(y, -x); }  // 顺时针旋转90度",
		"",
		"    // 角度相关",
		"    double angle() const { return atan2(y, x); }                            // 极角",
		"    double angle(const Point& p) const { return atan2(cross(p), dot(p)); }  // 与向量p的夹角",
		"",
		"    // 距离相关",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point& p) const { return (*this - p).norm2(); }",
		"",
		"    // 输出",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \"\\n\"; }",
		"};",
		"",
		"// 类型别名",
		"using Vector = Point;",
		"",
		"// 全局函数",
		"double dot(const Point& a, const Point& b) { return a.dot(b); }",
		"double cross(const Point& a, const Point& b) { return a.cross(b); }",
		"double distance(const Point& a, const Point& b) { return a.distance(b); }",
		"double distance2(const Point& a, const Point& b) { return a.distance2(b); }",
		"",
		"// 三点构成的三角形面积（有向面积）",
		"double triangle_area(const Point& a, const Point& b, const Point& c) { return cross(b - a, c - a) / 2.0; }",
		"",
		"// 判断三点的方向关系 (>0:逆时针, <0:顺时针, =0:共线)",
		"double orientation(const Point& a, const Point& b, const Point& c) { return cross(b - a, c - a); }",
		"",
		"// 判断点是否在线段上",
		"bool point_on_segment(const Point& p, const Point& a, const Point& b) {",
		"    return abs(cross(p - a, b - a)) < EPS && dot(p - a, p - b) <= EPS;",
		"}",
		"",
		"// 判断四边形是否为凸四边形",
		"bool is_convex_quadrilateral(const Point& a, const Point& b, const Point& c, const Point& d) {",
		"    double s1 = orientation(a, b, c);",
		"    double s2 = orientation(b, c, d);",
		"    double s3 = orientation(c, d, a);",
		"    double s4 = orientation(d, a, b);",
		"",
		"    return (s1 > EPS && s2 > EPS && s3 > EPS && s4 > EPS) || (s1 < -EPS && s2 < -EPS && s3 < -EPS && s4 < -EPS);",
		"}",
	})
}),

-- 05_Geometry\2D\Polygon.h
s("05_geometry_2d_polygon_h", {
	t({
		"/*",
		" * 二维多边形类模板",
		" * 时间复杂度: 面积计算O(n), 包含判断O(n), 凸包判断O(n)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 多边形相关的几何计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"struct Polygon {",
		"    vector<Point> vertices;",
		"",
		"    // 构造函数",
		"    Polygon() {}",
		"    Polygon(const vector<Point>& points) : vertices(points) {}",
		"",
		"    // 添加顶点",
		"    void add_vertex(const Point& p) { vertices.push_back(p); }",
		"    void add_vertex(double x, double y) { vertices.push_back(Point(x, y)); }",
		"",
		"    // 基本属性",
		"    int size() const { return vertices.size(); }",
		"    bool empty() const { return vertices.empty(); }",
		"",
		"    // 多边形面积（有向面积）",
		"    double area() const {",
		"        if (size() < 3) return 0;",
		"        double area = 0;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            area += vertices[i] ^ vertices[j];",
		"        }",
		"        return area / 2.0;",
		"    }",
		"",
		"    // 多边形周长",
		"    double perimeter() const {",
		"        if (size() < 2) return 0;",
		"        double perim = 0;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            perim += vertices[i].distance(vertices[j]);",
		"        }",
		"        return perim;",
		"    }",
		"",
		"    // 判断多边形方向（逆时针为正）",
		"    bool is_counter_clockwise() const { return area() > EPS; }",
		"",
		"    // 使多边形逆时针",
		"    void make_counter_clockwise() {",
		"        if (area() < -EPS) { reverse(vertices.begin(), vertices.end()); }",
		"    }",
		"",
		"    // 判断是否为凸多边形",
		"    bool is_convex() const {",
		"        if (size() < 3) return false;",
		"",
		"        bool has_pos = false, has_neg = false;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            int k = (i + 2) % size();",
		"",
		"            double cross = (vertices[j] - vertices[i]) ^ (vertices[k] - vertices[j]);",
		"            if (cross > EPS) has_pos = true;",
		"            if (cross < -EPS) has_neg = true;",
		"",
		"            if (has_pos && has_neg) return false;",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 点与多边形关系（射线法）",
		"    // 返回: -1内部, 0边界, 1外部",
		"    int point_relation(const Point& p) const {",
		"        if (size() < 3) return 1;",
		"",
		"        int winding = 0;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"",
		"            // 检查点是否在边上",
		"            Point edge = vertices[j] - vertices[i];",
		"            Point to_p = p - vertices[i];",
		"            if (abs(edge ^ to_p) < EPS && (to_p * edge) >= -EPS && (to_p * edge) <= (edge * edge) + EPS) {",
		"                return 0;  // 在边界上",
		"            }",
		"",
		"            // 射线相交判断",
		"            if (vertices[i].y <= p.y) {",
		"                if (vertices[j].y > p.y && ((vertices[j] - vertices[i]) ^ (p - vertices[i])) > EPS) { winding++; }",
		"            } else {",
		"                if (vertices[j].y <= p.y && ((vertices[j] - vertices[i]) ^ (p - vertices[i])) < -EPS) { winding--; }",
		"            }",
		"        }",
		"",
		"        return winding == 0 ? 1 : -1;",
		"    }",
		"",
		"    bool contains(const Point& p) const { return point_relation(p) <= 0; }",
		"    bool contains_strictly(const Point& p) const { return point_relation(p) < 0; }",
		"",
		"    // 多边形重心",
		"    Point centroid() const {",
		"        if (empty()) return Point();",
		"        if (size() == 1) return vertices[0];",
		"        if (size() == 2) return (vertices[0] + vertices[1]) * 0.5;",
		"",
		"        Point center(0, 0);",
		"        double area_sum = 0;",
		"",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            double cross = vertices[i] ^ vertices[j];",
		"            area_sum += cross;",
		"            center = center + (vertices[i] + vertices[j]) * cross;",
		"        }",
		"",
		"        if (abs(area_sum) < EPS) {",
		"            // 退化情况，返回几何中心",
		"            for (const Point& p : vertices) { center = center + p; }",
		"            return center / (double)size();",
		"        }",
		"",
		"        return center / (3.0 * area_sum);",
		"    }",
		"",
		"    // 多边形最小外接矩形",
		"    struct Rectangle {",
		"        Point bottom_left, top_right;",
		"        Rectangle(const Point& bl, const Point& tr) : bottom_left(bl), top_right(tr) {}",
		"    };",
		"",
		"    Rectangle bounding_box() const {",
		"        if (empty()) return Rectangle(Point(), Point());",
		"",
		"        double min_x = vertices[0].x, max_x = vertices[0].x;",
		"        double min_y = vertices[0].y, max_y = vertices[0].y;",
		"",
		"        for (const Point& p : vertices) {",
		"            min_x = min(min_x, p.x);",
		"            max_x = max(max_x, p.x);",
		"            min_y = min(min_y, p.y);",
		"            max_y = max(max_y, p.y);",
		"        }",
		"",
		"        return Rectangle(Point(min_x, min_y), Point(max_x, max_y));",
		"    }",
		"",
		"    // 简单多边形三角剖分（扇形剖分）",
		"    vector<vector<int>> triangulate() const {",
		"        vector<vector<int>> triangles;",
		"        if (size() < 3) return triangles;",
		"",
		"        for (int i = 1; i < size() - 1; i++) { triangles.push_back({0, i, i + 1}); }",
		"",
		"        return triangles;",
		"    }",
		"};",
	})
}),

-- 05_Geometry\2D\RotatingCalipers.h
s("05_geometry_2d_rotatingcalipers_h", {
	t({
		"/*",
		" * 旋转卡壳算法",
		" * 时间复杂度: O(n)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 凸包上点对的最值问题",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }  // 添加除法运算符",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    bool operator<(const Point& p) const { return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS); }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point& p) const { return (*this - p).norm2(); }",
		"};",
		"",
		"// 凸包直径（最远点对距离）",
		"double convex_diameter(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n <= 1) return 0;",
		"    if (n == 2) return convex_hull[0].distance(convex_hull[1]);",
		"",
		"    double max_dist = 0;",
		"    int j = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int next_i = (i + 1) % n;",
		"        Point edge_i = convex_hull[next_i] - convex_hull[i];",
		"",
		"        // 找到距离边i最远的点",
		"        while (true) {",
		"            int next_j = (j + 1) % n;",
		"            Point to_j = convex_hull[j] - convex_hull[i];",
		"            Point to_next_j = convex_hull[next_j] - convex_hull[i];",
		"",
		"            if ((edge_i ^ to_j) < (edge_i ^ to_next_j)) {",
		"                j = next_j;",
		"            } else {",
		"                break;",
		"            }",
		"        }",
		"",
		"        max_dist = max(max_dist, convex_hull[i].distance(convex_hull[j]));",
		"        max_dist = max(max_dist, convex_hull[next_i].distance(convex_hull[j]));",
		"    }",
		"",
		"    return max_dist;",
		"}",
		"",
		"// 凸包最小宽度（最近平行线距离）",
		"double convex_width(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n <= 2) return 0;",
		"",
		"    double min_width = 1e18;",
		"    int j = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int next_i = (i + 1) % n;",
		"        Point edge = convex_hull[next_i] - convex_hull[i];",
		"",
		"        // 找到距离边i最远的点",
		"        while (true) {",
		"            int next_j = (j + 1) % n;",
		"            Point to_j = convex_hull[j] - convex_hull[i];",
		"            Point to_next_j = convex_hull[next_j] - convex_hull[i];",
		"",
		"            if (abs(edge ^ to_j) < abs(edge ^ to_next_j)) {",
		"                j = next_j;",
		"            } else {",
		"                break;",
		"            }",
		"        }",
		"",
		"        double width = abs(edge ^ (convex_hull[j] - convex_hull[i])) / edge.norm();",
		"        min_width = min(min_width, width);",
		"    }",
		"",
		"    return min_width;",
		"}",
		"",
		"// 凸包最小面积外接矩形",
		"struct Rectangle {",
		"    Point vertices[4];  // 矩形四个顶点",
		"    double area;        // 矩形面积",
		"",
		"    Rectangle() : area(1e18) {}",
		"    Rectangle(const Point& center, const Point& u, const Point& v, double w, double h) {",
		"        Point half_u = u * (w / 2);",
		"        Point half_v = v * (h / 2);",
		"        vertices[0] = center - half_u - half_v;",
		"        vertices[1] = center + half_u - half_v;",
		"        vertices[2] = center + half_u + half_v;",
		"        vertices[3] = center - half_u + half_v;",
		"        area = w * h;",
		"    }",
		"};",
		"",
		"Rectangle min_area_rectangle(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n < 3) return Rectangle();",
		"",
		"    Rectangle min_rect;",
		"    int l = 0, r = 0, u = 0;  // 左右上边界点索引",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int next_i = (i + 1) % n;",
		"        Point edge = convex_hull[next_i] - convex_hull[i];",
		"        Point unit_edge = edge / edge.norm();",
		"        Point unit_normal(-unit_edge.y, unit_edge.x);  // 法向量",
		"",
		"        // 更新边界点",
		"        while ((convex_hull[(l + 1) % n] - convex_hull[i]) * unit_edge <",
		"               (convex_hull[l] - convex_hull[i]) * unit_edge) {",
		"            l = (l + 1) % n;",
		"        }",
		"        while ((convex_hull[(r + 1) % n] - convex_hull[i]) * unit_edge >",
		"               (convex_hull[r] - convex_hull[i]) * unit_edge) {",
		"            r = (r + 1) % n;",
		"        }",
		"        while ((convex_hull[(u + 1) % n] - convex_hull[i]) * unit_normal >",
		"               (convex_hull[u] - convex_hull[i]) * unit_normal) {",
		"            u = (u + 1) % n;",
		"        }",
		"",
		"        // 计算矩形",
		"        double width = (convex_hull[r] - convex_hull[l]) * unit_edge;",
		"        double height = (convex_hull[u] - convex_hull[i]) * unit_normal;",
		"        double area = width * height;",
		"",
		"        if (area < min_rect.area) {",
		"            Point center = (convex_hull[l] + convex_hull[r]) * 0.5 + unit_normal * (height / 2);",
		"            min_rect = Rectangle(center, unit_edge, unit_normal, width, height);",
		"        }",
		"    }",
		"",
		"    return min_rect;",
		"}",
		"",
		"// 凸包中的最大三角形面积",
		"double max_triangle_area(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n < 3) return 0;",
		"",
		"    double max_area = 0;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int j = (i + 1) % n;",
		"        int k = (i + 2) % n;",
		"",
		"        for (int l = i; l < n; l++) {",
		"            // 对于边ij，找到使三角形面积最大的点k",
		"            while (true) {",
		"                int next_k = (k + 1) % n;",
		"                Point to_k = convex_hull[k] - convex_hull[i];",
		"                Point to_next_k = convex_hull[next_k] - convex_hull[i];",
		"                Point edge = convex_hull[j] - convex_hull[i];",
		"",
		"                if (abs(edge ^ to_k) < abs(edge ^ to_next_k)) {",
		"                    k = next_k;",
		"                } else {",
		"                    break;",
		"                }",
		"            }",
		"",
		"            double area = abs((convex_hull[j] - convex_hull[i]) ^ (convex_hull[k] - convex_hull[i])) / 2.0;",
		"            max_area = max(max_area, area);",
		"",
		"            j = (j + 1) % n;",
		"            if (j == i) break;",
		"        }",
		"    }",
		"",
		"    return max_area;",
		"}",
	})
}),

-- 05_Geometry\2D\Segment.h
s("05_geometry_2d_segment_h", {
	t({
		"/*",
		" * 二维线段类模板",
		" * 时间复杂度: 各操作均为 O(1)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 线段相关的几何计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"struct Segment {",
		"    Point a, b;  // 线段端点",
		"",
		"    // 构造函数",
		"    Segment() {}",
		"    Segment(const Point& a, const Point& b) : a(a), b(b) {}",
		"    Segment(double x1, double y1, double x2, double y2) : a(Point(x1, y1)), b(Point(x2, y2)) {}",
		"",
		"    // 线段基本属性",
		"    double length() const { return a.distance(b); }",
		"    double length2() const { return (b - a).norm2(); }",
		"    Point direction() const { return b - a; }",
		"    Point midpoint() const { return (a + b) * 0.5; }",
		"",
		"    // 线段上的点",
		"    Point point_at(double t) const { return a + (b - a) * t; }  // t∈[0,1]",
		"",
		"    // 点到线段的距离",
		"    double distance_to_point(const Point& p) const {",
		"        Point ap = p - a, ab = b - a;",
		"        double t = ap * ab / ab.norm2();",
		"        t = max(0.0, min(1.0, t));  // 限制在[0,1]",
		"        Point closest = a + ab * t;",
		"        return p.distance(closest);",
		"    }",
		"",
		"    // 点在线段上的投影",
		"    Point project(const Point& p) const {",
		"        Point ap = p - a, ab = b - a;",
		"        double t = ap * ab / ab.norm2();",
		"        t = max(0.0, min(1.0, t));",
		"        return a + ab * t;",
		"    }",
		"",
		"    // 判断点是否在线段上",
		"    bool contains(const Point& p) const { return abs((p - a) ^ (b - a)) < EPS && (p - a) * (p - b) <= EPS; }",
		"",
		"    // 判断两线段是否相交",
		"    bool intersects(const Segment& other) const {",
		"        Point ab = b - a, cd = other.b - other.a;",
		"        Point ac = other.a - a, ad = other.b - a;",
		"        Point ca = a - other.a, cb = b - other.a;",
		"",
		"        // 快速排斥实验",
		"        if (max(a.x, b.x) < min(other.a.x, other.b.x) - EPS || max(other.a.x, other.b.x) < min(a.x, b.x) - EPS ||",
		"            max(a.y, b.y) < min(other.a.y, other.b.y) - EPS || max(other.a.y, other.b.y) < min(a.y, b.y) - EPS) {",
		"            return false;",
		"        }",
		"",
		"        // 跨立实验",
		"        double d1 = ab ^ ac;",
		"        double d2 = ab ^ ad;",
		"        double d3 = cd ^ ca;",
		"        double d4 = cd ^ cb;",
		"",
		"        if (d1 * d2 < -EPS && d3 * d4 < -EPS) return true;",
		"",
		"        // 特殊情况：端点在对方线段上",
		"        if (abs(d1) < EPS && contains(other.a)) return true;",
		"        if (abs(d2) < EPS && contains(other.b)) return true;",
		"        if (abs(d3) < EPS && other.contains(a)) return true;",
		"        if (abs(d4) < EPS && other.contains(b)) return true;",
		"",
		"        return false;",
		"    }",
		"",
		"    // 两线段交点",
		"    vector<Point> intersection(const Segment& other) const {",
		"        vector<Point> result;",
		"",
		"        Point ab = b - a, cd = other.b - other.a;",
		"        Point ac = other.a - a;",
		"",
		"        double d = ab ^ cd;",
		"        if (abs(d) < EPS) {",
		"            // 平行或共线",
		"            if (abs(ab ^ ac) < EPS) {",
		"                // 共线，可能有重叠",
		"                double t1 = 0, t2 = 1;",
		"                double s1 = (other.a - a) * ab / ab.norm2();",
		"                double s2 = (other.b - a) * ab / ab.norm2();",
		"                if (s1 > s2) swap(s1, s2);",
		"",
		"                double left = max(t1, s1);",
		"                double right = min(t2, s2);",
		"",
		"                if (left <= right + EPS) {",
		"                    if (abs(left - right) < EPS) {",
		"                        // 一个交点",
		"                        result.push_back(point_at(left));",
		"                    } else {",
		"                        // 线段重叠",
		"                        result.push_back(point_at(left));",
		"                        result.push_back(point_at(right));",
		"                    }",
		"                }",
		"            }",
		"            return result;",
		"        }",
		"",
		"        double t = (ac ^ cd) / d;",
		"        double s = (ac ^ ab) / d;",
		"",
		"        if (t >= -EPS && t <= 1 + EPS && s >= -EPS && s <= 1 + EPS) { result.push_back(point_at(t)); }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 两线段间的最短距离",
		"    double distance_to_segment(const Segment& other) const {",
		"        if (intersects(other)) return 0;",
		"",
		"        return min({distance_to_point(other.a),",
		"                    distance_to_point(other.b),",
		"                    other.distance_to_point(a),",
		"                    other.distance_to_point(b)});",
		"    }",
		"};",
	})
}),

-- 05_Geometry\3D\ConvexHull3D.h
s("05_geometry_3d_convexhull3d_h", {
	t({
		"/*",
		" * 三维凸包算法（增量法）",
		" * 时间复杂度: O(n^2)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 求三维点集的凸包",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 需要包含Point3D.h或Vector3D.h",
		"struct Point3D {",
		"    double x, y, z;",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    bool operator<(const Point3D& p) const {",
		"        if (abs(x - p.x) > EPS) return x < p.x;",
		"        if (abs(y - p.y) > EPS) return y < p.y;",
		"        return z < p.z;",
		"    }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double distance(const Point3D& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"struct Face {",
		"    int a, b, c;     // 面的三个顶点索引",
		"    Point3D normal;  // 面的法向量",
		"",
		"    Face() {}",
		"    Face(int a, int b, int c) : a(a), b(b), c(c) {}",
		"",
		"    // 计算面的法向量",
		"    void compute_normal(const vector<Point3D>& points) {",
		"        Point3D v1 = points[b] - points[a];",
		"        Point3D v2 = points[c] - points[a];",
		"        normal = v1.cross(v2);",
		"        if (normal.norm() > EPS) { normal = normal * (1.0 / normal.norm()); }",
		"    }",
		"",
		"    // 判断点是否在面的正侧",
		"    bool visible_from(const Point3D& p, const vector<Point3D>& points) const {",
		"        Point3D to_p = p - points[a];",
		"        return to_p.dot(normal) > EPS;",
		"    }",
		"};",
		"",
		"class ConvexHull3D {",
		"   private:",
		"    vector<Point3D> points;",
		"    vector<Face> faces;",
		"    vector<vector<int>> adj;  // 邻接表：adj[i]存储包含点i的面",
		"",
		"    // 判断四点是否共面",
		"    bool coplanar(int a, int b, int c, int d) const {",
		"        Point3D v1 = points[b] - points[a];",
		"        Point3D v2 = points[c] - points[a];",
		"        Point3D v3 = points[d] - points[a];",
		"        return abs(v1.dot(v2.cross(v3))) < EPS;",
		"    }",
		"",
		"    // 找到初始四面体",
		"    bool find_initial_tetrahedron() {",
		"        int n = points.size();",
		"        if (n < 4) return false;",
		"",
		"        // 找到不共线的三点",
		"        int p0 = 0, p1 = 1, p2 = 2;",
		"        for (p2 = 2; p2 < n; p2++) {",
		"            Point3D v1 = points[p1] - points[p0];",
		"            Point3D v2 = points[p2] - points[p0];",
		"            if (v1.cross(v2).norm() > EPS) break;",
		"        }",
		"        if (p2 == n) return false;",
		"",
		"        // 找到不共面的第四点",
		"        int p3 = p2 + 1;",
		"        for (; p3 < n; p3++) {",
		"            if (!coplanar(p0, p1, p2, p3)) break;",
		"        }",
		"        if (p3 == n) return false;",
		"",
		"        // 确保正确的方向",
		"        Point3D v1 = points[p1] - points[p0];",
		"        Point3D v2 = points[p2] - points[p0];",
		"        Point3D v3 = points[p3] - points[p0];",
		"        if (v1.dot(v2.cross(v3)) < 0) { swap(p1, p2); }",
		"",
		"        // 创建初始四面体的四个面",
		"        faces.clear();",
		"        faces.push_back(Face(p0, p1, p2));",
		"        faces.push_back(Face(p0, p2, p3));",
		"        faces.push_back(Face(p0, p3, p1));",
		"        faces.push_back(Face(p1, p3, p2));",
		"",
		"        // 计算法向量（指向外部）",
		"        for (Face& face : faces) {",
		"            face.compute_normal(points);",
		"            // 确保法向量指向外部",
		"            Point3D center = (points[face.a] + points[face.b] + points[face.c]) * (1.0 / 3.0);",
		"            Point3D other_point;",
		"            bool found = false;",
		"            for (int i = 0; i < 4; i++) {",
		"                if (i != face.a && i != face.b && i != face.c) {",
		"                    other_point = points[i];",
		"                    found = true;",
		"                    break;",
		"                }",
		"            }",
		"            if (found && (other_point - center).dot(face.normal) > 0) { face.normal = face.normal * (-1); }",
		"        }",
		"",
		"        return true;",
		"    }",
		"",
		"   public:",
		"    ConvexHull3D(vector<Point3D> pts) : points(pts) {",
		"        // 去重",
		"        sort(points.begin(), points.end());",
		"        points.erase(unique(points.begin(), points.end()), points.end());",
		"    }",
		"",
		"    bool build() {",
		"        int n = points.size();",
		"        if (n < 4) return false;",
		"",
		"        if (!find_initial_tetrahedron()) return false;",
		"",
		"        // 增量添加剩余点",
		"        for (int i = 4; i < n; i++) {",
		"            vector<int> visible_faces;",
		"",
		"            // 找到可见面",
		"            for (int j = 0; j < faces.size(); j++) {",
		"                if (faces[j].visible_from(points[i], points)) { visible_faces.push_back(j); }",
		"            }",
		"",
		"            if (visible_faces.empty()) continue;",
		"",
		"            // 收集边界边",
		"            set<pair<int, int>> boundary_edges;",
		"            for (int face_idx : visible_faces) {",
		"                Face& face = faces[face_idx];",
		"                boundary_edges.insert({min(face.a, face.b), max(face.a, face.b)});",
		"                boundary_edges.insert({min(face.b, face.c), max(face.b, face.c)});",
		"                boundary_edges.insert({min(face.c, face.a), max(face.c, face.a)});",
		"            }",
		"",
		"            // 移除内部边",
		"            set<pair<int, int>> real_boundary;",
		"            for (const auto& edge : boundary_edges) {",
		"                bool is_boundary = true;",
		"                for (int face_idx : visible_faces) {",
		"                    Face& face = faces[face_idx];",
		"                    int count = 0;",
		"                    if ((face.a == edge.first || face.a == edge.second)) count++;",
		"                    if ((face.b == edge.first || face.b == edge.second)) count++;",
		"                    if ((face.c == edge.first || face.c == edge.second)) count++;",
		"                    if (count == 2) {",
		"                        // 这条边在这个面上",
		"                        is_boundary = !is_boundary;",
		"                    }",
		"                }",
		"                if (is_boundary) { real_boundary.insert(edge); }",
		"            }",
		"",
		"            // 删除可见面",
		"            vector<Face> new_faces;",
		"            for (int j = 0; j < faces.size(); j++) {",
		"                bool visible = find(visible_faces.begin(), visible_faces.end(), j) != visible_faces.end();",
		"                if (!visible) { new_faces.push_back(faces[j]); }",
		"            }",
		"            faces = new_faces;",
		"",
		"            // 添加新面",
		"            for (const auto& edge : real_boundary) {",
		"                Face new_face(edge.first, edge.second, i);",
		"                new_face.compute_normal(points);",
		"                faces.push_back(new_face);",
		"            }",
		"        }",
		"",
		"        return true;",
		"    }",
		"",
		"    vector<Face> get_faces() const { return faces; }",
		"    vector<Point3D> get_vertices() const {",
		"        set<int> vertex_set;",
		"        for (const Face& face : faces) {",
		"            vertex_set.insert(face.a);",
		"            vertex_set.insert(face.b);",
		"            vertex_set.insert(face.c);",
		"        }",
		"        vector<Point3D> vertices;",
		"        for (int idx : vertex_set) { vertices.push_back(points[idx]); }",
		"        return vertices;",
		"    }",
		"",
		"    double volume() const {",
		"        double vol = 0;",
		"        Point3D origin(0, 0, 0);",
		"        for (const Face& face : faces) {",
		"            Point3D v1 = points[face.a];",
		"            Point3D v2 = points[face.b];",
		"            Point3D v3 = points[face.c];",
		"            vol += v1.dot(v2.cross(v3));",
		"        }",
		"        return abs(vol) / 6.0;",
		"    }",
		"};",
		"",
		"// 简化接口",
		"vector<vector<int>> convex_hull_3d(vector<Point3D> points) {",
		"    ConvexHull3D hull(points);",
		"    if (!hull.build()) return {};",
		"",
		"    vector<Face> faces = hull.get_faces();",
		"    vector<vector<int>> result;",
		"    for (const Face& face : faces) { result.push_back({face.a, face.b, face.c}); }",
		"    return result;",
		"}",
	})
}),

-- 05_Geometry\3D\Plane3D.h
s("05_geometry_3d_plane3d_h", {
	t({
		"/**",
		" * 三维平面类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：三维空间中的平面相关计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 使用Point3D类（需要包含Point3D.h）",
		"struct Point3D {",
		"    double x, y, z;",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    Point3D operator/(double t) const { return Point3D(x / t, y / t, z / t); }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double norm2() const { return x * x + y * y + z * z; }",
		"    Point3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point3D() : *this / len;",
		"    }",
		"};",
		"",
		"// 三维平面类",
		"struct Plane3D {",
		"    Point3D normal;  // 法向量",
		"    double d;        // 平面方程：normal·x + d = 0",
		"",
		"    // 构造函数",
		"    Plane3D() : d(0) {}",
		"",
		"    // 从法向量和平面上一点构造",
		"    Plane3D(const Point3D& n, const Point3D& point) : normal(n.normalize()) { d = -normal.dot(point); }",
		"",
		"    // 从三点构造平面",
		"    Plane3D(const Point3D& a, const Point3D& b, const Point3D& c) {",
		"        normal = (b - a).cross(c - a).normalize();",
		"        d = -normal.dot(a);",
		"    }",
		"",
		"    // 从平面方程 ax + by + cz + d = 0 构造",
		"    Plane3D(double a, double b, double c, double D) {",
		"        normal = Point3D(a, b, c);",
		"        double len = normal.norm();",
		"        if (len > EPS) {",
		"            normal = normal / len;",
		"            d = D / len;",
		"        } else {",
		"            normal = Point3D(0, 0, 1);",
		"            d = 0;",
		"        }",
		"    }",
		"",
		"    // 点到平面的距离（有向距离）",
		"    double distance_to_point(const Point3D& p) const { return normal.dot(p) + d; }",
		"",
		"    // 点到平面的距离（绝对距离）",
		"    double abs_distance_to_point(const Point3D& p) const { return abs(distance_to_point(p)); }",
		"",
		"    // 判断点是否在平面上",
		"    bool contains_point(const Point3D& p) const { return abs(distance_to_point(p)) < EPS; }",
		"",
		"    // 点在平面上的投影",
		"    Point3D project_point(const Point3D& p) const {",
		"        double dist = distance_to_point(p);",
		"        return p - normal * dist;",
		"    }",
		"",
		"    // 点关于平面的对称点",
		"    Point3D reflect_point(const Point3D& p) const {",
		"        double dist = distance_to_point(p);",
		"        return p - normal * (2 * dist);",
		"    }",
		"",
		"    // 判断两平面是否平行",
		"    bool is_parallel(const Plane3D& other) const { return abs(abs(normal.dot(other.normal)) - 1.0) < EPS; }",
		"",
		"    // 判断两平面是否垂直",
		"    bool is_perpendicular(const Plane3D& other) const { return abs(normal.dot(other.normal)) < EPS; }",
		"",
		"    // 两平面的交线（如果存在）",
		"    struct Line3D {",
		"        Point3D point;      // 直线上一点",
		"        Point3D direction;  // 方向向量",
		"",
		"        Line3D() {}",
		"        Line3D(const Point3D& p, const Point3D& dir) : point(p), direction(dir.normalize()) {}",
		"    };",
		"",
		"    Line3D intersection_line(const Plane3D& other) const {",
		"        if (is_parallel(other)) {",
		"            return Line3D();  // 平行，无交线或重合",
		"        }",
		"",
		"        Point3D dir = normal.cross(other.normal);",
		"",
		"        // 找交线上的一点",
		"        Point3D p;",
		"        double max_coord = max({abs(dir.x), abs(dir.y), abs(dir.z)});",
		"",
		"        if (abs(dir.x - max_coord) < EPS) {",
		"            // 在 yz 平面上求解",
		"            double det = normal.y * other.normal.z - normal.z * other.normal.y;",
		"            if (abs(det) > EPS) {",
		"                p.x = 0;",
		"                p.y = (-d * other.normal.z + other.d * normal.z) / det;",
		"                p.z = (d * other.normal.y - other.d * normal.y) / det;",
		"            }",
		"        } else if (abs(dir.y - max_coord) < EPS) {",
		"            // 在 xz 平面上求解",
		"            double det = normal.x * other.normal.z - normal.z * other.normal.x;",
		"            if (abs(det) > EPS) {",
		"                p.y = 0;",
		"                p.x = (-d * other.normal.z + other.d * normal.z) / det;",
		"                p.z = (d * other.normal.x - other.d * normal.x) / det;",
		"            }",
		"        } else {",
		"            // 在 xy 平面上求解",
		"            double det = normal.x * other.normal.y - normal.y * other.normal.x;",
		"            if (abs(det) > EPS) {",
		"                p.z = 0;",
		"                p.x = (-d * other.normal.y + other.d * normal.y) / det;",
		"                p.y = (d * other.normal.x - other.d * normal.x) / det;",
		"            }",
		"        }",
		"",
		"        return Line3D(p, dir);",
		"    }",
		"",
		"    // 三平面的交点",
		"    static Point3D intersection_point(const Plane3D& p1, const Plane3D& p2, const Plane3D& p3) {",
		"        // 求解线性方程组",
		"        // n1·x + d1 = 0",
		"        // n2·x + d2 = 0",
		"        // n3·x + d3 = 0",
		"",
		"        Point3D n1 = p1.normal, n2 = p2.normal, n3 = p3.normal;",
		"        double d1 = p1.d, d2 = p2.d, d3 = p3.d;",
		"",
		"        double det = n1.dot(n2.cross(n3));",
		"        if (abs(det) < EPS) {",
		"            return Point3D(1e18, 1e18, 1e18);  // 无唯一解",
		"        }",
		"",
		"        Point3D result = n2.cross(n3) * (-d1) + n3.cross(n1) * (-d2) + n1.cross(n2) * (-d3);",
		"        return result / det;",
		"    }",
		"};",
		"",
		"// 三维直线类",
		"struct Line3D {",
		"    Point3D point;      // 直线上一点",
		"    Point3D direction;  // 方向向量",
		"",
		"    Line3D() {}",
		"    Line3D(const Point3D& p, const Point3D& dir) : point(p), direction(dir.normalize()) {}",
		"    Line3D(const Point3D& a, const Point3D& b) : point(a), direction((b - a).normalize()) {}",
		"",
		"    // 直线上的参数方程点",
		"    Point3D point_at(double t) const { return point + direction * t; }",
		"",
		"    // 点到直线的距离",
		"    double distance_to_point(const Point3D& p) const {",
		"        Point3D to_p = p - point;",
		"        return to_p.cross(direction).norm();",
		"    }",
		"",
		"    // 点在直线上的投影",
		"    Point3D project_point(const Point3D& p) const {",
		"        Point3D to_p = p - point;",
		"        double t = to_p.dot(direction);",
		"        return point_at(t);",
		"    }",
		"",
		"    // 判断点是否在直线上",
		"    bool contains_point(const Point3D& p) const { return distance_to_point(p) < EPS; }",
		"",
		"    // 两直线的最短距离",
		"    double distance_to_line(const Line3D& other) const {",
		"        Point3D w = point - other.point;",
		"        Point3D cross_dir = direction.cross(other.direction);",
		"",
		"        if (cross_dir.norm() < EPS) {",
		"            // 平行或重合",
		"            return distance_to_point(other.point);",
		"        }",
		"",
		"        return abs(w.dot(cross_dir)) / cross_dir.norm();",
		"    }",
		"",
		"    // 两直线的交点（如果相交）",
		"    Point3D intersection_point(const Line3D& other) const {",
		"        Point3D w = point - other.point;",
		"        Point3D cross_dir = direction.cross(other.direction);",
		"",
		"        if (cross_dir.norm() < EPS) {",
		"            // 平行或重合",
		"            return Point3D(1e18, 1e18, 1e18);",
		"        }",
		"",
		"        double t = w.cross(other.direction).dot(cross_dir) / cross_dir.norm2();",
		"        return point_at(t);",
		"    }",
		"",
		"    // 直线与平面的交点",
		"    Point3D intersection_with_plane(const Plane3D& plane) const {",
		"        double denom = direction.dot(plane.normal);",
		"        if (abs(denom) < EPS) {",
		"            // 平行或在平面内",
		"            return Point3D(1e18, 1e18, 1e18);",
		"        }",
		"",
		"        double t = -(plane.normal.dot(point) + plane.d) / denom;",
		"        return point_at(t);",
		"    }",
		"",
		"    // 判断直线是否与平面平行",
		"    bool is_parallel_to_plane(const Plane3D& plane) const { return abs(direction.dot(plane.normal)) < EPS; }",
		"",
		"    // 判断直线是否在平面内",
		"    bool is_in_plane(const Plane3D& plane) const { return is_parallel_to_plane(plane) && plane.contains_point(point); }",
		"};",
		"",
		"// 全局函数",
		"double point_to_plane_distance(const Point3D& p, const Plane3D& plane) { return plane.abs_distance_to_point(p); }",
		"",
		"double point_to_line_distance(const Point3D& p, const Line3D& line) { return line.distance_to_point(p); }",
		"",
		"double line_to_line_distance(const Line3D& l1, const Line3D& l2) { return l1.distance_to_line(l2); }",
	})
}),

-- 05_Geometry\3D\Point3D.h
s("05_geometry_3d_point3d_h", {
	t({
		"/**",
		" * 三维点/向量类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：三维几何计算的基础类",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"struct Point3D {",
		"    double x, y, z;",
		"",
		"    // 构造函数",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"",
		"    // 基本运算符重载",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    Point3D operator/(double t) const { return Point3D(x / t, y / t, z / t); }",
		"    Point3D operator-() const { return Point3D(-x, -y, -z); }",
		"",
		"    Point3D& operator+=(const Point3D& p) {",
		"        x += p.x;",
		"        y += p.y;",
		"        z += p.z;",
		"        return *this;",
		"    }",
		"    Point3D& operator-=(const Point3D& p) {",
		"        x -= p.x;",
		"        y -= p.y;",
		"        z -= p.z;",
		"        return *this;",
		"    }",
		"    Point3D& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        z *= t;",
		"        return *this;",
		"    }",
		"    Point3D& operator/=(double t) {",
		"        x /= t;",
		"        y /= t;",
		"        z /= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算符",
		"    bool operator<(const Point3D& p) const {",
		"        if (abs(x - p.x) > EPS) return x < p.x;",
		"        if (abs(y - p.y) > EPS) return y < p.y;",
		"        return z < p.z - EPS;",
		"    }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    bool operator!=(const Point3D& p) const { return !(*this == p); }",
		"",
		"    // 向量基本运算",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }  // 点积",
		"",
		"    // 叉积（返回向量）",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"",
		"    // 长度相关",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }  // 向量长度",
		"    double norm2() const { return x * x + y * y + z * z; }       // 长度平方",
		"",
		"    // 单位化",
		"    Point3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point3D(0, 0, 0) : Point3D(x / len, y / len, z / len);",
		"    }",
		"",
		"    // 距离相关",
		"    double distance(const Point3D& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point3D& p) const { return (*this - p).norm2(); }",
		"",
		"    // 投影到平面（沿给定法向量方向）",
		"    Point3D project_to_plane(const Point3D& normal, const Point3D& point_on_plane) const {",
		"        Point3D n = normal.normalize();",
		"        double d = (*this - point_on_plane).dot(n);",
		"        return *this - n * d;",
		"    }",
		"",
		"    // 绕轴旋转（Rodrigues旋转公式）",
		"    Point3D rotate_around_axis(const Point3D& axis, double angle) const {",
		"        Point3D k = axis.normalize();",
		"        double cos_theta = cos(angle);",
		"        double sin_theta = sin(angle);",
		"        return *this * cos_theta + k.cross(*this) * sin_theta + k * (k.dot(*this)) * (1 - cos_theta);",
		"    }",
		"",
		"    // 输出",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \" \" << z << \"\\n\"; }",
		"};",
		"",
		"// 类型别名",
		"using Vector3D = Point3D;",
		"",
		"// 全局函数",
		"double dot(const Point3D& a, const Point3D& b) { return a.dot(b); }",
		"Point3D cross(const Point3D& a, const Point3D& b) { return a.cross(b); }",
		"double distance(const Point3D& a, const Point3D& b) { return a.distance(b); }",
		"double distance2(const Point3D& a, const Point3D& b) { return a.distance2(b); }",
		"",
		"// 三点构成的三角形面积",
		"double triangle_area(const Point3D& a, const Point3D& b, const Point3D& c) { return cross(b - a, c - a).norm() / 2.0; }",
		"",
		"// 四点构成的四面体体积（有向体积）",
		"double tetrahedron_volume(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return dot(b - a, cross(c - a, d - a)) / 6.0;",
		"}",
		"",
		"// 判断四点是否共面",
		"bool are_coplanar(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return abs(tetrahedron_volume(a, b, c, d)) < EPS;",
		"}",
		"",
		"// 三点确定平面的法向量",
		"Point3D plane_normal(const Point3D& a, const Point3D& b, const Point3D& c) { return cross(b - a, c - a).normalize(); }",
		"",
		"// 求两向量的夹角（弧度）",
		"double angle_between_vectors(const Point3D& a, const Point3D& b) {",
		"    double cos_theta = dot(a, b) / (a.norm() * b.norm());",
		"    cos_theta = max(-1.0, min(1.0, cos_theta));  // 避免精度误差",
		"    return acos(cos_theta);",
		"}",
	})
}),

-- 05_Geometry\3D\Sphere3D.h
s("05_geometry_3d_sphere3d_h", {
	t({
		"/**",
		" * 三维球体类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：三维空间中的球体相关计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 使用Point3D类（需要包含Point3D.h）",
		"struct Point3D {",
		"    double x, y, z;",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    Point3D operator/(double t) const { return Point3D(x / t, y / t, z / t); }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double norm2() const { return x * x + y * y + z * z; }",
		"    double distance(const Point3D& p) const { return (*this - p).norm(); }",
		"    Point3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point3D() : *this / len;",
		"    }",
		"};",
		"",
		"struct Plane3D {",
		"    Point3D normal;",
		"    double d;",
		"    Plane3D() : d(0) {}",
		"    Plane3D(const Point3D& n, const Point3D& point) : normal(n.normalize()) { d = -normal.dot(point); }",
		"    double distance_to_point(const Point3D& p) const { return normal.dot(p) + d; }",
		"    double abs_distance_to_point(const Point3D& p) const { return abs(distance_to_point(p)); }",
		"    bool contains_point(const Point3D& p) const { return abs(distance_to_point(p)) < EPS; }",
		"};",
		"",
		"struct Line3D {",
		"    Point3D point, direction;",
		"    Line3D() {}",
		"    Line3D(const Point3D& p, const Point3D& dir) : point(p), direction(dir.normalize()) {}",
		"    Point3D point_at(double t) const { return point + direction * t; }",
		"    double distance_to_point(const Point3D& p) const {",
		"        Point3D to_p = p - point;",
		"        return to_p.cross(direction).norm();",
		"    }",
		"};",
		"",
		"// 三维球体类",
		"struct Sphere3D {",
		"    Point3D center;  // 球心",
		"    double radius;   // 半径",
		"",
		"    // 构造函数",
		"    Sphere3D() : radius(0) {}",
		"    Sphere3D(const Point3D& c, double r) : center(c), radius(r) {}",
		"    Sphere3D(double x, double y, double z, double r) : center(x, y, z), radius(r) {}",
		"",
		"    // 比较运算符",
		"    bool operator==(const Sphere3D& other) const { return center == other.center && abs(radius - other.radius) < EPS; }",
		"",
		"    // 球体的基本属性",
		"    double volume() const { return 4.0 * PI * radius * radius * radius / 3.0; }",
		"    double surface_area() const { return 4.0 * PI * radius * radius; }",
		"    double diameter() const { return 2 * radius; }",
		"",
		"    // 点与球的关系",
		"    // 返回值：-1内部，0边界，1外部",
		"    int point_relation(const Point3D& p) const {",
		"        double d = center.distance(p);",
		"        if (d < radius - EPS) return -1;  // 内部",
		"        if (d > radius + EPS) return 1;   // 外部",
		"        return 0;                         // 边界",
		"    }",
		"",
		"    bool contains(const Point3D& p) const { return point_relation(p) <= 0; }",
		"    bool contains_strictly(const Point3D& p) const { return point_relation(p) < 0; }",
		"    bool on_sphere(const Point3D& p) const { return point_relation(p) == 0; }",
		"",
		"    // 点到球面的最近距离",
		"    double distance_to_point(const Point3D& p) const { return max(0.0, center.distance(p) - radius); }",
		"",
		"    // 直线与球的关系",
		"    // 返回值：-1相离，0相切，1相交",
		"    int line_relation(const Line3D& line) const {",
		"        double d = line.distance_to_point(center);",
		"",
		"        if (d > radius + EPS) return -1;  // 相离",
		"        if (d < radius - EPS) return 1;   // 相交",
		"        return 0;                         // 相切",
		"    }",
		"",
		"    // 直线与球的交点",
		"    vector<Point3D> line_intersection(const Line3D& line) const {",
		"        vector<Point3D> result;",
		"",
		"        // 计算球心到直线的距离",
		"        Point3D to_center = center - line.point;",
		"        double t0 = to_center.dot(line.direction);",
		"        Point3D closest = line.point_at(t0);",
		"        double d = center.distance(closest);",
		"",
		"        if (d > radius + EPS) return result;  // 无交点",
		"",
		"        if (abs(d - radius) < EPS) {",
		"            // 相切，一个交点",
		"            result.push_back(closest);",
		"        } else {",
		"            // 相交，两个交点",
		"            double delta = sqrt(radius * radius - d * d);",
		"            result.push_back(line.point_at(t0 + delta));",
		"            result.push_back(line.point_at(t0 - delta));",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 平面与球的关系",
		"    // 返回值：-1相离，0相切，1相交",
		"    int plane_relation(const Plane3D& plane) const {",
		"        double d = plane.abs_distance_to_point(center);",
		"",
		"        if (d > radius + EPS) return -1;  // 相离",
		"        if (d < radius - EPS) return 1;   // 相交",
		"        return 0;                         // 相切",
		"    }",
		"",
		"    // 平面与球的交线（圆）",
		"    struct Circle3D {",
		"        Point3D center;",
		"        double radius;",
		"        Point3D normal;  // 圆所在平面的法向量",
		"",
		"        Circle3D() : radius(0) {}",
		"        Circle3D(const Point3D& c, double r, const Point3D& n) : center(c), radius(r), normal(n) {}",
		"",
		"        double area() const { return PI * radius * radius; }",
		"        double circumference() const { return 2 * PI * radius; }",
		"    };",
		"",
		"    Circle3D plane_intersection(const Plane3D& plane) const {",
		"        double d = plane.abs_distance_to_point(center);",
		"        if (d > radius + EPS) return Circle3D();  // 无交线",
		"",
		"        // 球心在平面上的投影",
		"        Point3D proj_center = center - plane.normal * plane.distance_to_point(center);",
		"",
		"        if (abs(d - radius) < EPS) {",
		"            // 相切，交点为一个点（半径为0的圆）",
		"            return Circle3D(proj_center, 0, plane.normal);",
		"        } else {",
		"            // 相交，交线为圆",
		"            double circle_radius = sqrt(radius * radius - d * d);",
		"            return Circle3D(proj_center, circle_radius, plane.normal);",
		"        }",
		"    }",
		"",
		"    // 两球关系",
		"    // 返回值：-1外离，0外切，1相交，2内切，3内含",
		"    int sphere_relation(const Sphere3D& other) const {",
		"        double d = center.distance(other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        if (d > r1 + r2 + EPS) return -1;           // 外离",
		"        if (abs(d - r1 - r2) < EPS) return 0;       // 外切",
		"        if (abs(d - abs(r1 - r2)) < EPS) return 2;  // 内切",
		"        if (d < abs(r1 - r2) - EPS) return 3;       // 内含",
		"        return 1;                                   // 相交",
		"    }",
		"",
		"    // 两球交线（圆）",
		"    Circle3D sphere_intersection(const Sphere3D& other) const {",
		"        double d = center.distance(other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        // 无交线的情况",
		"        if (d > r1 + r2 + EPS || d < abs(r1 - r2) - EPS || d < EPS) { return Circle3D(); }",
		"",
		"        // 计算交圆",
		"        double a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);",
		"        double h = sqrt(r1 * r1 - a * a);",
		"",
		"        Point3D circle_center = center + (other.center - center) * (a / d);",
		"        Point3D normal = (other.center - center).normalize();",
		"",
		"        if (abs(h) < EPS) {",
		"            // 一个交点（相切）",
		"            return Circle3D(circle_center, 0, normal);",
		"        } else {",
		"            // 交圆",
		"            return Circle3D(circle_center, h, normal);",
		"        }",
		"    }",
		"",
		"    // 过球外一点的切平面的切点圆",
		"    Circle3D tangent_circle(const Point3D& p) const {",
		"        if (contains_strictly(p)) return Circle3D();  // 点在球内无切平面",
		"",
		"        double d = center.distance(p);",
		"        if (on_sphere(p)) {",
		"            // 点在球面上，切平面为过该点且垂直于半径的平面",
		"            Point3D normal = (p - center).normalize();",
		"            return Circle3D(p, 0, normal);",
		"        }",
		"",
		"        // 点在球外，切点构成一个圆",
		"        double cos_theta = radius / d;",
		"        double sin_theta = sqrt(1 - cos_theta * cos_theta);",
		"        double circle_radius = radius * sin_theta;",
		"        double dist_to_circle = radius * cos_theta;",
		"",
		"        Point3D direction = (p - center).normalize();",
		"        Point3D circle_center = center + direction * dist_to_circle;",
		"",
		"        return Circle3D(circle_center, circle_radius, direction);",
		"    }",
		"};",
		"",
		"// 四点确定球（外接球）",
		"Sphere3D circumsphere(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    // 建立线性方程组求解球心",
		"    Point3D ba = b - a, ca = c - a, da = d - a;",
		"    double ba2 = ba.norm2(), ca2 = ca.norm2(), da2 = da.norm2();",
		"",
		"    // 计算行列式",
		"    double det = ba.dot(ca.cross(da)) * 2;",
		"    if (abs(det) < EPS) return Sphere3D(Point3D(0, 0, 0), -1);  // 四点共面",
		"",
		"    Point3D center = a + (ca.cross(da) * ba2 + da.cross(ba) * ca2 + ba.cross(ca) * da2) / det;",
		"    double radius = center.distance(a);",
		"",
		"    return Sphere3D(center, radius);",
		"}",
		"",
		"// 最小球覆盖（Welzl算法的三维版本）",
		"Sphere3D min_enclosing_sphere(vector<Point3D> points) {",
		"    if (points.empty()) return Sphere3D();",
		"    if (points.size() == 1) return Sphere3D(points[0], 0);",
		"",
		"    random_shuffle(points.begin(), points.end());",
		"",
		"    Sphere3D sphere;",
		"    int n = points.size();",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        if (!sphere.contains(points[i])) {",
		"            sphere = Sphere3D((points[0] + points[i]) * 0.5, points[0].distance(points[i]) * 0.5);",
		"            for (int j = 1; j < i; j++) {",
		"                if (!sphere.contains(points[j])) {",
		"                    // 两点确定直径",
		"                    sphere = Sphere3D((points[i] + points[j]) * 0.5, points[i].distance(points[j]) * 0.5);",
		"                    for (int k = 0; k < j; k++) {",
		"                        if (!sphere.contains(points[k])) {",
		"                            // 三点确定圆，球心在垂直于三点平面的直线上",
		"                            Point3D normal = (points[j] - points[i]).cross(points[k] - points[i]).normalize();",
		"                            Point3D mid = (points[i] + points[j] + points[k]) / 3;",
		"",
		"                            // 寻找最优球心（简化处理）",
		"                            for (int l = 0; l < k; l++) {",
		"                                if (!sphere.contains(points[l])) {",
		"                                    sphere = circumsphere(points[i], points[j], points[k], points[l]);",
		"                                    break;",
		"                                }",
		"                            }",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    return sphere;",
		"}",
	})
}),

-- 05_Geometry\3D\Vector3D.h
s("05_geometry_3d_vector3d_h", {
	t({
		"/*",
		" * 三维向量类模板",
		" * 时间复杂度: 各操作均为 O(1)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 三维几何计算的基础类",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"struct Vector3D {",
		"    double x, y, z;",
		"",
		"    // 构造函数",
		"    Vector3D() : x(0), y(0), z(0) {}",
		"    Vector3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"",
		"    // 基本运算符重载",
		"    Vector3D operator+(const Vector3D& v) const { return Vector3D(x + v.x, y + v.y, z + v.z); }",
		"    Vector3D operator-(const Vector3D& v) const { return Vector3D(x - v.x, y - v.y, z - v.z); }",
		"    Vector3D operator*(double t) const { return Vector3D(x * t, y * t, z * t); }",
		"    Vector3D operator/(double t) const { return Vector3D(x / t, y / t, z / t); }",
		"    Vector3D operator-() const { return Vector3D(-x, -y, -z); }",
		"",
		"    Vector3D& operator+=(const Vector3D& v) {",
		"        x += v.x;",
		"        y += v.y;",
		"        z += v.z;",
		"        return *this;",
		"    }",
		"    Vector3D& operator-=(const Vector3D& v) {",
		"        x -= v.x;",
		"        y -= v.y;",
		"        z -= v.z;",
		"        return *this;",
		"    }",
		"    Vector3D& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        z *= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算符",
		"    bool operator==(const Vector3D& v) const { return abs(x - v.x) < EPS && abs(y - v.y) < EPS && abs(z - v.z) < EPS; }",
		"    bool operator!=(const Vector3D& v) const { return !(*this == v); }",
		"",
		"    // 向量运算",
		"    double dot(const Vector3D& v) const { return x * v.x + y * v.y + z * v.z; }",
		"    Vector3D cross(const Vector3D& v) const {",
		"        return Vector3D(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);",
		"    }",
		"",
		"    // 运算符重载：点乘和叉乘",
		"    double operator*(const Vector3D& v) const { return dot(v); }",
		"    Vector3D operator^(const Vector3D& v) const { return cross(v); }",
		"",
		"    // 长度相关",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double norm2() const { return x * x + y * y + z * z; }",
		"",
		"    // 单位化",
		"    Vector3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Vector3D(0, 0, 0) : Vector3D(x / len, y / len, z / len);",
		"    }",
		"",
		"    // 距离",
		"    double distance(const Vector3D& v) const { return (*this - v).norm(); }",
		"    double distance2(const Vector3D& v) const { return (*this - v).norm2(); }",
		"",
		"    // 角度",
		"    double angle(const Vector3D& v) const {",
		"        double cos_theta = dot(v) / (norm() * v.norm());",
		"        cos_theta = max(-1.0, min(1.0, cos_theta));  // 防止数值误差",
		"        return acos(cos_theta);",
		"    }",
		"",
		"    // 投影",
		"    Vector3D project(const Vector3D& v) const { return v * (dot(v) / v.norm2()); }",
		"",
		"    // 判断是否平行",
		"    bool parallel(const Vector3D& v) const { return cross(v).norm() < EPS; }",
		"",
		"    // 判断是否垂直",
		"    bool perpendicular(const Vector3D& v) const { return abs(dot(v)) < EPS; }",
		"",
		"    // 输出",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \" \" << z << \"\\n\"; }",
		"};",
		"",
		"// 类型别名",
		"using Point3D = Vector3D;",
		"",
		"// 全局函数",
		"double dot(const Vector3D& a, const Vector3D& b) { return a.dot(b); }",
		"Vector3D cross(const Vector3D& a, const Vector3D& b) { return a.cross(b); }",
		"double distance(const Vector3D& a, const Vector3D& b) { return a.distance(b); }",
		"double distance2(const Vector3D& a, const Vector3D& b) { return a.distance2(b); }",
		"",
		"// 混合积（标量三重积）",
		"double scalar_triple_product(const Vector3D& a, const Vector3D& b, const Vector3D& c) { return a * (b ^ c); }",
		"",
		"// 向量三重积",
		"Vector3D vector_triple_product(const Vector3D& a, const Vector3D& b, const Vector3D& c) {",
		"    return b * (a * c) - c * (a * b);",
		"}",
		"",
		"// 四面体体积",
		"double tetrahedron_volume(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return abs(scalar_triple_product(b - a, c - a, d - a)) / 6.0;",
		"}",
		"",
		"// 判断四点共面",
		"bool coplanar(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return abs(scalar_triple_product(b - a, c - a, d - a)) < EPS;",
		"}",
	})
}),

-- 05_Geometry\Utils\Intersection.h
s("05_geometry_utils_intersection_h", {
	t({
		"/*",
		" * 几何相交和数值计算工具",
		" * 时间复杂度: 各函数不同",
		" * 空间复杂度: O(1) - O(n)",
		" * 适用场景: 几何相交判断和数值计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 高斯消元法求解线性方程组",
		"class LinearSolver {",
		"   private:",
		"    vector<vector<double>> matrix;",
		"    vector<double> result;",
		"    int n;",
		"",
		"   public:",
		"    LinearSolver(int size) : n(size) {",
		"        matrix.assign(n, vector<double>(n + 1, 0));",
		"        result.assign(n, 0);",
		"    }",
		"",
		"    void set_coeff(int row, int col, double val) { matrix[row][col] = val; }",
		"    void set_const(int row, double val) { matrix[row][n] = val; }",
		"",
		"    bool solve() {",
		"        for (int i = 0; i < n; i++) {",
		"            // 选主元",
		"            int pivot = i;",
		"            for (int j = i + 1; j < n; j++) {",
		"                if (fabs(matrix[j][i]) > fabs(matrix[pivot][i])) { pivot = j; }",
		"            }",
		"",
		"            if (fabs(matrix[pivot][i]) < EPS) return false;",
		"",
		"            if (pivot != i) swap(matrix[i], matrix[pivot]);",
		"",
		"            // 消元",
		"            for (int j = i + 1; j < n; j++) {",
		"                double factor = matrix[j][i] / matrix[i][i];",
		"                for (int k = i; k <= n; k++) { matrix[j][k] -= factor * matrix[i][k]; }",
		"            }",
		"        }",
		"",
		"        // 回代",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            result[i] = matrix[i][n];",
		"            for (int j = i + 1; j < n; j++) { result[i] -= matrix[i][j] * result[j]; }",
		"            result[i] /= matrix[i][i];",
		"        }",
		"        return true;",
		"    }",
		"",
		"    double get_result(int i) { return result[i]; }",
		"};",
		"",
		"// 二分法求方程根",
		"template <typename F>",
		"double bisection_method(F f, double a, double b, double eps = EPS) {",
		"    if (f(a) * f(b) > 0) return NAN;",
		"",
		"    while (b - a > eps) {",
		"        double mid = (a + b) / 2;",
		"        if (f(a) * f(mid) <= 0) {",
		"            b = mid;",
		"        } else {",
		"            a = mid;",
		"        }",
		"    }",
		"    return (a + b) / 2;",
		"}",
		"",
		"// 牛顿法求方程根",
		"template <typename F, typename DF>",
		"double newton_method(F f, DF df, double x0, int max_iter = 100) {",
		"    double x = x0;",
		"    for (int i = 0; i < max_iter; i++) {",
		"        double fx = f(x);",
		"        double dfx = df(x);",
		"        if (fabs(dfx) < EPS) break;",
		"        double new_x = x - fx / dfx;",
		"        if (fabs(new_x - x) < EPS) break;",
		"        x = new_x;",
		"    }",
		"    return x;",
		"}",
		"",
		"// 三分法求单峰函数极值",
		"template <typename F>",
		"double ternary_search(F f, double left, double right, bool find_max = true) {",
		"    for (int iter = 0; iter < 100; iter++) {",
		"        double m1 = left + (right - left) / 3;",
		"        double m2 = right - (right - left) / 3;",
		"        if ((f(m1) > f(m2)) == find_max) {",
		"            right = m2;",
		"        } else {",
		"            left = m1;",
		"        }",
		"    }",
		"    return (left + right) / 2;",
		"}",
		"",
		"// Simpson积分",
		"template <typename F>",
		"double simpson_integral(F f, double a, double b, int n = 1000) {",
		"    double h = (b - a) / n;",
		"    double sum = f(a) + f(b);",
		"    for (int i = 1; i < n; i++) {",
		"        double x = a + i * h;",
		"        sum += (i % 2 == 1 ? 4 : 2) * f(x);",
		"    }",
		"    return sum * h / 3;",
		"}",
		"",
		"// 自适应Simpson积分",
		"template <typename F>",
		"double adaptive_simpson(F f, double a, double b, double eps = EPS, int max_depth = 15) {",
		"    function<double(double, double, int)> simpson15 = [&](double l, double r, int depth) -> double {",
		"        double mid = (l + r) / 2;",
		"        double left = (l + mid) / 2;",
		"        double right = (mid + r) / 2;",
		"",
		"        double s1 = (r - l) / 6 * (f(l) + 4 * f(mid) + f(r));",
		"        double s2 = (mid - l) / 6 * (f(l) + 4 * f(left) + f(mid)) + (r - mid) / 6 * (f(mid) + 4 * f(right) + f(r));",
		"",
		"        if (depth <= 0 || fabs(s1 - s2) <= 15 * eps) { return s2 + (s2 - s1) / 15; }",
		"",
		"        return simpson15(l, mid, depth - 1) + simpson15(mid, r, depth - 1);",
		"    };",
		"",
		"    return simpson15(a, b, max_depth);",
		"}",
		"",
		"// 拉格朗日插值",
		"class LagrangeInterpolation {",
		"   private:",
		"    vector<pair<double, double>> points;",
		"",
		"   public:",
		"    void add_point(double x, double y) { points.push_back({x, y}); }",
		"",
		"    double interpolate(double x) {",
		"        double result = 0;",
		"        int n = points.size();",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            double term = points[i].second;",
		"            for (int j = 0; j < n; j++) {",
		"                if (i != j) { term *= (x - points[j].first) / (points[i].first - points[j].first); }",
		"            }",
		"            result += term;",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// 格点相关函数",
		"long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }",
		"",
		"// Pick定理：求多边形内部格点数",
		"long long pick_theorem(double area, long long boundary_points) {",
		"    return (long long)(area + 0.5) - boundary_points / 2 + 1;",
		"}",
		"",
		"// 线段上的格点数（不包括端点）",
		"long long lattice_points_on_segment(long long x1, long long y1, long long x2, long long y2) {",
		"    return gcd(abs(x2 - x1), abs(y2 - y1)) - 1;",
		"}",
		"",
		"// FFT快速傅里叶变换",
		"void fft(vector<complex<double>>& a, bool invert = false) {",
		"    int n = a.size();",
		"",
		"    for (int i = 1, j = 0; i < n; i++) {",
		"        int bit = n >> 1;",
		"        for (; j & bit; bit >>= 1) j ^= bit;",
		"        j ^= bit;",
		"        if (i < j) swap(a[i], a[j]);",
		"    }",
		"",
		"    for (int len = 2; len <= n; len <<= 1) {",
		"        double ang = 2 * M_PI / len * (invert ? -1 : 1);",
		"        complex<double> wlen(cos(ang), sin(ang));",
		"",
		"        for (int i = 0; i < n; i += len) {",
		"            complex<double> w(1);",
		"            for (int j = 0; j < len / 2; j++) {",
		"                complex<double> u = a[i + j];",
		"                complex<double> v = a[i + j + len / 2] * w;",
		"                a[i + j] = u + v;",
		"                a[i + j + len / 2] = u - v;",
		"                w *= wlen;",
		"            }",
		"        }",
		"    }",
		"",
		"    if (invert) {",
		"        for (auto& x : a) x /= n;",
		"    }",
		"}",
		"",
		"// 多项式求值（Horner方法）",
		"double polynomial_eval(const vector<double>& coeffs, double x) {",
		"    double result = 0;",
		"    for (int i = coeffs.size() - 1; i >= 0; i--) { result = result * x + coeffs[i]; }",
		"    return result;",
		"}",
		"",
		"// 数值微分（中心差分）",
		"template <typename F>",
		"double numerical_derivative(F f, double x, double h = 1e-6) {",
		"    return (f(x + h) - f(x - h)) / (2 * h);",
		"}",
		"",
		"// 随机点生成器",
		"struct RandomPointGenerator {",
		"    mt19937 gen;",
		"    uniform_real_distribution<double> dis;",
		"",
		"    RandomPointGenerator(double min_val = -100, double max_val = 100) : gen(random_device{}()), dis(min_val, max_val) {}",
		"",
		"    pair<double, double> random_point() { return make_pair(dis(gen), dis(gen)); }",
		"",
		"    // 在圆内生成随机点",
		"    pair<double, double> random_point_in_circle(double cx, double cy, double r) {",
		"        double theta = dis(gen) * 2 * M_PI / 200.0;",
		"        double radius = sqrt(dis(gen) / 200.0) * r;",
		"        return make_pair(cx + radius * cos(theta), cy + radius * sin(theta));",
		"    }",
		"};",
	})
}),

-- 05_Geometry\Utils\Precision.h
s("05_geometry_utils_precision_h", {
	t({
		"/*",
		" * 几何精度处理工具",
		" * 时间复杂度: O(1)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 几何计算中的精度控制和浮点数比较",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 浮点数比较函数",
		"int dcmp(double x) {",
		"    if (fabs(x) < EPS) return 0;",
		"    return x < 0 ? -1 : 1;",
		"}",
		"",
		"bool equal(double a, double b) { return fabs(a - b) < EPS; }",
		"bool less(double a, double b) { return a < b - EPS; }",
		"bool less_equal(double a, double b) { return a < b + EPS; }",
		"bool greater(double a, double b) { return a > b + EPS; }",
		"bool greater_equal(double a, double b) { return a > b - EPS; }",
		"",
		"// 角度标准化",
		"double normalize_angle(double angle) {",
		"    while (angle < 0) angle += 2 * PI;",
		"    while (angle >= 2 * PI) angle -= 2 * PI;",
		"    return angle;",
		"}",
		"",
		"double normalize_angle_pm_pi(double angle) {",
		"    while (angle < -PI) angle += 2 * PI;",
		"    while (angle > PI) angle -= 2 * PI;",
		"    return angle;",
		"}",
		"",
		"// 安全的数学函数",
		"double safe_acos(double x) { return acos(max(-1.0, min(1.0, x))); }",
		"double safe_asin(double x) { return asin(max(-1.0, min(1.0, x))); }",
		"double safe_sqrt(double x) { return sqrt(max(0.0, x)); }",
		"",
		"// 数值稳定的二次方程求解",
		"pair<double, double> solve_quadratic(double a, double b, double c) {",
		"    if (fabs(a) < EPS) {",
		"        if (fabs(b) < EPS) return {NAN, NAN};",
		"        return {-c / b, NAN};",
		"    }",
		"",
		"    double discriminant = b * b - 4 * a * c;",
		"    if (discriminant < -EPS) return {NAN, NAN};",
		"",
		"    discriminant = max(0.0, discriminant);",
		"    double sqrt_d = sqrt(discriminant);",
		"",
		"    double x1, x2;",
		"    if (b >= 0) {",
		"        x1 = (-b - sqrt_d) / (2 * a);",
		"        x2 = c / (a * x1);",
		"    } else {",
		"        x2 = (-b + sqrt_d) / (2 * a);",
		"        x1 = c / (a * x2);",
		"    }",
		"",
		"    if (x1 > x2) swap(x1, x2);",
		"    return {x1, x2};",
		"}",
		"",
		"// 高精度距离计算",
		"double distance2_stable(double x1, double y1, double x2, double y2) {",
		"    double dx = x2 - x1;",
		"    double dy = y2 - y1;",
		"    return dx * dx + dy * dy;",
		"}",
		"",
		"// 高精度三角形面积计算（海伦公式的数值稳定版本）",
		"double triangle_area_stable(double x1, double y1, double x2, double y2, double x3, double y3) {",
		"    double a = safe_sqrt(distance2_stable(x2, y2, x3, y3));",
		"    double b = safe_sqrt(distance2_stable(x1, y1, x3, y3));",
		"    double c = safe_sqrt(distance2_stable(x1, y1, x2, y2));",
		"",
		"    if (a > b) swap(a, b);",
		"    if (b > c) swap(b, c);",
		"    if (a > b) swap(a, b);",
		"",
		"    double s = (a + b + c) / 2;",
		"    double area_sq = s * (s - a) * (s - b) * (s - c);",
		"    return safe_sqrt(area_sq);",
		"}",
		"",
		"// 自适应精度处理",
		"class AdaptivePrecision {",
		"   private:",
		"    double base_eps;",
		"    double scale_factor;",
		"",
		"   public:",
		"    AdaptivePrecision(double eps = EPS, double scale = 1e6) : base_eps(eps), scale_factor(scale) {}",
		"",
		"    double get_eps(double magnitude) const { return base_eps * max(1.0, magnitude / scale_factor); }",
		"",
		"    bool equal(double a, double b) const {",
		"        double mag = max(fabs(a), fabs(b));",
		"        return fabs(a - b) < get_eps(mag);",
		"    }",
		"",
		"    int sign(double x) const {",
		"        double eps = get_eps(fabs(x));",
		"        if (fabs(x) < eps) return 0;",
		"        return x < 0 ? -1 : 1;",
		"    }",
		"};",
		"",
		"// 有理数近似",
		"struct Fraction {",
		"    long long num, den;",
		"",
		"    Fraction(long long n = 0, long long d = 1) : num(n), den(d) {",
		"        if (den < 0) {",
		"            num = -num;",
		"            den = -den;",
		"        }",
		"        long long g = __gcd(abs(num), abs(den));",
		"        num /= g;",
		"        den /= g;",
		"    }",
		"",
		"    Fraction(double x, long long max_den = 1000000) {",
		"        num = 0;",
		"        den = 1;",
		"        long long a = (long long)floor(x);",
		"        long long p0 = 1, p1 = a, q0 = 0, q1 = 1;",
		"",
		"        double r = x - a;",
		"        while (fabs(r) > EPS && q1 <= max_den) {",
		"            r = 1.0 / r;",
		"            a = (long long)floor(r);",
		"            long long p2 = a * p1 + p0;",
		"            long long q2 = a * q1 + q0;",
		"",
		"            if (q2 > max_den) break;",
		"",
		"            p0 = p1;",
		"            p1 = p2;",
		"            q0 = q1;",
		"            q1 = q2;",
		"            r = r - a;",
		"        }",
		"",
		"        num = p1;",
		"        den = q1;",
		"        if (den < 0) {",
		"            num = -num;",
		"            den = -den;",
		"        }",
		"        long long g = __gcd(abs(num), abs(den));",
		"        num /= g;",
		"        den /= g;",
		"    }",
		"",
		"    double to_double() const { return (double)num / den; }",
		"",
		"    Fraction operator+(const Fraction& f) const { return Fraction(num * f.den + f.num * den, den * f.den); }",
		"    Fraction operator-(const Fraction& f) const { return Fraction(num * f.den - f.num * den, den * f.den); }",
		"    Fraction operator*(const Fraction& f) const { return Fraction(num * f.num, den * f.den); }",
		"    Fraction operator/(const Fraction& f) const { return Fraction(num * f.den, den * f.num); }",
		"",
		"    bool operator==(const Fraction& f) const { return num * f.den == f.num * den; }",
		"    bool operator<(const Fraction& f) const { return num * f.den < f.num * den; }",
		"};",
	})
}),

-- 05_Geometry\Utils\Transformation.h
s("05_geometry_utils_transformation_h", {
	t({
		"/*",
		" * 几何坐标变换工具",
		" * 时间复杂度: O(1)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 二维几何中的坐标变换操作",
		" */",
		"",
		"const double PI = acos(-1.0);",
		"",
		"// 角度弧度转换",
		"double to_radian(double degree) { return degree * PI / 180.0; }",
		"double to_degree(double radian) { return radian * 180.0 / PI; }",
		"",
		"// 极坐标结构",
		"struct Polar {",
		"    double r, theta;",
		"    Polar(double r = 0, double theta = 0) : r(r), theta(theta) {}",
		"};",
		"",
		"// 直角坐标与极坐标转换",
		"Polar to_polar(double x, double y) { return Polar(sqrt(x * x + y * y), atan2(y, x)); }",
		"",
		"pair<double, double> to_cartesian(const Polar& p) { return make_pair(p.r * cos(p.theta), p.r * sin(p.theta)); }",
		"",
		"// 二维变换矩阵",
		"struct Transform2D {",
		"    double a, b, c, d, tx, ty;  // 变换矩阵 [a c tx; b d ty; 0 0 1]",
		"",
		"    Transform2D() : a(1), b(0), c(0), d(1), tx(0), ty(0) {}",
		"",
		"    // 平移变换",
		"    static Transform2D translate(double dx, double dy) {",
		"        Transform2D t;",
		"        t.tx = dx;",
		"        t.ty = dy;",
		"        return t;",
		"    }",
		"",
		"    // 旋转变换（绕原点，弧度）",
		"    static Transform2D rotate(double theta) {",
		"        Transform2D t;",
		"        t.a = cos(theta);",
		"        t.c = -sin(theta);",
		"        t.b = sin(theta);",
		"        t.d = cos(theta);",
		"        return t;",
		"    }",
		"",
		"    // 缩放变换",
		"    static Transform2D scale(double sx, double sy) {",
		"        Transform2D t;",
		"        t.a = sx;",
		"        t.d = sy;",
		"        return t;",
		"    }",
		"",
		"    // 反射变换（沿x轴）",
		"    static Transform2D reflect_x() {",
		"        Transform2D t;",
		"        t.d = -1;",
		"        return t;",
		"    }",
		"",
		"    // 反射变换（沿y轴）",
		"    static Transform2D reflect_y() {",
		"        Transform2D t;",
		"        t.a = -1;",
		"        return t;",
		"    }",
		"",
		"    // 剪切变换",
		"    static Transform2D shear(double sx, double sy) {",
		"        Transform2D t;",
		"        t.c = sx;",
		"        t.b = sy;",
		"        return t;",
		"    }",
		"",
		"    // 变换合成",
		"    Transform2D operator*(const Transform2D& other) const {",
		"        Transform2D result;",
		"        result.a = a * other.a + c * other.b;",
		"        result.b = b * other.a + d * other.b;",
		"        result.c = a * other.c + c * other.d;",
		"        result.d = b * other.c + d * other.d;",
		"        result.tx = a * other.tx + c * other.ty + tx;",
		"        result.ty = b * other.tx + d * other.ty + ty;",
		"        return result;",
		"    }",
		"",
		"    // 应用变换",
		"    pair<double, double> apply(double x, double y) const { return make_pair(a * x + c * y + tx, b * x + d * y + ty); }",
		"",
		"    // 逆变换",
		"    Transform2D inverse() const {",
		"        double det = a * d - b * c;",
		"        if (fabs(det) < 1e-9) return Transform2D();  // 奇异矩阵",
		"",
		"        Transform2D inv;",
		"        inv.a = d / det;",
		"        inv.b = -b / det;",
		"        inv.c = -c / det;",
		"        inv.d = a / det;",
		"        inv.tx = (c * ty - d * tx) / det;",
		"        inv.ty = (b * tx - a * ty) / det;",
		"        return inv;",
		"    }",
		"};",
		"",
		"// 点绕某点旋转",
		"pair<double, double> rotate_point(double x, double y, double cx, double cy, double theta) {",
		"    double costh = cos(theta), sinth = sin(theta);",
		"    double dx = x - cx, dy = y - cy;",
		"    return make_pair(cx + dx * costh - dy * sinth, cy + dx * sinth + dy * costh);",
		"}",
		"",
		"// 点关于直线对称",
		"pair<double, double> reflect_point(double x, double y, double a, double b, double c) {",
		"    // 直线方程: ax + by + c = 0",
		"    double norm2 = a * a + b * b;",
		"    double t = -(a * x + b * y + c) / norm2;",
		"    return make_pair(x + 2 * a * t, y + 2 * b * t);",
		"}",
		"",
		"// 齐次坐标变换",
		"struct HomogeneousTransform {",
		"    double matrix[3][3];",
		"",
		"    HomogeneousTransform() {",
		"        memset(matrix, 0, sizeof(matrix));",
		"        matrix[0][0] = matrix[1][1] = matrix[2][2] = 1;",
		"    }",
		"",
		"    // 应用变换",
		"    pair<double, double> apply(double x, double y) const {",
		"        double w = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2];",
		"        return make_pair((matrix[0][0] * x + matrix[0][1] * y + matrix[0][2]) / w,",
		"                         (matrix[1][0] * x + matrix[1][1] * y + matrix[1][2]) / w);",
		"    }",
		"",
		"    // 透视变换",
		"    static HomogeneousTransform perspective(double px, double py) {",
		"        HomogeneousTransform t;",
		"        t.matrix[2][0] = px;",
		"        t.matrix[2][1] = py;",
		"        return t;",
		"    }",
		"};",
		"",
		"// 仿射变换参数计算",
		"Transform2D compute_affine_transform(const vector<pair<double, double>>& src, const vector<pair<double, double>>& dst) {",
		"    if (src.size() != dst.size() || src.size() < 3) {",
		"        return Transform2D();  // 至少需要3个点",
		"    }",
		"",
		"    // 使用最小二乘法计算变换参数",
		"    // 这里实现简化版本，实际应用中可能需要更复杂的算法",
		"    Transform2D t;",
		"",
		"    // 简单的平移计算",
		"    double sx = 0, sy = 0, dx = 0, dy = 0;",
		"    for (int i = 0; i < src.size(); i++) {",
		"        sx += src[i].first;",
		"        sy += src[i].second;",
		"        dx += dst[i].first;",
		"        dy += dst[i].second;",
		"    }",
		"",
		"    t.tx = dx / src.size() - sx / src.size();",
		"    t.ty = dy / src.size() - sy / src.size();",
		"",
		"    return t;",
		"}",
	})
}),

-- 06_String_Algorithms\Advanced\Booth.h
s("06_string_algorithms_advanced_booth_h", {
	t({
		"/**",
		" * Booth算法",
		" * 功能：线性时间内找到字符串的字典序最小循环移位位置",
		" * 时间复杂度：O(n)",
		" * 空间复杂度：O(n)",
		" * 适用场景：字符串最小表示、循环字符串比较、字符串规范化",
		" */",
		"struct BoothAlgorithm {",
		"    // Booth算法主函数",
		"    static int minimum_rotation(const string& s) {",
		"        string ss = s + s;",
		"        int n = s.length();",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            k = 0;",
		"            while (k < n && ss[i + k] == ss[j + k]) { k++; }",
		"",
		"            if (k == n) break;",
		"",
		"            if (ss[i + k] > ss[j + k]) {",
		"                i = max(i + k + 1, j + 1);",
		"                if (i == j) i++;",
		"            } else {",
		"                j = max(j + k + 1, i + 1);",
		"                if (i == j) j++;",
		"            }",
		"        }",
		"",
		"        return min(i, j);",
		"    }",
		"",
		"    // 获取字符串的最小表示",
		"    static string get_minimum_representation(const string& s) {",
		"        int pos = minimum_rotation(s);",
		"        return s.substr(pos) + s.substr(0, pos);",
		"    }",
		"",
		"    // 获取字符串的最大表示",
		"    static string get_maximum_representation(const string& s) {",
		"        string ss = s + s;",
		"        int n = s.length();",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            k = 0;",
		"            while (k < n && ss[i + k] == ss[j + k]) { k++; }",
		"",
		"            if (k == n) break;",
		"",
		"            if (ss[i + k] < ss[j + k]) {  // 注意这里改为小于号",
		"                i = max(i + k + 1, j + 1);",
		"                if (i == j) i++;",
		"            } else {",
		"                j = max(j + k + 1, i + 1);",
		"                if (i == j) j++;",
		"            }",
		"        }",
		"",
		"        int pos = min(i, j);",
		"        return s.substr(pos) + s.substr(0, pos);",
		"    }",
		"",
		"    // 比较两个字符串的循环表示",
		"    static int compare_cyclic(const string& s1, const string& s2) {",
		"        string min1 = get_minimum_representation(s1);",
		"        string min2 = get_minimum_representation(s2);",
		"",
		"        if (min1 < min2) return -1;",
		"        if (min1 > min2) return 1;",
		"        return 0;",
		"    }",
		"",
		"    // 检查两个字符串是否循环同构",
		"    static bool are_cyclic_isomorphic(const string& s1, const string& s2) {",
		"        if (s1.length() != s2.length()) return false;",
		"        return get_minimum_representation(s1) == get_minimum_representation(s2);",
		"    }",
		"",
		"    // 计算字符串的所有循环移位并按字典序排序",
		"    static vector<string> all_rotations_sorted(const string& s) {",
		"        vector<string> rotations;",
		"        int n = s.length();",
		"",
		"        for (int i = 0; i < n; i++) { rotations.push_back(s.substr(i) + s.substr(0, i)); }",
		"",
		"        sort(rotations.begin(), rotations.end());",
		"        return rotations;",
		"    }",
		"",
		"    // 使用Booth算法的字符串周期检测",
		"    static vector<int> find_all_periods(const string& s) {",
		"        vector<int> periods;",
		"        int n = s.length();",
		"",
		"        for (int period = 1; period <= n; period++) {",
		"            if (n % period == 0) {",
		"                bool is_period = true;",
		"                string pattern = s.substr(0, period);",
		"",
		"                for (int i = period; i < n; i += period) {",
		"                    if (s.substr(i, period) != pattern) {",
		"                        is_period = false;",
		"                        break;",
		"                    }",
		"                }",
		"",
		"                if (is_period) { periods.push_back(period); }",
		"            }",
		"        }",
		"",
		"        return periods;",
		"    }",
		"",
		"    // 计算最小周期",
		"    static int minimum_period(const string& s) {",
		"        auto periods = find_all_periods(s);",
		"        return periods.empty() ? s.length() : periods[0];",
		"    }",
		"",
		"    // 使用Booth算法优化的字符串匹配",
		"    static vector<int> cyclic_string_matching(const string& text, const string& pattern) {",
		"        vector<int> matches;",
		"        string min_pattern = get_minimum_representation(pattern);",
		"        int n = text.length();",
		"        int m = pattern.length();",
		"",
		"        for (int i = 0; i <= n - m; i++) {",
		"            string substr = text.substr(i, m);",
		"            if (get_minimum_representation(substr) == min_pattern) { matches.push_back(i); }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    // Lyndon词判断（基于Booth算法）",
		"    static bool is_lyndon_word(const string& s) {",
		"        if (s.empty()) return false;",
		"",
		"        int min_pos = minimum_rotation(s);",
		"        if (min_pos != 0) return false;",
		"",
		"        // 检查是否为primitive（不是其他字符串的幂）",
		"        int period = minimum_period(s);",
		"        return period == s.length();",
		"    }",
		"",
		"    // 构造字符串的Booth标准形",
		"    static string booth_canonical_form(const string& s) {",
		"        string min_repr = get_minimum_representation(s);",
		"",
		"        // 添加额外的标准化步骤",
		"        // 例如，如果需要处理大小写不敏感，可以转换为小写",
		"        transform(min_repr.begin(), min_repr.end(), min_repr.begin(), ::tolower);",
		"",
		"        return min_repr;",
		"    }",
		"",
		"    // 使用Booth算法的高效循环字符串哈希",
		"    static unsigned long long cyclic_hash(const string& s) {",
		"        string canonical = get_minimum_representation(s);",
		"        unsigned long long hash_val = 0;",
		"        unsigned long long base = 31;",
		"        unsigned long long mod = 1e9 + 7;",
		"",
		"        for (char c : canonical) { hash_val = (hash_val * base + (c - 'a' + 1)) % mod; }",
		"",
		"        return hash_val;",
		"    }",
		"",
		"   private:",
		"    // 辅助函数：比较两个字符串的字典序（考虑循环）",
		"    static int cyclic_compare(const string& s, int pos1, int pos2, int len) {",
		"        for (int i = 0; i < len; i++) {",
		"            char c1 = s[(pos1 + i) % s.length()];",
		"            char c2 = s[(pos2 + i) % s.length()];",
		"            if (c1 < c2) return -1;",
		"            if (c1 > c2) return 1;",
		"        }",
		"        return 0;",
		"    }",
		"",
		"   public:",
		"    // 扩展Booth算法：处理多字符串的最小表示",
		"    static vector<string> minimum_representations(const vector<string>& strings) {",
		"        vector<string> results;",
		"        results.reserve(strings.size());",
		"",
		"        for (const string& s : strings) { results.push_back(get_minimum_representation(s)); }",
		"",
		"        return results;",
		"    }",
		"",
		"    // 计算循环等价类的代表元素",
		"    static string equivalence_class_representative(const string& s) { return get_minimum_representation(s); }",
		"",
		"    // 判断字符串是否是原始的（primitive）",
		"    static bool is_primitive(const string& s) { return minimum_period(s) == s.length(); }",
		"};",
	})
}),

-- 06_String_Algorithms\Advanced\Lyndon.h
s("06_string_algorithms_advanced_lyndon_h", {
	t({
		"/**",
		" * Lyndon词分解算法",
		" * 功能：将字符串分解为Lyndon词的连接，支持各种Lyndon词相关操作",
		" * 时间复杂度：Duval算法 O(n)，标准分解 O(n²)",
		" * 空间复杂度：O(n)",
		" * 适用场景：字符串周期性分析、最小循环移位、字符串比较",
		" */",
		"struct LyndonDecomposition {",
		"    // Duval算法 - 线性时间Lyndon分解",
		"    static vector<string> duval_algorithm(const string& s) {",
		"        vector<string> factorization;",
		"        int n = s.length();",
		"        int i = 0;",
		"",
		"        while (i < n) {",
		"            int j = i + 1, k = i;",
		"",
		"            while (j < n && s[k] <= s[j]) {",
		"                if (s[k] < s[j]) {",
		"                    k = i;",
		"                } else {",
		"                    k++;",
		"                }",
		"                j++;",
		"            }",
		"",
		"            while (i <= k) {",
		"                factorization.push_back(s.substr(i, j - k));",
		"                i += j - k;",
		"            }",
		"        }",
		"",
		"        return factorization;",
		"    }",
		"",
		"    // 检查字符串是否为Lyndon词",
		"    static bool is_lyndon_word(const string& s) {",
		"        int n = s.length();",
		"        for (int i = 1; i < n; i++) {",
		"            if (s.substr(i) + s.substr(0, i) <= s) { return false; }",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 生成长度为n，字母表大小为k的所有Lyndon词",
		"    static vector<string> generate_lyndon_words(int n, int k) {",
		"        vector<string> result;",
		"        string current(n, 'a');",
		"",
		"        function<void(int)> generate = [&](int pos) {",
		"            if (pos == n) {",
		"                if (is_lyndon_word(current)) { result.push_back(current); }",
		"                return;",
		"            }",
		"",
		"            for (int c = 0; c < k; c++) {",
		"                current[pos] = 'a' + c;",
		"                generate(pos + 1);",
		"            }",
		"        };",
		"",
		"        generate(0);",
		"        return result;",
		"    }",
		"",
		"    // 计算字符串的Lyndon分解并返回详细信息",
		"    static vector<pair<string, pair<int, int>>> detailed_decomposition(const string& s) {",
		"        vector<pair<string, pair<int, int>>> result;",
		"        int n = s.length();",
		"        int i = 0;",
		"",
		"        while (i < n) {",
		"            int j = i + 1, k = i;",
		"",
		"            while (j < n && s[k] <= s[j]) {",
		"                if (s[k] < s[j]) {",
		"                    k = i;",
		"                } else {",
		"                    k++;",
		"                }",
		"                j++;",
		"            }",
		"",
		"            while (i <= k) {",
		"                int len = j - k;",
		"                result.push_back({s.substr(i, len), {i, i + len - 1}});",
		"                i += len;",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 使用Lyndon分解求最小后缀",
		"    static int minimum_suffix(const string& s) {",
		"        int n = s.length();",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            if (s[(i + k) % n] == s[(j + k) % n]) {",
		"                k++;",
		"            } else if (s[(i + k) % n] > s[(j + k) % n]) {",
		"                i = i + k + 1;",
		"                if (i <= j) i = j + 1;",
		"                k = 0;",
		"            } else {",
		"                j = j + k + 1;",
		"                if (j <= i) j = i + 1;",
		"                k = 0;",
		"            }",
		"        }",
		"",
		"        return min(i, j);",
		"    }",
		"",
		"    // 使用Lyndon分解求最大后缀",
		"    static int maximum_suffix(const string& s) {",
		"        int n = s.length();",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            if (s[(i + k) % n] == s[(j + k) % n]) {",
		"                k++;",
		"            } else if (s[(i + k) % n] < s[(j + k) % n]) {",
		"                i = i + k + 1;",
		"                if (i <= j) i = j + 1;",
		"                k = 0;",
		"            } else {",
		"                j = j + k + 1;",
		"                if (j <= i) j = i + 1;",
		"                k = 0;",
		"            }",
		"        }",
		"",
		"        return min(i, j);",
		"    }",
		"",
		"    // 计算字符串的字典序最小循环移位",
		"    static string minimum_rotation(const string& s) {",
		"        string doubled = s + s;",
		"        int pos = minimum_suffix(doubled.substr(0, 2 * s.length() - 1));",
		"        return doubled.substr(pos, s.length());",
		"    }",
		"",
		"    // 计算字符串的字典序最大循环移位",
		"    static string maximum_rotation(const string& s) {",
		"        string doubled = s + s;",
		"        int pos = maximum_suffix(doubled.substr(0, 2 * s.length() - 1));",
		"        return doubled.substr(pos, s.length());",
		"    }",
		"",
		"    // 检查两个字符串是否循环等价",
		"    static bool are_cyclic_equivalent(const string& s1, const string& s2) {",
		"        if (s1.length() != s2.length()) return false;",
		"        return minimum_rotation(s1) == minimum_rotation(s2);",
		"    }",
		"",
		"    // 使用Lyndon分解进行字符串比较",
		"    static int lyndon_compare(const string& s1, const string& s2) {",
		"        auto decomp1 = duval_algorithm(s1);",
		"        auto decomp2 = duval_algorithm(s2);",
		"",
		"        int i = 0;",
		"        while (i < decomp1.size() && i < decomp2.size()) {",
		"            if (decomp1[i] < decomp2[i]) return -1;",
		"            if (decomp1[i] > decomp2[i]) return 1;",
		"            i++;",
		"        }",
		"",
		"        if (decomp1.size() < decomp2.size()) return -1;",
		"        if (decomp1.size() > decomp2.size()) return 1;",
		"        return 0;",
		"    }",
		"",
		"    // 计算Lyndon词的标准分解",
		"    static pair<string, string> standard_factorization(const string& s) {",
		"        if (!is_lyndon_word(s)) return {\"\", \"\"};",
		"",
		"        int n = s.length();",
		"        if (n == 1) return {s, \"\"};",
		"",
		"        // 找到最大的真前缀，使得它是一个Lyndon词",
		"        for (int i = n - 1; i >= 1; i--) {",
		"            string prefix = s.substr(0, i);",
		"            string suffix = s.substr(i);",
		"",
		"            if (is_lyndon_word(prefix) && prefix < suffix) { return {prefix, suffix}; }",
		"        }",
		"",
		"        return {s.substr(0, 1), s.substr(1)};",
		"    }",
		"",
		"    // 构造Lyndon词的Christoffel词表示",
		"    static string christoffel_word(int p, int q) {",
		"        // 构造斜率为p/q的Christoffel词",
		"        string result;",
		"        int a = 0, b = 0;",
		"",
		"        while (a < q || b < p) {",
		"            if ((a + 1) * q < (b + 1) * p) {",
		"                result += 'a';",
		"                a++;",
		"            } else {",
		"                result += 'b';",
		"                b++;",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Advanced\MinimalRotation.h
s("06_string_algorithms_advanced_minimalrotation_h", {
	t({
		"/**",
		" * 最小表示法算法集合",
		" * 功能：求字符串的最小循环移位、字典序最小的旋转等",
		" * 时间复杂度：O(n)",
		" * 空间复杂度：O(n)",
		" * 适用场景：字符串规范化、循环字符串比较、旋转字符串处理",
		" */",
		"struct MinimalRotation {",
		"    // 标准的最小表示法算法",
		"    static int find_minimal_rotation(const string& s) {",
		"        int n = s.length();",
		"        string doubled = s + s;",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            k = 0;",
		"            while (k < n && doubled[i + k] == doubled[j + k]) { k++; }",
		"",
		"            if (k == n) break;",
		"",
		"            if (doubled[i + k] > doubled[j + k]) {",
		"                i = i + k + 1;",
		"                if (i <= j) i = j + 1;",
		"            } else {",
		"                j = j + k + 1;",
		"                if (j <= i) j = i + 1;",
		"            }",
		"        }",
		"",
		"        return min(i, j);",
		"    }",
		"",
		"    // 获取最小循环表示",
		"    static string get_minimal_string(const string& s) {",
		"        int pos = find_minimal_rotation(s);",
		"        return s.substr(pos) + s.substr(0, pos);",
		"    }",
		"",
		"    // 最大表示法",
		"    static int find_maximal_rotation(const string& s) {",
		"        int n = s.length();",
		"        string doubled = s + s;",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            k = 0;",
		"            while (k < n && doubled[i + k] == doubled[j + k]) { k++; }",
		"",
		"            if (k == n) break;",
		"",
		"            if (doubled[i + k] < doubled[j + k]) {",
		"                i = i + k + 1;",
		"                if (i <= j) i = j + 1;",
		"            } else {",
		"                j = j + k + 1;",
		"                if (j <= i) j = i + 1;",
		"            }",
		"        }",
		"",
		"        return min(i, j);",
		"    }",
		"",
		"    // 获取最大循环表示",
		"    static string get_maximal_string(const string& s) {",
		"        int pos = find_maximal_rotation(s);",
		"        return s.substr(pos) + s.substr(0, pos);",
		"    }",
		"",
		"    // 数值版本的最小表示法（处理数字序列）",
		"    static int find_minimal_rotation_numeric(const vector<int>& arr) {",
		"        int n = arr.size();",
		"        vector<int> doubled(arr.begin(), arr.end());",
		"        doubled.insert(doubled.end(), arr.begin(), arr.end());",
		"",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            k = 0;",
		"            while (k < n && doubled[i + k] == doubled[j + k]) { k++; }",
		"",
		"            if (k == n) break;",
		"",
		"            if (doubled[i + k] > doubled[j + k]) {",
		"                i = i + k + 1;",
		"                if (i <= j) i = j + 1;",
		"            } else {",
		"                j = j + k + 1;",
		"                if (j <= i) j = i + 1;",
		"            }",
		"        }",
		"",
		"        return min(i, j);",
		"    }",
		"",
		"    // 获取数值序列的最小循环表示",
		"    static vector<int> get_minimal_array(const vector<int>& arr) {",
		"        int pos = find_minimal_rotation_numeric(arr);",
		"        vector<int> result;",
		"        int n = arr.size();",
		"",
		"        for (int i = 0; i < n; i++) { result.push_back(arr[(pos + i) % n]); }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 比较两个字符串的循环字典序",
		"    static int compare_cyclic(const string& s1, const string& s2) {",
		"        string min1 = get_minimal_string(s1);",
		"        string min2 = get_minimal_string(s2);",
		"",
		"        if (min1 < min2) return -1;",
		"        if (min1 > min2) return 1;",
		"        return 0;",
		"    }",
		"",
		"    // 检查两个字符串是否循环等价",
		"    static bool are_cyclic_equivalent(const string& s1, const string& s2) {",
		"        if (s1.length() != s2.length()) return false;",
		"        return get_minimal_string(s1) == get_minimal_string(s2);",
		"    }",
		"",
		"    // 计算字符串的所有不同循环移位",
		"    static vector<string> get_unique_rotations(const string& s) {",
		"        set<string> unique_set;",
		"        int n = s.length();",
		"",
		"        for (int i = 0; i < n; i++) { unique_set.insert(s.substr(i) + s.substr(0, i)); }",
		"",
		"        return vector<string>(unique_set.begin(), unique_set.end());",
		"    }",
		"",
		"    // 使用最小表示法的字符串标准化",
		"    static string normalize(const string& s) { return get_minimal_string(s); }",
		"",
		"    // 计算循环字符串的哈希值",
		"    static unsigned long long cyclic_hash(const string& s) {",
		"        string canonical = get_minimal_string(s);",
		"        unsigned long long hash_val = 0;",
		"        unsigned long long base = 131;",
		"",
		"        for (char c : canonical) { hash_val = hash_val * base + c; }",
		"",
		"        return hash_val;",
		"    }",
		"",
		"    // 找到所有具有相同最小表示的字符串的起始位置",
		"    static vector<int> find_all_minimal_positions(const string& s) {",
		"        string minimal = get_minimal_string(s);",
		"        vector<int> positions;",
		"        int n = s.length();",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            string rotation = s.substr(i) + s.substr(0, i);",
		"            if (rotation == minimal) { positions.push_back(i); }",
		"        }",
		"",
		"        return positions;",
		"    }",
		"",
		"    // 判断字符串是否为其最小表示",
		"    static bool is_minimal_representation(const string& s) { return find_minimal_rotation(s) == 0; }",
		"",
		"    // 计算到最小表示的距离（需要的循环移位次数）",
		"    static int distance_to_minimal(const string& s) { return find_minimal_rotation(s); }",
		"",
		"    // 字符串的周期性分析",
		"    static vector<int> find_periods_using_minimal_rotation(const string& s) {",
		"        vector<int> periods;",
		"        int n = s.length();",
		"",
		"        for (int p = 1; p <= n; p++) {",
		"            if (n % p == 0) {",
		"                string pattern = s.substr(0, p);",
		"                bool is_period = true;",
		"",
		"                for (int i = p; i < n; i += p) {",
		"                    if (s.substr(i, p) != pattern) {",
		"                        is_period = false;",
		"                        break;",
		"                    }",
		"                }",
		"",
		"                if (is_period) { periods.push_back(p); }",
		"            }",
		"        }",
		"",
		"        return periods;",
		"    }",
		"",
		"    // 使用最小表示法进行字符串分组",
		"    static map<string, vector<string>> group_by_cyclic_equivalence(const vector<string>& strings) {",
		"        map<string, vector<string>> groups;",
		"",
		"        for (const string& s : strings) {",
		"            string canonical = get_minimal_string(s);",
		"            groups[canonical].push_back(s);",
		"        }",
		"",
		"        return groups;",
		"    }",
		"",
		"    // 扩展到处理权重字符串（每个字符有权重）",
		"    static int find_minimal_rotation_weighted(const vector<pair<char, int>>& weighted_string) {",
		"        int n = weighted_string.size();",
		"        vector<pair<char, int>> doubled = weighted_string;",
		"        doubled.insert(doubled.end(), weighted_string.begin(), weighted_string.end());",
		"",
		"        int i = 0, j = 1, k = 0;",
		"",
		"        while (i < n && j < n) {",
		"            k = 0;",
		"            while (k < n && doubled[i + k] == doubled[j + k]) { k++; }",
		"",
		"            if (k == n) break;",
		"",
		"            auto cmp = [](const pair<char, int>& a, const pair<char, int>& b) {",
		"                if (a.first != b.first) return a.first < b.first;",
		"                return a.second < b.second;",
		"            };",
		"",
		"            if (cmp(doubled[j + k], doubled[i + k])) {",
		"                i = i + k + 1;",
		"                if (i <= j) i = j + 1;",
		"            } else {",
		"                j = j + k + 1;",
		"                if (j <= i) j = i + 1;",
		"            }",
		"        }",
		"",
		"        return min(i, j);",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Automaton\AhoCorasick.h
s("06_string_algorithms_automaton_ahocorasick_h", {
	t({
		"/*",
		" * AC自动机算法",
		" * 时间复杂度: 构建O(∑|模式串|), 匹配O(n+输出数量)",
		" * 空间复杂度: O(∑|模式串|×字符集大小)",
		" * 适用场景: 多模式串匹配、敏感词过滤、文本检索",
		" */",
		"struct AhoCorasick {",
		"    struct Node {",
		"        map<char, int> children;",
		"        int fail;",
		"        vector<int> output;",
		"        int depth;",
		"",
		"        Node() : fail(0), depth(0) {}",
		"    };",
		"",
		"    vector<Node> trie;",
		"    vector<string> patterns;",
		"    int node_count;",
		"",
		"    AhoCorasick() {",
		"        node_count = 0;",
		"        trie.push_back(Node());",
		"    }",
		"",
		"    // 添加模式串",
		"    void add_pattern(const string& pattern, int pattern_id = -1) {",
		"        if (pattern_id == -1) { pattern_id = patterns.size(); }",
		"        patterns.push_back(pattern);",
		"",
		"        int current = 0;",
		"        for (char c : pattern) {",
		"            if (trie[current].children.find(c) == trie[current].children.end()) {",
		"                trie[current].children[c] = ++node_count;",
		"                trie.push_back(Node());",
		"                trie[node_count].depth = trie[current].depth + 1;",
		"            }",
		"            current = trie[current].children[c];",
		"        }",
		"        trie[current].output.push_back(pattern_id);",
		"    }",
		"",
		"    // 构建失配指针",
		"    void build_failure_links() {",
		"        queue<int> q;",
		"",
		"        // 第一层节点的失配指针指向根节点",
		"        for (auto& [c, child] : trie[0].children) {",
		"            trie[child].fail = 0;",
		"            q.push(child);",
		"        }",
		"",
		"        while (!q.empty()) {",
		"            int current = q.front();",
		"            q.pop();",
		"",
		"            for (auto& [c, child] : trie[current].children) {",
		"                q.push(child);",
		"",
		"                // 寻找失配指针",
		"                int fail_node = trie[current].fail;",
		"                while (fail_node != 0 && trie[fail_node].children.find(c) == trie[fail_node].children.end()) {",
		"                    fail_node = trie[fail_node].fail;",
		"                }",
		"",
		"                if (trie[fail_node].children.find(c) != trie[fail_node].children.end() &&",
		"                    trie[fail_node].children[c] != child) {",
		"                    trie[child].fail = trie[fail_node].children[c];",
		"                } else {",
		"                    trie[child].fail = 0;",
		"                }",
		"",
		"                // 合并输出集合",
		"                for (int pattern_id : trie[trie[child].fail].output) { trie[child].output.push_back(pattern_id); }",
		"            }",
		"        }",
		"    }",
		"",
		"    // 在文本中搜索所有模式串",
		"    vector<pair<int, int>> search(const string& text) {",
		"        vector<pair<int, int>> matches;  // (位置, 模式串ID)",
		"        int current = 0;",
		"",
		"        for (int i = 0; i < text.length(); i++) {",
		"            char c = text[i];",
		"",
		"            // 寻找匹配的转移",
		"            while (current != 0 && trie[current].children.find(c) == trie[current].children.end()) {",
		"                current = trie[current].fail;",
		"            }",
		"",
		"            if (trie[current].children.find(c) != trie[current].children.end()) { current = trie[current].children[c]; }",
		"",
		"            // 输出所有匹配的模式串",
		"            for (int pattern_id : trie[current].output) {",
		"                int pattern_len = patterns[pattern_id].length();",
		"                matches.push_back({i - pattern_len + 1, pattern_id});",
		"            }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    // 统计每个模式串的出现次数",
		"    vector<int> count_occurrences(const string& text) {",
		"        vector<int> count(patterns.size(), 0);",
		"        vector<pair<int, int>> matches = search(text);",
		"",
		"        for (auto& [pos, pattern_id] : matches) { count[pattern_id]++; }",
		"",
		"        return count;",
		"    }",
		"",
		"    // 检查文本中是否包含任何模式串",
		"    bool contains_any_pattern(const string& text) {",
		"        int current = 0;",
		"",
		"        for (char c : text) {",
		"            while (current != 0 && trie[current].children.find(c) == trie[current].children.end()) {",
		"                current = trie[current].fail;",
		"            }",
		"",
		"            if (trie[current].children.find(c) != trie[current].children.end()) { current = trie[current].children[c]; }",
		"",
		"            if (!trie[current].output.empty()) { return true; }",
		"        }",
		"",
		"        return false;",
		"    }",
		"",
		"    // 获取第一个匹配的模式串信息",
		"    pair<int, int> find_first_match(const string& text) {",
		"        int current = 0;",
		"",
		"        for (int i = 0; i < text.length(); i++) {",
		"            char c = text[i];",
		"",
		"            while (current != 0 && trie[current].children.find(c) == trie[current].children.end()) {",
		"                current = trie[current].fail;",
		"            }",
		"",
		"            if (trie[current].children.find(c) != trie[current].children.end()) { current = trie[current].children[c]; }",
		"",
		"            if (!trie[current].output.empty()) {",
		"                int pattern_id = trie[current].output[0];",
		"                int pattern_len = patterns[pattern_id].length();",
		"                return {i - pattern_len + 1, pattern_id};",
		"            }",
		"        }",
		"",
		"        return {-1, -1};  // 未找到",
		"    }",
		"",
		"    // 替换文本中的所有模式串",
		"    string replace_all(const string& text, const string& replacement) {",
		"        vector<pair<int, int>> matches = search(text);",
		"        if (matches.empty()) return text;",
		"",
		"        // 按位置排序",
		"        sort(matches.begin(), matches.end());",
		"",
		"        string result;",
		"        int last_end = 0;",
		"",
		"        for (auto& [pos, pattern_id] : matches) {",
		"            int pattern_len = patterns[pattern_id].length();",
		"",
		"            // 跳过重叠的匹配",
		"            if (pos < last_end) continue;",
		"",
		"            // 添加中间的文本",
		"            result += text.substr(last_end, pos - last_end);",
		"            // 添加替换文本",
		"            result += replacement;",
		"",
		"            last_end = pos + pattern_len;",
		"        }",
		"",
		"        // 添加剩余的文本",
		"        result += text.substr(last_end);",
		"",
		"        return result;",
		"    }",
		"",
		"    // 计算模式串集合的总匹配长度",
		"    int total_match_length(const string& text) {",
		"        vector<pair<int, int>> matches = search(text);",
		"        vector<bool> covered(text.length(), false);",
		"",
		"        for (auto& [pos, pattern_id] : matches) {",
		"            int pattern_len = patterns[pattern_id].length();",
		"            for (int i = pos; i < pos + pattern_len; i++) { covered[i] = true; }",
		"        }",
		"",
		"        return count(covered.begin(), covered.end(), true);",
		"    }",
		"",
		"    // 获取Trie树的统计信息",
		"    struct TrieStats {",
		"        int total_nodes;",
		"        int total_patterns;",
		"        int max_depth;",
		"        double avg_depth;",
		"    };",
		"",
		"    TrieStats get_stats() {",
		"        TrieStats stats;",
		"        stats.total_nodes = node_count + 1;",
		"        stats.total_patterns = patterns.size();",
		"        stats.max_depth = 0;",
		"",
		"        int total_depth = 0;",
		"        int pattern_count = 0;",
		"",
		"        for (int i = 0; i <= node_count; i++) {",
		"            if (!trie[i].output.empty()) {",
		"                pattern_count += trie[i].output.size();",
		"                total_depth += trie[i].depth * trie[i].output.size();",
		"                stats.max_depth = max(stats.max_depth, trie[i].depth);",
		"            }",
		"        }",
		"",
		"        stats.avg_depth = pattern_count > 0 ? (double)total_depth / pattern_count : 0;",
		"",
		"        return stats;",
		"    }",
		"",
		"    // 打印Trie树结构（调试用）",
		"    void print_trie() {",
		"        function<void(int, string)> dfs = [&](int node, string prefix) {",
		"            if (!trie[node].output.empty()) {",
		"                cout << prefix << \" -> patterns: \";",
		"                for (int id : trie[node].output) { cout << patterns[id] << \" \"; }",
		"                cout << endl;",
		"            }",
		"",
		"            for (auto& [c, child] : trie[node].children) { dfs(child, prefix + c); }",
		"        };",
		"",
		"        cout << \"Trie structure:\" << endl;",
		"        dfs(0, \"\");",
		"    }",
		"",
		"    // 清空自动机",
		"    void clear() {",
		"        trie.clear();",
		"        patterns.clear();",
		"        node_count = 0;",
		"        trie.push_back(Node());",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"AhoCorasick ac;",
		"",
		"// 添加模式串",
		"ac.add_pattern(\"he\");",
		"ac.add_pattern(\"she\");",
		"ac.add_pattern(\"his\");",
		"ac.add_pattern(\"hers\");",
		"",
		"// 构建AC自动机",
		"ac.build_failure_links();",
		"",
		"// 在文本中搜索",
		"string text = \"ushers\";",
		"vector<pair<int, int>> matches = ac.search(text);",
		"",
		"for (auto& [pos, pattern_id] : matches) {",
		"    cout << \"Found pattern '\" << ac.patterns[pattern_id]",
		"         << \"' at position \" << pos << endl;",
		"}",
		"",
		"// 统计出现次数",
		"vector<int> counts = ac.count_occurrences(text);",
		"for (int i = 0; i < counts.size(); i++) {",
		"    cout << \"Pattern '\" << ac.patterns[i]",
		"         << \"' appears \" << counts[i] << \" times\" << endl;",
		"}",
		"*/",
	})
}),

-- 06_String_Algorithms\Automaton\PalindromicTree.h
s("06_string_algorithms_automaton_palindromictree_h", {
	t({
		"/**",
		" * 回文树（Palindromic Tree / Eertree）",
		" * 功能：构建字符串的回文自动机，可以快速处理回文子串相关问题",
		" * 时间复杂度：构建 O(n)，查询 O(1)",
		" * 空间复杂度：O(n)",
		" * 适用场景：回文子串计数、查找所有本质不同的回文子串、动态添加字符",
		" */",
		"struct PalindromicTree {",
		"    struct Node {",
		"        map<char, int> next;  // 边",
		"        int len;              // 回文串长度",
		"        int fail;             // 失配指针",
		"        int cnt;              // 出现次数",
		"",
		"        Node() : len(0), fail(0), cnt(0) {}",
		"    };",
		"",
		"    string s;",
		"    vector<Node> tree;",
		"    int node_cnt, last;",
		"",
		"    PalindromicTree() { init(); }",
		"",
		"    void init() {",
		"        tree.clear();",
		"        tree.resize(2);",
		"        node_cnt = 1;",
		"        last = 0;",
		"",
		"        // 奇根 len = -1",
		"        tree[0].len = -1;",
		"        tree[0].fail = 0;",
		"",
		"        // 偶根 len = 0",
		"        tree[1].len = 0;",
		"        tree[1].fail = 0;",
		"    }",
		"",
		"    int get_fail(int pos, int x) {",
		"        while (pos - tree[x].len - 1 < 0 || s[pos - tree[x].len - 1] != s[pos]) { x = tree[x].fail; }",
		"        return x;",
		"    }",
		"",
		"    void extend(char c) {",
		"        s.push_back(c);",
		"        int pos = s.length() - 1;",
		"",
		"        int cur = get_fail(pos, last);",
		"",
		"        if (tree[cur].next.find(c) == tree[cur].next.end()) {",
		"            // 新建节点",
		"            int new_node = ++node_cnt;",
		"            tree.resize(node_cnt + 1);",
		"",
		"            tree[new_node].len = tree[cur].len + 2;",
		"",
		"            if (tree[new_node].len == 1) {",
		"                tree[new_node].fail = 1;  // 偶根",
		"            } else {",
		"                int fail_node = get_fail(pos, tree[cur].fail);",
		"                tree[new_node].fail = tree[fail_node].next[c];",
		"            }",
		"",
		"            tree[cur].next[c] = new_node;",
		"        }",
		"",
		"        last = tree[cur].next[c];",
		"        tree[last].cnt++;",
		"    }",
		"",
		"    void build(const string& str) {",
		"        init();",
		"        for (char c : str) { extend(c); }",
		"    }",
		"",
		"    // 计算每个回文串的实际出现次数",
		"    void count() {",
		"        for (int i = node_cnt; i >= 0; i--) { tree[tree[i].fail].cnt += tree[i].cnt; }",
		"    }",
		"",
		"    // 获取所有本质不同的回文子串",
		"    vector<string> get_all_palindromes() {",
		"        vector<string> result;",
		"",
		"        function<void(int, string)> dfs = [&](int node, string current) {",
		"            if (tree[node].len > 0) { result.push_back(current); }",
		"",
		"            for (auto& edge : tree[node].next) {",
		"                char c = edge.first;",
		"                int next_node = edge.second;",
		"                string next_str = c + current + c;",
		"                dfs(next_node, next_str);",
		"            }",
		"        };",
		"",
		"        // 从奇根和偶根开始遍历",
		"        dfs(0, \"\");",
		"        dfs(1, \"\");",
		"",
		"        return result;",
		"    }",
		"",
		"    // 获取回文子串的数量",
		"    int get_palindrome_count() {",
		"        return node_cnt - 1;  // 不包括两个根节点",
		"    }",
		"",
		"    // 获取最长回文子串的长度",
		"    int get_max_length() {",
		"        int max_len = 0;",
		"        for (int i = 2; i <= node_cnt; i++) { max_len = max(max_len, tree[i].len); }",
		"        return max_len;",
		"    }",
		"",
		"    // 检查从位置pos开始的回文串",
		"    vector<int> get_palindromes_at_position(int pos) {",
		"        vector<int> lengths;",
		"",
		"        // 重新构建到指定位置",
		"        string temp_s = s;",
		"        init();",
		"        for (int i = 0; i <= pos; i++) { extend(temp_s[i]); }",
		"",
		"        int cur = last;",
		"        while (cur > 1) {",
		"            lengths.push_back(tree[cur].len);",
		"            cur = tree[cur].fail;",
		"        }",
		"",
		"        return lengths;",
		"    }",
		"",
		"    // 计算回文子串总数",
		"    long long total_palindrome_count() {",
		"        count();",
		"        long long total = 0;",
		"        for (int i = 2; i <= node_cnt; i++) { total += tree[i].cnt; }",
		"        return total;",
		"    }",
		"",
		"    void print_tree() {",
		"        for (int i = 0; i <= node_cnt; i++) {",
		"            cout << \"Node \" << i << \": len=\" << tree[i].len << \" fail=\" << tree[i].fail << \" cnt=\" << tree[i].cnt",
		"                 << \"\\n\";",
		"            for (auto& edge : tree[i].next) { cout << \"  -> \" << edge.first << \" to \" << edge.second << \"\\n\"; }",
		"        }",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Automaton\SuffixAutomaton.h
s("06_string_algorithms_automaton_suffixautomaton_h", {
	t({
		"/*",
		" * 后缀自动机算法",
		" * 时间复杂度: 构建O(n), 查询O(m)",
		" * 空间复杂度: O(n×字符集大小)",
		" * 适用场景: 子串查询、最长公共子串、字典序第k小子串",
		" */",
		"struct SuffixAutomaton {",
		"    struct Node {",
		"        map<char, int> children;",
		"        int link;        // 后缀链接",
		"        int length;      // 最长字符串长度",
		"        int first_pos;   // 第一次出现位置",
		"        int cnt;         // 出现次数",
		"        bool is_cloned;  // 是否为克隆节点",
		"",
		"        Node() : link(-1), length(0), first_pos(-1), cnt(0), is_cloned(false) {}",
		"    };",
		"",
		"    vector<Node> nodes;",
		"    int last;  // 当前状态",
		"    int size;  // 节点数量",
		"",
		"    SuffixAutomaton() {",
		"        nodes.resize(1);",
		"        last = 0;",
		"        size = 1;",
		"        nodes[0].length = 0;",
		"        nodes[0].link = -1;",
		"    }",
		"",
		"    // 扩展字符c",
		"    void extend(char c) {",
		"        int cur = size++;",
		"        nodes.resize(size);",
		"        nodes[cur].length = nodes[last].length + 1;",
		"        nodes[cur].first_pos = nodes[cur].length - 1;",
		"",
		"        int p = last;",
		"        while (p != -1 && nodes[p].children.find(c) == nodes[p].children.end()) {",
		"            nodes[p].children[c] = cur;",
		"            p = nodes[p].link;",
		"        }",
		"",
		"        if (p == -1) {",
		"            nodes[cur].link = 0;",
		"        } else {",
		"            int q = nodes[p].children[c];",
		"            if (nodes[p].length + 1 == nodes[q].length) {",
		"                nodes[cur].link = q;",
		"            } else {",
		"                int clone = size++;",
		"                nodes.resize(size);",
		"                nodes[clone] = nodes[q];",
		"                nodes[clone].length = nodes[p].length + 1;",
		"                nodes[clone].is_cloned = true;",
		"                nodes[clone].first_pos = -1;",
		"",
		"                while (p != -1 && nodes[p].children[c] == q) {",
		"                    nodes[p].children[c] = clone;",
		"                    p = nodes[p].link;",
		"                }",
		"",
		"                nodes[q].link = nodes[cur].link = clone;",
		"            }",
		"        }",
		"",
		"        last = cur;",
		"    }",
		"",
		"    // 构建后缀自动机",
		"    void build(const string& s) {",
		"        for (char c : s) { extend(c); }",
		"    }",
		"",
		"    // 检查子串是否存在",
		"    bool contains(const string& pattern) {",
		"        int curr = 0;",
		"        for (char c : pattern) {",
		"            if (nodes[curr].children.find(c) == nodes[curr].children.end()) { return false; }",
		"            curr = nodes[curr].children[c];",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 计算子串第一次出现位置",
		"    int first_occurrence(const string& pattern) {",
		"        int curr = 0;",
		"        for (char c : pattern) {",
		"            if (nodes[curr].children.find(c) == nodes[curr].children.end()) { return -1; }",
		"            curr = nodes[curr].children[c];",
		"        }",
		"        return nodes[curr].first_pos - pattern.length() + 1;",
		"    }",
		"",
		"    // 计算不同子串数量",
		"    long long count_distinct_substrings() {",
		"        long long result = 0;",
		"        for (int i = 1; i < size; i++) {",
		"            if (!nodes[i].is_cloned) { result += nodes[i].length - (nodes[nodes[i].link].length); }",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 计算每个状态的出现次数",
		"    void calculate_occurrences() {",
		"        vector<int> order(size);",
		"        iota(order.begin(), order.end(), 0);",
		"",
		"        // 按长度排序",
		"        sort(order.begin(), order.end(), [&](int a, int b) { return nodes[a].length > nodes[b].length; });",
		"",
		"        // 初始化终止状态",
		"        for (int i = 0; i < size; i++) {",
		"            if (!nodes[i].is_cloned) { nodes[i].cnt = 1; }",
		"        }",
		"",
		"        // 自底向上计算",
		"        for (int v : order) {",
		"            if (nodes[v].link != -1) { nodes[nodes[v].link].cnt += nodes[v].cnt; }",
		"        }",
		"    }",
		"",
		"    // 获取子串出现次数",
		"    int get_occurrences(const string& pattern) {",
		"        int curr = 0;",
		"        for (char c : pattern) {",
		"            if (nodes[curr].children.find(c) == nodes[curr].children.end()) { return 0; }",
		"            curr = nodes[curr].children[c];",
		"        }",
		"        return nodes[curr].cnt;",
		"    }",
		"",
		"    // 找到第k小的子串",
		"    string kth_substring(long long k) {",
		"        vector<long long> dp(size);",
		"        function<long long(int)> count_paths = [&](int v) -> long long {",
		"            if (dp[v] != 0) return dp[v];",
		"            dp[v] = 1;  // 空字符串",
		"            for (auto& [c, u] : nodes[v].children) { dp[v] += count_paths(u); }",
		"            return dp[v];",
		"        };",
		"",
		"        count_paths(0);",
		"",
		"        if (k > dp[0]) return \"\";  // k太大",
		"",
		"        string result;",
		"        int curr = 0;",
		"        k--;  // 跳过空字符串",
		"",
		"        while (k > 0) {",
		"            for (auto& [c, next] : nodes[curr].children) {",
		"                if (k <= dp[next]) {",
		"                    result += c;",
		"                    curr = next;",
		"                    k--;",
		"                    break;",
		"                } else {",
		"                    k -= dp[next];",
		"                }",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 计算最长公共子串",
		"    int longest_common_substring(const string& s1, const string& s2) {",
		"        // 构建s1的后缀自动机",
		"        clear();",
		"        build(s1);",
		"",
		"        int result = 0;",
		"        int curr = 0;",
		"        int length = 0;",
		"",
		"        for (char c : s2) {",
		"            while (curr != 0 && nodes[curr].children.find(c) == nodes[curr].children.end()) {",
		"                curr = nodes[curr].link;",
		"                length = nodes[curr].length;",
		"            }",
		"",
		"            if (nodes[curr].children.find(c) != nodes[curr].children.end()) {",
		"                curr = nodes[curr].children[c];",
		"                length++;",
		"                result = max(result, length);",
		"            } else {",
		"                curr = 0;",
		"                length = 0;",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 获取所有不同子串",
		"    vector<string> get_all_substrings() {",
		"        vector<string> result;",
		"",
		"        function<void(int, string)> dfs = [&](int v, string current) {",
		"            if (v != 0) result.push_back(current);",
		"",
		"            for (auto& [c, u] : nodes[v].children) { dfs(u, current + c); }",
		"        };",
		"",
		"        dfs(0, \"\");",
		"        return result;",
		"    }",
		"",
		"    // 计算字典序第k小的循环移位",
		"    string kth_cyclic_shift(const string& s, long long k) {",
		"        string doubled = s + s;",
		"        clear();",
		"        build(doubled);",
		"",
		"        int curr = 0;",
		"        string result;",
		"",
		"        for (int i = 0; i < s.length(); i++) {",
		"            vector<char> candidates;",
		"            for (auto& [c, next] : nodes[curr].children) { candidates.push_back(c); }",
		"            sort(candidates.begin(), candidates.end());",
		"",
		"            for (char c : candidates) {",
		"                int next = nodes[curr].children[c];",
		"                // 这里需要更复杂的计算来确定第k小",
		"                // 简化实现",
		"                result += c;",
		"                curr = next;",
		"                break;",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 多字符串的最长公共子串",
		"    int longest_common_substring_multi(const vector<string>& strings) {",
		"        if (strings.empty()) return 0;",
		"",
		"        clear();",
		"        build(strings[0]);",
		"",
		"        vector<vector<int>> dp(strings.size(), vector<int>(size, 0));",
		"",
		"        for (int i = 1; i < strings.size(); i++) {",
		"            int curr = 0;",
		"            int length = 0;",
		"",
		"            for (char c : strings[i]) {",
		"                while (curr != 0 && nodes[curr].children.find(c) == nodes[curr].children.end()) {",
		"                    curr = nodes[curr].link;",
		"                    length = nodes[curr].length;",
		"                }",
		"",
		"                if (nodes[curr].children.find(c) != nodes[curr].children.end()) {",
		"                    curr = nodes[curr].children[c];",
		"                    length++;",
		"                } else {",
		"                    curr = 0;",
		"                    length = 0;",
		"                }",
		"",
		"                dp[i][curr] = max(dp[i][curr], length);",
		"            }",
		"",
		"            // 向上传播",
		"            vector<int> order(size);",
		"            iota(order.begin(), order.end(), 0);",
		"            sort(order.begin(), order.end(), [&](int a, int b) { return nodes[a].length > nodes[b].length; });",
		"",
		"            for (int v : order) {",
		"                if (nodes[v].link != -1) {",
		"                    dp[i][nodes[v].link] = max(dp[i][nodes[v].link], min(dp[i][v], nodes[nodes[v].link].length));",
		"                }",
		"            }",
		"        }",
		"",
		"        int result = 0;",
		"        for (int v = 0; v < size; v++) {",
		"            int min_len = nodes[v].length;",
		"            for (int i = 1; i < strings.size(); i++) { min_len = min(min_len, dp[i][v]); }",
		"            result = max(result, min_len);",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 清空自动机",
		"    void clear() {",
		"        nodes.clear();",
		"        nodes.resize(1);",
		"        last = 0;",
		"        size = 1;",
		"        nodes[0].length = 0;",
		"        nodes[0].link = -1;",
		"    }",
		"",
		"    // 获取状态数",
		"    int get_size() const { return size; }",
		"",
		"    // 调试输出",
		"    void debug_print() {",
		"        cout << \"Suffix Automaton with \" << size << \" states:\" << endl;",
		"        for (int i = 0; i < size; i++) {",
		"            cout << \"State \" << i << \": len=\" << nodes[i].length << \", link=\" << nodes[i].link",
		"                 << \", pos=\" << nodes[i].first_pos << \", cnt=\" << nodes[i].cnt << endl;",
		"            cout << \"  Children: \";",
		"            for (auto& [c, next] : nodes[i].children) { cout << c << \"->\" << next << \" \"; }",
		"            cout << endl;",
		"        }",
		"    }",
		"",
		"    // 构建后缀树（从后缀自动机）",
		"    vector<vector<pair<int, pair<int, int>>>> build_suffix_tree() {",
		"        vector<vector<pair<int, pair<int, int>>>> tree(size);",
		"",
		"        for (int v = 1; v < size; v++) {",
		"            int parent = nodes[v].link;",
		"            int start = nodes[parent].length;",
		"            int end = nodes[v].length - 1;",
		"            tree[parent].push_back({v, {start, end}});",
		"        }",
		"",
		"        return tree;",
		"    }",
		"};",
		"",
		"// 使用示例：",
		"// SuffixAutomaton sam;",
		"// sam.build(\"abcbc\");",
		"// bool exists = sam.contains(\"bc\");",
		"// int distinct = sam.count_distinct_substrings();",
		"// sam.calculate_occurrences();",
		"// int count = sam.get_occurrences(\"bc\");",
	})
}),

-- 06_String_Algorithms\Palindromes\Manacher.h
s("06_string_algorithms_palindromes_manacher_h", {
	t({
		"/*",
		" * Manacher算法 - 回文串处理",
		" * 时间复杂度: O(n)",
		" * 空间复杂度: O(n)",
		" * 功能: 找出字符串中所有回文子串的半径",
		" */",
		"vector<int> manacher(string s) {",
		"    string t = \"#\";",
		"    for (auto c : s) {",
		"        t += c;",
		"        t += \"#\";",
		"    }",
		"    int n = t.size();",
		"    vector<int> r(n);",
		"    for (int i = 0, j = 0; i < n; ++i) {",
		"        if (2 * j - i >= 0 && j + r[j] > i) { r[i] = min(r[2 * j - i], j + r[j] - i); }",
		"        while (i - r[i] >= 0 && i + r[i] < n && t[i - r[i]] == t[i + r[i]]) { r[i] += 1; }",
		"        if (i + r[i] > j + r[j]) { j = i; }",
		"    }",
		"    return r;",
		"}",
		"",
		"// 获取r[i]位置的回文子串",
		"pair<int, string> get(const string &s, const vector<int> &r, int i) {",
		"    int len = r[i] - 1;",
		"    if (len <= 0) return {-1, \"\"};",
		"    int st = (i - len) / 2;",
		"    return {st, s.substr(st, len)};",
		"}",
	})
}),

-- 06_String_Algorithms\Palindromes\PalindromePartition.h
s("06_string_algorithms_palindromes_palindromepartition_h", {
	t({
		"/*",
		" * 回文分割算法",
		" * 时间复杂度: 预处理O(n²), 查询根据具体算法而定",
		" * 空间复杂度: O(n²)",
		" * 适用场景: 回文分割、回文子串计数、动态规划优化",
		" */",
		"struct PalindromePartition {",
		"    string s;",
		"    int n;",
		"    vector<vector<bool>> is_palindrome;",
		"",
		"    PalindromePartition(const string& str) : s(str), n(str.length()) { precompute_palindromes(); }",
		"",
		"   private:",
		"    // 预计算所有子串是否为回文",
		"    void precompute_palindromes() {",
		"        is_palindrome.assign(n, vector<bool>(n, false));",
		"",
		"        // 长度为1的子串都是回文",
		"        for (int i = 0; i < n; i++) { is_palindrome[i][i] = true; }",
		"",
		"        // 长度为2的子串",
		"        for (int i = 0; i < n - 1; i++) {",
		"            if (s[i] == s[i + 1]) { is_palindrome[i][i + 1] = true; }",
		"        }",
		"",
		"        // 长度大于2的子串",
		"        for (int len = 3; len <= n; len++) {",
		"            for (int i = 0; i <= n - len; i++) {",
		"                int j = i + len - 1;",
		"                if (s[i] == s[j] && is_palindrome[i + 1][j - 1]) { is_palindrome[i][j] = true; }",
		"            }",
		"        }",
		"    }",
		"",
		"   public:",
		"    // 检查子串s[i..j]是否为回文",
		"    bool check_palindrome(int i, int j) const { return is_palindrome[i][j]; }",
		"",
		"    // 最小分割次数（DP）",
		"    int min_cuts() const {",
		"        vector<int> dp(n + 1, INT_MAX);",
		"        dp[0] = 0;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 0; j < i; j++) {",
		"                if (is_palindrome[j][i - 1] && dp[j] != INT_MAX) { dp[i] = min(dp[i], dp[j] + 1); }",
		"            }",
		"        }",
		"",
		"        return dp[n] - 1;  // 减1因为分割次数比段数少1",
		"    }",
		"",
		"    // 返回一种最小分割方案",
		"    vector<string> min_cut_partition() const {",
		"        vector<int> dp(n + 1, INT_MAX);",
		"        vector<int> parent(n + 1, -1);",
		"        dp[0] = 0;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 0; j < i; j++) {",
		"                if (is_palindrome[j][i - 1] && dp[j] != INT_MAX) {",
		"                    if (dp[j] + 1 < dp[i]) {",
		"                        dp[i] = dp[j] + 1;",
		"                        parent[i] = j;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        // 重构分割方案",
		"        vector<string> result;",
		"        int pos = n;",
		"        while (pos > 0) {",
		"            int prev = parent[pos];",
		"            result.push_back(s.substr(prev, pos - prev));",
		"            pos = prev;",
		"        }",
		"",
		"        reverse(result.begin(), result.end());",
		"        return result;",
		"    }",
		"",
		"    // 所有可能的回文分割方案",
		"    vector<vector<string>> all_partitions() const {",
		"        vector<vector<string>> result;",
		"        vector<string> current;",
		"        backtrack(0, current, result);",
		"        return result;",
		"    }",
		"",
		"   private:",
		"    void backtrack(int start, vector<string>& current, vector<vector<string>>& result) const {",
		"        if (start == n) {",
		"            result.push_back(current);",
		"            return;",
		"        }",
		"",
		"        for (int end = start; end < n; end++) {",
		"            if (is_palindrome[start][end]) {",
		"                current.push_back(s.substr(start, end - start + 1));",
		"                backtrack(end + 1, current, result);",
		"                current.pop_back();",
		"            }",
		"        }",
		"    }",
		"",
		"   public:",
		"    // 计算分割方案数量",
		"    long long count_partitions() const {",
		"        vector<long long> dp(n + 1, 0);",
		"        dp[0] = 1;",
		"",
		"        for (int i = 1; i <= n; i++) {",
		"            for (int j = 0; j < i; j++) {",
		"                if (is_palindrome[j][i - 1]) { dp[i] += dp[j]; }",
		"            }",
		"        }",
		"",
		"        return dp[n];",
		"    }",
		"",
		"    // 最长回文子序列长度",
		"    int longest_palindromic_subsequence() const {",
		"        vector<vector<int>> dp(n, vector<int>(n, 0));",
		"",
		"        // 长度为1的子序列",
		"        for (int i = 0; i < n; i++) { dp[i][i] = 1; }",
		"",
		"        // 长度为2的子序列",
		"        for (int i = 0; i < n - 1; i++) {",
		"            if (s[i] == s[i + 1]) {",
		"                dp[i][i + 1] = 2;",
		"            } else {",
		"                dp[i][i + 1] = 1;",
		"            }",
		"        }",
		"",
		"        // 长度大于2的子序列",
		"        for (int len = 3; len <= n; len++) {",
		"            for (int i = 0; i <= n - len; i++) {",
		"                int j = i + len - 1;",
		"                if (s[i] == s[j]) {",
		"                    dp[i][j] = dp[i + 1][j - 1] + 2;",
		"                } else {",
		"                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);",
		"                }",
		"            }",
		"        }",
		"",
		"        return dp[0][n - 1];",
		"    }",
		"",
		"    // 最短回文串（在开头添加字符使整个串成为回文）",
		"    string shortest_palindrome() const {",
		"        string rev_s = s;",
		"        reverse(rev_s.begin(), rev_s.end());",
		"        string combined = s + \"#\" + rev_s;",
		"",
		"        // 计算KMP的next数组",
		"        vector<int> next(combined.length(), 0);",
		"        for (int i = 1; i < combined.length(); i++) {",
		"            int j = next[i - 1];",
		"            while (j > 0 && combined[i] != combined[j]) { j = next[j - 1]; }",
		"            if (combined[i] == combined[j]) { j++; }",
		"            next[i] = j;",
		"        }",
		"",
		"        int overlap = next[combined.length() - 1];",
		"        return rev_s.substr(0, n - overlap) + s;",
		"    }",
		"",
		"    // 验证是否可以通过最多k次删除字符得到回文",
		"    bool can_be_palindrome_k_deletions(int k) const {",
		"        int lps = longest_palindromic_subsequence();",
		"        return n - lps <= k;",
		"    }",
		"",
		"    // 通过插入字符使字符串变成回文的最少插入次数",
		"    int min_insertions_for_palindrome() const { return n - longest_palindromic_subsequence(); }",
		"",
		"    // 找到所有回文子串",
		"    vector<pair<int, int>> all_palindromic_substrings() const {",
		"        vector<pair<int, int>> palindromes;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = i; j < n; j++) {",
		"                if (is_palindrome[i][j]) { palindromes.push_back({i, j}); }",
		"            }",
		"        }",
		"",
		"        return palindromes;",
		"    }",
		"",
		"    // 最长回文子串",
		"    pair<int, int> longest_palindromic_substring() const {",
		"        int max_len = 0;",
		"        pair<int, int> result = {0, 0};",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            for (int j = i; j < n; j++) {",
		"                if (is_palindrome[i][j] && j - i + 1 > max_len) {",
		"                    max_len = j - i + 1;",
		"                    result = {i, j};",
		"                }",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Pattern_Matching\BoyerMoore.h
s("06_string_algorithms_pattern_matching_boyermoore_h", {
	t({
		"/*",
		" * Boyer-Moore字符串匹配算法",
		" * 时间复杂度: 预处理O(m+σ), 匹配O(n)平均, O(nm)最坏",
		" * 空间复杂度: O(m+σ)",
		" * 适用场景: 长模式串匹配、文本搜索、字符集较大的匹配",
		" */",
		"struct BoyerMoore {",
		"    string pattern;",
		"    vector<int> bad_char, good_suffix;",
		"",
		"    BoyerMoore(const string& p) : pattern(p) { preprocess(); }",
		"",
		"    void preprocess() {",
		"        int m = pattern.length();",
		"        bad_char.assign(256, -1);",
		"        good_suffix.assign(m, 0);",
		"",
		"        // 预处理坏字符表",
		"        for (int i = 0; i < m; i++) { bad_char[(int)pattern[i]] = i; }",
		"",
		"        // 预处理好后缀表",
		"        vector<int> suffix(m, 0);",
		"        compute_suffix(suffix);",
		"",
		"        // 情况1：模式串的后缀在模式串中的其他位置出现",
		"        for (int i = 0; i < m; i++) { good_suffix[i] = m; }",
		"",
		"        for (int i = m - 1; i >= 0; i--) {",
		"            if (suffix[i] == i + 1) {",
		"                for (int j = 0; j < m - 1 - i; j++) {",
		"                    if (good_suffix[j] == m) { good_suffix[j] = m - 1 - i; }",
		"                }",
		"            }",
		"        }",
		"",
		"        // 情况2：模式串的后缀的一部分匹配模式串的前缀",
		"        for (int i = 0; i <= m - 2; i++) { good_suffix[m - 1 - suffix[i]] = m - 1 - i; }",
		"    }",
		"",
		"    void compute_suffix(vector<int>& suffix) {",
		"        int m = pattern.length();",
		"        suffix[m - 1] = m;",
		"        int g = m - 1, f = 0;",
		"",
		"        for (int i = m - 2; i >= 0; i--) {",
		"            if (i > g && suffix[i + m - 1 - f] < i - g) {",
		"                suffix[i] = suffix[i + m - 1 - f];",
		"            } else {",
		"                if (i < g) g = i;",
		"                f = i;",
		"                while (g >= 0 && pattern[g] == pattern[g + m - 1 - f]) { g--; }",
		"                suffix[i] = f - g;",
		"            }",
		"        }",
		"    }",
		"",
		"    vector<int> search(const string& text) {",
		"        vector<int> matches;",
		"        int n = text.length();",
		"        int m = pattern.length();",
		"",
		"        int s = 0;  // shift of the pattern",
		"        while (s <= n - m) {",
		"            int j = m - 1;",
		"",
		"            // 从右到左比较",
		"            while (j >= 0 && pattern[j] == text[s + j]) { j--; }",
		"",
		"            if (j < 0) {",
		"                matches.push_back(s);",
		"                s += good_suffix[0];",
		"            } else {",
		"                int bad_char_shift = j - bad_char[(int)text[s + j]];",
		"                int good_suffix_shift = good_suffix[j];",
		"                s += max(bad_char_shift, good_suffix_shift);",
		"            }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    int count_matches(const string& text) { return search(text).size(); }",
		"",
		"    bool contains(const string& text) { return !search(text).empty(); }",
		"};",
		"",
		"// Rabin-Karp字符串匹配算法",
		"struct RabinKarp {",
		"    static const int BASE = 257;",
		"    static const int MOD = 1e9 + 7;",
		"",
		"    string pattern;",
		"    long long pattern_hash;",
		"    long long base_pow;",
		"",
		"    RabinKarp(const string& p) : pattern(p) {",
		"        pattern_hash = compute_hash(pattern);",
		"        base_pow = 1;",
		"        for (int i = 0; i < pattern.length() - 1; i++) { base_pow = base_pow * BASE % MOD; }",
		"    }",
		"",
		"    long long compute_hash(const string& s) {",
		"        long long hash_val = 0;",
		"        for (char c : s) { hash_val = (hash_val * BASE + c) % MOD; }",
		"        return hash_val;",
		"    }",
		"",
		"    vector<int> search(const string& text) {",
		"        vector<int> matches;",
		"        int n = text.length();",
		"        int m = pattern.length();",
		"",
		"        if (m > n) return matches;",
		"",
		"        // 计算第一个窗口的哈希值",
		"        long long window_hash = compute_hash(text.substr(0, m));",
		"",
		"        for (int i = 0; i <= n - m; i++) {",
		"            // 检查哈希值是否匹配",
		"            if (window_hash == pattern_hash) {",
		"                // 哈希值匹配，进行字符串比较确认",
		"                if (text.substr(i, m) == pattern) { matches.push_back(i); }",
		"            }",
		"",
		"            // 滚动哈希：移除最左边的字符，添加新字符",
		"            if (i < n - m) {",
		"                window_hash = (window_hash - (text[i] * base_pow % MOD) + MOD) % MOD;",
		"                window_hash = (window_hash * BASE + text[i + m]) % MOD;",
		"            }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    int count_matches(const string& text) { return search(text).size(); }",
		"",
		"    bool contains(const string& text) { return !search(text).empty(); }",
		"};",
		"",
		"// Z算法（Z-function）",
		"struct ZAlgorithm {",
		"    static vector<int> z_function(const string& s) {",
		"        int n = s.length();",
		"        vector<int> z(n);",
		"",
		"        for (int i = 1, l = 0, r = 0; i < n; i++) {",
		"            if (i <= r) { z[i] = min(r - i + 1, z[i - l]); }",
		"            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) { z[i]++; }",
		"            if (i + z[i] - 1 > r) {",
		"                l = i;",
		"                r = i + z[i] - 1;",
		"            }",
		"        }",
		"",
		"        return z;",
		"    }",
		"",
		"    static vector<int> search(const string& pattern, const string& text) {",
		"        string combined = pattern + \"#\" + text;",
		"        vector<int> z = z_function(combined);",
		"        vector<int> matches;",
		"",
		"        int pattern_len = pattern.length();",
		"        for (int i = pattern_len + 1; i < combined.length(); i++) {",
		"            if (z[i] == pattern_len) { matches.push_back(i - pattern_len - 1); }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    static int count_matches(const string& pattern, const string& text) { return search(pattern, text).size(); }",
		"",
		"    static bool contains(const string& pattern, const string& text) { return !search(pattern, text).empty(); }",
		"};",
	})
}),

-- 06_String_Algorithms\Pattern_Matching\KMP.h
s("06_string_algorithms_pattern_matching_kmp_h", {
	t({
		"/*",
		" * KMP字符串匹配算法",
		" * 时间复杂度: 预处理O(m), 匹配O(n+m)",
		" * 空间复杂度: O(m)",
		" * 适用场景: 字符串模式匹配、周期性检测、前缀函数相关问题",
		" */",
		"struct KMP {",
		"    vector<int> failure;",
		"    string pattern;",
		"",
		"    KMP(const string& p) : pattern(p) { build_failure_function(); }",
		"",
		"    // 构建失配函数（前缀函数）",
		"    void build_failure_function() {",
		"        int m = pattern.length();",
		"        failure.assign(m, 0);",
		"",
		"        for (int i = 1; i < m; i++) {",
		"            int j = failure[i - 1];",
		"            while (j > 0 && pattern[i] != pattern[j]) {",
		"                j = failure[j - 1];",
		"            }",
		"            if (pattern[i] == pattern[j]) {",
		"                j++;",
		"            }",
		"            failure[i] = j;",
		"        }",
		"    }",
		"",
		"    // 在文本中查找模式串的所有出现位置",
		"    vector<int> search(const string& text) {",
		"        vector<int> matches;",
		"        int n = text.length(), m = pattern.length();",
		"        if (m == 0) return matches;",
		"",
		"        int j = 0;",
		"        for (int i = 0; i < n; i++) {",
		"            while (j > 0 && text[i] != pattern[j]) {",
		"                j = failure[j - 1];",
		"            }",
		"            if (text[i] == pattern[j]) {",
		"                j++;",
		"            }",
		"            if (j == m) {",
		"                matches.push_back(i - m + 1);",
		"                j = failure[j - 1];",
		"            }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    // 计算字符串的周期",
		"    vector<int> get_periods(const string& s) {",
		"        KMP kmp(s);",
		"        vector<int> periods;",
		"        int n = s.length();",
		"        int len = n;",
		"",
		"        while (len > 0) {",
		"            len = kmp.failure[len - 1];",
		"            if (len > 0 && n % (n - len) == 0) {",
		"                periods.push_back(n - len);",
		"            }",
		"        }",
		"",
		"        reverse(periods.begin(), periods.end());",
		"        return periods;",
		"    }",
		"",
		"    // 计算字符串的border（真前缀且为后缀）",
		"    vector<int> get_borders(const string& s) {",
		"        KMP kmp(s);",
		"        vector<int> borders;",
		"        int n = s.length();",
		"        int len = kmp.failure[n - 1];",
		"",
		"        while (len > 0) {",
		"            borders.push_back(len);",
		"            len = kmp.failure[len - 1];",
		"        }",
		"",
		"        reverse(borders.begin(), borders.end());",
		"        return borders;",
		"    }",
		"",
		"    // 统计模式串在文本中的出现次数",
		"    int count_occurrences(const string& text) { return search(text).size(); }",
		"",
		"    // 检查字符串是否为另一个字符串的子串",
		"    bool is_substring(const string& text) { return !search(text).empty(); }",
		"",
		"    // 计算两个字符串的最长公共前缀长度数组",
		"    static vector<int> lcp_array(const string& s, const string& t) {",
		"        string combined = s + \"#\" + t;",
		"        KMP kmp(combined);",
		"",
		"        vector<int> lcp;",
		"        int n = s.length(), m = t.length();",
		"",
		"        for (int i = 0; i <= m; i++) {",
		"            if (n + 1 + i < combined.length()) {",
		"                int pos = n + 1 + i;",
		"                int len = 0;",
		"                while (len < min(n, m - i) && s[len] == t[i + len]) {",
		"                    len++;",
		"                }",
		"                lcp.push_back(len);",
		"            }",
		"        }",
		"",
		"        return lcp;",
		"    }",
		"",
		"    // 计算字符串自身的Z函数",
		"    static vector<int> z_function(const string& s) {",
		"        int n = s.length();",
		"        vector<int> z(n);",
		"",
		"        for (int i = 1, l = 0, r = 0; i < n; i++) {",
		"            if (i <= r) {",
		"                z[i] = min(r - i + 1, z[i - l]);",
		"            }",
		"            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
		"                z[i]++;",
		"            }",
		"            if (i + z[i] - 1 > r) {",
		"                l = i;",
		"                r = i + z[i] - 1;",
		"            }",
		"        }",
		"",
		"        return z;",
		"    }",
		"",
		"    // 使用KMP求解字符串匹配的变种问题",
		"",
		"    // 求最长相等前后缀长度",
		"    int longest_prefix_suffix() {",
		"        if (pattern.empty()) return 0;",
		"        return failure[pattern.length() - 1];",
		"    }",
		"",
		"    // 计算字符串的最小周期",
		"    int minimum_period() {",
		"        int n = pattern.length();",
		"        int lps = longest_prefix_suffix();",
		"        int period = n - lps;",
		"",
		"        // 如果n能被period整除，则period是最小周期",
		"        if (n % period == 0) {",
		"            return period;",
		"        }",
		"        return n;  // 整个字符串就是一个周期",
		"    }",
		"",
		"    // 检查字符串是否具有周期性",
		"    bool is_periodic() { return minimum_period() < pattern.length(); }",
		"",
		"    // 计算添加最少字符使字符串变成回文",
		"    int min_chars_to_palindrome() {",
		"        string rev = pattern;",
		"        reverse(rev.begin(), rev.end());",
		"",
		"        KMP kmp(rev);",
		"        vector<int> matches = kmp.search(pattern);",
		"",
		"        if (!matches.empty()) {",
		"            int overlap = rev.length() - matches[0];",
		"            return pattern.length() - overlap;",
		"        }",
		"",
		"        return pattern.length();",
		"    }",
		"",
		"    // 在文本串中查找第一个匹配位置",
		"    int find_first(const string& text) {",
		"        vector<int> matches = search(text);",
		"        return matches.empty() ? -1 : matches[0];",
		"    }",
		"",
		"    // 在文本串中查找最后一个匹配位置",
		"    int find_last(const string& text) {",
		"        vector<int> matches = search(text);",
		"        return matches.empty() ? -1 : matches.back();",
		"    }",
		"",
		"    // 模式串预处理信息",
		"    void print_failure_function() {",
		"        cout << \"Pattern: \" << pattern << endl;",
		"        cout << \"Failure function: \";",
		"        for (int x : failure) {",
		"            cout << x << \" \";",
		"        }",
		"        cout << endl;",
		"    }",
		"};",
		"",
		"// 扩展KMP算法",
		"struct ExtendedKMP {",
		"    vector<int> z;",
		"    string s;",
		"",
		"    ExtendedKMP(const string& str) : s(str) { compute_z_array(); }",
		"",
		"    void compute_z_array() {",
		"        int n = s.length();",
		"        z.assign(n, 0);",
		"",
		"        for (int i = 1, l = 0, r = 0; i < n; i++) {",
		"            if (i <= r) {",
		"                z[i] = min(r - i + 1, z[i - l]);",
		"            }",
		"            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
		"                z[i]++;",
		"            }",
		"            if (i + z[i] - 1 > r) {",
		"                l = i;",
		"                r = i + z[i] - 1;",
		"            }",
		"        }",
		"    }",
		"",
		"    // 在文本中查找模式串",
		"    vector<int> search(const string& text, const string& pattern) {",
		"        string combined = pattern + \"#\" + text;",
		"        ExtendedKMP ext_kmp(combined);",
		"",
		"        vector<int> matches;",
		"        int p_len = pattern.length();",
		"",
		"        for (int i = p_len + 1; i < combined.length(); i++) {",
		"            if (ext_kmp.z[i] == p_len) {",
		"                matches.push_back(i - p_len - 1);",
		"            }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"};",
		"",
		"// 使用示例",
		"/*",
		"// 基本KMP使用",
		"KMP kmp(\"ABABCABABA\");",
		"string text = \"ABABABABCABABAABABCABABA\";",
		"vector<int> matches = kmp.search(text);",
		"",
		"for (int pos : matches) {",
		"    cout << \"Found at position: \" << pos << endl;",
		"}",
		"",
		"// 计算字符串周期",
		"vector<int> periods = kmp.get_periods(\"ABCABCABC\");",
		"cout << \"Periods: \";",
		"for (int p : periods) {",
		"    cout << p << \" \";",
		"}",
		"cout << endl;",
		"*/",
	})
}),

-- 06_String_Algorithms\Pattern_Matching\RabinKarp.h
s("06_string_algorithms_pattern_matching_rabinkarp_h", {
	t({
		"/*",
		" * Rabin-Karp字符串匹配算法",
		" * 时间复杂度: 预处理O(m), 匹配O(n+m)平均, O(nm)最坏",
		" * 空间复杂度: O(1)",
		" * 适用场景: 多模式串匹配、滚动哈希匹配、概率性匹配",
		" */",
		"struct RabinKarpAlgorithm {",
		"    static const long long BASE1 = 131;",
		"    static const long long BASE2 = 137;",
		"    static const long long MOD1 = 1e9 + 7;",
		"    static const long long MOD2 = 1e9 + 9;",
		"",
		"    string pattern;",
		"    pair<long long, long long> pattern_hash;",
		"    pair<long long, long long> base_pow;",
		"",
		"    RabinKarpAlgorithm(const string& p) : pattern(p) {",
		"        pattern_hash = compute_double_hash(pattern);",
		"        base_pow = {1, 1};",
		"",
		"        for (int i = 0; i < pattern.length() - 1; i++) {",
		"            base_pow.first = base_pow.first * BASE1 % MOD1;",
		"            base_pow.second = base_pow.second * BASE2 % MOD2;",
		"        }",
		"    }",
		"",
		"    pair<long long, long long> compute_double_hash(const string& s) {",
		"        long long hash1 = 0, hash2 = 0;",
		"",
		"        for (char c : s) {",
		"            hash1 = (hash1 * BASE1 + c) % MOD1;",
		"            hash2 = (hash2 * BASE2 + c) % MOD2;",
		"        }",
		"",
		"        return {hash1, hash2};",
		"    }",
		"",
		"    vector<int> search(const string& text) {",
		"        vector<int> matches;",
		"        int n = text.length();",
		"        int m = pattern.length();",
		"",
		"        if (m > n) return matches;",
		"",
		"        // 计算第一个窗口的双重哈希值",
		"        pair<long long, long long> window_hash = compute_double_hash(text.substr(0, m));",
		"",
		"        for (int i = 0; i <= n - m; i++) {",
		"            // 检查双重哈希值是否匹配",
		"            if (window_hash == pattern_hash) {",
		"                // 哈希值匹配，进行字符串比较确认（避免误报）",
		"                if (text.substr(i, m) == pattern) { matches.push_back(i); }",
		"            }",
		"",
		"            // 滚动哈希：移除最左边的字符，添加新字符",
		"            if (i < n - m) {",
		"                // 第一个哈希函数",
		"                window_hash.first = (window_hash.first - (text[i] * base_pow.first % MOD1) + MOD1) % MOD1;",
		"                window_hash.first = (window_hash.first * BASE1 + text[i + m]) % MOD1;",
		"",
		"                // 第二个哈希函数",
		"                window_hash.second = (window_hash.second - (text[i] * base_pow.second % MOD2) + MOD2) % MOD2;",
		"                window_hash.second = (window_hash.second * BASE2 + text[i + m]) % MOD2;",
		"            }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    bool contains(const string& text) { return !search(text).empty(); }",
		"",
		"    int count_occurrences(const string& text) { return search(text).size(); }",
		"};",
		"",
		"// Z算法的独立实现",
		"struct ZFunction {",
		"    static vector<int> compute_z(const string& s) {",
		"        int n = s.length();",
		"        vector<int> z(n, 0);",
		"",
		"        for (int i = 1, l = 0, r = 0; i < n; i++) {",
		"            if (i <= r) { z[i] = min(r - i + 1, z[i - l]); }",
		"",
		"            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) { z[i]++; }",
		"",
		"            if (i + z[i] - 1 > r) {",
		"                l = i;",
		"                r = i + z[i] - 1;",
		"            }",
		"        }",
		"",
		"        return z;",
		"    }",
		"",
		"    static vector<int> pattern_match(const string& pattern, const string& text) {",
		"        string combined = pattern + \"$\" + text;",
		"        vector<int> z = compute_z(combined);",
		"        vector<int> matches;",
		"",
		"        int pattern_len = pattern.length();",
		"        for (int i = pattern_len + 1; i < combined.length(); i++) {",
		"            if (z[i] == pattern_len) { matches.push_back(i - pattern_len - 1); }",
		"        }",
		"",
		"        return matches;",
		"    }",
		"",
		"    // 计算字符串的周期",
		"    static vector<int> compute_periods(const string& s) {",
		"        vector<int> z = compute_z(s);",
		"        vector<int> periods;",
		"        int n = s.length();",
		"",
		"        for (int i = 1; i < n; i++) {",
		"            if (i + z[i] == n) { periods.push_back(i); }",
		"        }",
		"",
		"        return periods;",
		"    }",
		"",
		"    // 查找最小周期",
		"    static int minimal_period(const string& s) {",
		"        vector<int> periods = compute_periods(s);",
		"        return periods.empty() ? s.length() : periods[0];",
		"    }",
		"",
		"    // 判断字符串是否是周期性的",
		"    static bool is_periodic(const string& s) { return minimal_period(s) < s.length(); }",
		"",
		"    // 计算最长公共前缀数组",
		"    static vector<int> longest_common_prefix(const string& s, const vector<string>& strings) {",
		"        vector<int> lcp;",
		"",
		"        for (const string& t : strings) {",
		"            string combined = s + \"$\" + t;",
		"            vector<int> z = compute_z(combined);",
		"            int max_lcp = 0;",
		"",
		"            for (int i = s.length() + 1; i < combined.length(); i++) { max_lcp = max(max_lcp, z[i]); }",
		"",
		"            lcp.push_back(max_lcp);",
		"        }",
		"",
		"        return lcp;",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Pattern_Matching\Z_Algorithm.h
s("06_string_algorithms_pattern_matching_z_algorithm_h", {
	t({
		"/*",
		" * Z算法 - 线性时间字符串匹配",
		" * 时间复杂度: O(n)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 前缀匹配、字符串匹配、周期性检测",
		" */",
		"struct ZAlgorithm {",
		"    vector<int> z;",
		"    string s;",
		"",
		"    ZAlgorithm(const string& str) : s(str) {",
		"        int n = s.length();",
		"        z.resize(n);",
		"        compute_z();",
		"    }",
		"",
		"    // 计算Z数组",
		"    void compute_z() {",
		"        int n = s.length();",
		"        if (n == 0) return;",
		"",
		"        z[0] = n;",
		"        int l = 0, r = 0;",
		"",
		"        for (int i = 1; i < n; i++) {",
		"            if (i <= r) { z[i] = min(r - i + 1, z[i - l]); }",
		"",
		"            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) { z[i]++; }",
		"",
		"            if (i + z[i] - 1 > r) {",
		"                l = i;",
		"                r = i + z[i] - 1;",
		"            }",
		"        }",
		"    }",
		"",
		"    // 在文本中查找模式串的所有出现位置",
		"    vector<int> find_occurrences(const string& pattern, const string& text) {",
		"        string combined = pattern + \"$\" + text;",
		"        ZAlgorithm za(combined);",
		"",
		"        vector<int> occurrences;",
		"        int p_len = pattern.length();",
		"",
		"        for (int i = p_len + 1; i < combined.length(); i++) {",
		"            if (za.z[i] == p_len) { occurrences.push_back(i - p_len - 1); }",
		"        }",
		"",
		"        return occurrences;",
		"    }",
		"",
		"    // 获取Z数组",
		"    vector<int> get_z_array() const { return z; }",
		"",
		"    // 计算字符串的最长公共前缀后缀长度",
		"    int longest_prefix_suffix() {",
		"        int n = s.length();",
		"        for (int i = 1; i < n; i++) {",
		"            if (z[i] == n - i) { return z[i]; }",
		"        }",
		"        return 0;",
		"    }",
		"",
		"    // 检查字符串是否为周期字符串",
		"    bool is_periodic() {",
		"        int n = s.length();",
		"        for (int period = 1; period <= n / 2; period++) {",
		"            if (n % period == 0) {",
		"                bool valid = true;",
		"                for (int i = period; i < n && valid; i++) {",
		"                    if (z[i] < n - i) { valid = false; }",
		"                }",
		"                if (valid) return true;",
		"            }",
		"        }",
		"        return false;",
		"    }",
		"",
		"    // 获取最小周期长度",
		"    int minimum_period() {",
		"        int n = s.length();",
		"        for (int period = 1; period <= n; period++) {",
		"            if (n % period == 0) {",
		"                bool valid = true;",
		"                for (int i = period; i < n && valid; i++) {",
		"                    if (z[i] < n - i) { valid = false; }",
		"                }",
		"                if (valid) return period;",
		"            }",
		"        }",
		"        return n;",
		"    }",
		"};",
		"",
		"// 扩展Z算法 - 处理两个不同字符串",
		"struct ExtendedZ {",
		"    // 计算字符串s关于字符串t的扩展Z数组",
		"    static vector<int> extended_z(const string& s, const string& t) {",
		"        int n = s.length(), m = t.length();",
		"        vector<int> z(n);",
		"",
		"        if (n == 0) return z;",
		"",
		"        // 首先计算z[0]",
		"        int k = 0;",
		"        while (k < n && k < m && s[k] == t[k]) k++;",
		"        z[0] = k;",
		"",
		"        int l = 0, r = 0;",
		"        if (z[0] > 0) {",
		"            l = 0;",
		"            r = z[0] - 1;",
		"        }",
		"",
		"        for (int i = 1; i < n; i++) {",
		"            if (i > r) {",
		"                // 从头开始匹配",
		"                k = 0;",
		"                while (i + k < n && k < m && s[i + k] == t[k]) k++;",
		"                z[i] = k;",
		"                if (k > 0) {",
		"                    l = i;",
		"                    r = i + k - 1;",
		"                }",
		"            } else {",
		"                // 利用已知信息",
		"                int beta = r - i + 1;",
		"                if (z[i - l] < beta) {",
		"                    z[i] = z[i - l];",
		"                } else {",
		"                    k = beta;",
		"                    while (i + k < n && k < m && s[i + k] == t[k]) k++;",
		"                    z[i] = k;",
		"                    l = i;",
		"                    r = i + k - 1;",
		"                }",
		"            }",
		"        }",
		"",
		"        return z;",
		"    }",
		"",
		"    // 查找字符串t在字符串s中的所有出现位置",
		"    static vector<int> find_all(const string& s, const string& t) {",
		"        vector<int> z = extended_z(s, t);",
		"        vector<int> positions;",
		"",
		"        for (int i = 0; i < s.length(); i++) {",
		"            if (z[i] == t.length()) { positions.push_back(i); }",
		"        }",
		"",
		"        return positions;",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Rolling_Hash\DoubleHash.h
s("06_string_algorithms_rolling_hash_doublehash_h", {
	t({
		"/*",
		" * 双哈希滚动哈希",
		" * 时间复杂度: 预处理O(n), 查询O(1)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 字符串哈希、降低冲突概率、高精度字符串比较",
		" */",
		"struct DoubleHash {",
		"    static const int MOD1 = 1e9 + 7;",
		"    static const int MOD2 = 1e9 + 9;",
		"    static const int BASE1 = 31;",
		"    static const int BASE2 = 37;",
		"",
		"    vector<long long> hash1, hash2, power1, power2;",
		"    string s;",
		"    int n;",
		"",
		"    DoubleHash(const string& str) : s(str), n(str.length()) {",
		"        hash1.resize(n + 1);",
		"        hash2.resize(n + 1);",
		"        power1.resize(n + 1);",
		"        power2.resize(n + 1);",
		"        build();",
		"    }",
		"",
		"   private:",
		"    void build() {",
		"        power1[0] = power2[0] = 1;",
		"        hash1[0] = hash2[0] = 0;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            int char_val = s[i] - 'a' + 1;",
		"",
		"            power1[i + 1] = (power1[i] * BASE1) % MOD1;",
		"            power2[i + 1] = (power2[i] * BASE2) % MOD2;",
		"",
		"            hash1[i + 1] = (hash1[i] * BASE1 + char_val) % MOD1;",
		"            hash2[i + 1] = (hash2[i] * BASE2 + char_val) % MOD2;",
		"        }",
		"    }",
		"",
		"   public:",
		"    // 获取子串s[l..r]的双哈希值",
		"    pair<long long, long long> get_hash(int l, int r) const {",
		"        long long h1 = (hash1[r + 1] - (hash1[l] * power1[r - l + 1]) % MOD1 + MOD1) % MOD1;",
		"        long long h2 = (hash2[r + 1] - (hash2[l] * power2[r - l + 1]) % MOD2 + MOD2) % MOD2;",
		"        return {h1, h2};",
		"    }",
		"",
		"    // 比较两个子串是否相等",
		"    bool equal(int l1, int r1, int l2, int r2) const { return get_hash(l1, r1) == get_hash(l2, r2); }",
		"",
		"    // 计算字符串的双哈希值（静态方法）",
		"    static pair<long long, long long> compute_hash(const string& str) {",
		"        long long h1 = 0, h2 = 0;",
		"        long long pow1 = 1, pow2 = 1;",
		"",
		"        for (char c : str) {",
		"            int char_val = c - 'a' + 1;",
		"            h1 = (h1 + char_val * pow1) % MOD1;",
		"            h2 = (h2 + char_val * pow2) % MOD2;",
		"            pow1 = (pow1 * BASE1) % MOD1;",
		"            pow2 = (pow2 * BASE2) % MOD2;",
		"        }",
		"",
		"        return {h1, h2};",
		"    }",
		"",
		"    // 在文本中查找模式串",
		"    vector<int> find_pattern(const string& pattern) const {",
		"        vector<int> positions;",
		"        if (pattern.length() > n) return positions;",
		"",
		"        auto pattern_hash = compute_hash(pattern);",
		"        int len = pattern.length();",
		"",
		"        for (int i = 0; i <= n - len; i++) {",
		"            if (get_hash(i, i + len - 1) == pattern_hash) { positions.push_back(i); }",
		"        }",
		"",
		"        return positions;",
		"    }",
		"",
		"    // 最长公共前缀",
		"    int lcp(int i, int j) const {",
		"        int left = 0, right = min(n - i, n - j);",
		"        int result = 0;",
		"",
		"        while (left <= right) {",
		"            int mid = (left + right) / 2;",
		"            if (equal(i, i + mid - 1, j, j + mid - 1)) {",
		"                result = mid;",
		"                left = mid + 1;",
		"            } else {",
		"                right = mid - 1;",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 计算所有长度为k的不同子串数量",
		"    int count_distinct_substrings(int k) const {",
		"        if (k > n) return 0;",
		"",
		"        set<pair<long long, long long>> unique_hashes;",
		"",
		"        for (int i = 0; i <= n - k; i++) { unique_hashes.insert(get_hash(i, i + k - 1)); }",
		"",
		"        return unique_hashes.size();",
		"    }",
		"",
		"    // 找到最长重复子串",
		"    pair<int, int> longest_repeated_substring() const {",
		"        int left = 1, right = n;",
		"        int max_len = 0;",
		"        int position = -1;",
		"",
		"        while (left <= right) {",
		"            int mid = (left + right) / 2;",
		"",
		"            map<pair<long long, long long>, int> hash_pos;",
		"            bool found = false;",
		"",
		"            for (int i = 0; i <= n - mid; i++) {",
		"                auto h = get_hash(i, i + mid - 1);",
		"                if (hash_pos.count(h)) {",
		"                    max_len = mid;",
		"                    position = hash_pos[h];",
		"                    found = true;",
		"                    break;",
		"                } else {",
		"                    hash_pos[h] = i;",
		"                }",
		"            }",
		"",
		"            if (found) {",
		"                left = mid + 1;",
		"            } else {",
		"                right = mid - 1;",
		"            }",
		"        }",
		"",
		"        return {max_len, position};",
		"    }",
		"",
		"    // 查找所有长度为k的重复子串",
		"    vector<pair<int, vector<int>>> find_repeated_substrings(int k) const {",
		"        if (k > n) return {};",
		"",
		"        map<pair<long long, long long>, vector<int>> hash_positions;",
		"",
		"        for (int i = 0; i <= n - k; i++) {",
		"            auto h = get_hash(i, i + k - 1);",
		"            hash_positions[h].push_back(i);",
		"        }",
		"",
		"        vector<pair<int, vector<int>>> result;",
		"        for (const auto& [hash_val, positions] : hash_positions) {",
		"            if (positions.size() > 1) { result.push_back({k, positions}); }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 检查字符串是否有长度为k的重复子串",
		"    bool has_repeated_substring(int k) const {",
		"        if (k > n) return false;",
		"",
		"        set<pair<long long, long long>> seen_hashes;",
		"",
		"        for (int i = 0; i <= n - k; i++) {",
		"            auto h = get_hash(i, i + k - 1);",
		"            if (seen_hashes.count(h)) { return true; }",
		"            seen_hashes.insert(h);",
		"        }",
		"",
		"        return false;",
		"    }",
		"",
		"    // 计算两个字符串的最长公共子串",
		"    static pair<int, int> longest_common_substring(const string& s1, const string& s2) {",
		"        DoubleHash h1(s1), h2(s2);",
		"        int n1 = s1.length(), n2 = s2.length();",
		"",
		"        int left = 0, right = min(n1, n2);",
		"        int max_len = 0;",
		"        int pos1 = -1, pos2 = -1;",
		"",
		"        while (left <= right) {",
		"            int mid = (left + right) / 2;",
		"",
		"            set<pair<long long, long long>> hashes1;",
		"            for (int i = 0; i <= n1 - mid; i++) { hashes1.insert(h1.get_hash(i, i + mid - 1)); }",
		"",
		"            bool found = false;",
		"            for (int i = 0; i <= n2 - mid; i++) {",
		"                auto h = h2.get_hash(i, i + mid - 1);",
		"                if (hashes1.count(h)) {",
		"                    max_len = mid;",
		"                    pos2 = i;",
		"                    // 找到s1中对应的位置",
		"                    for (int j = 0; j <= n1 - mid; j++) {",
		"                        if (h1.get_hash(j, j + mid - 1) == h) {",
		"                            pos1 = j;",
		"                            break;",
		"                        }",
		"                    }",
		"                    found = true;",
		"                    break;",
		"                }",
		"            }",
		"",
		"            if (found) {",
		"                left = mid + 1;",
		"            } else {",
		"                right = mid - 1;",
		"            }",
		"        }",
		"",
		"        return {max_len, pos1};  // 返回长度和在s1中的位置",
		"    }",
		"",
		"    // 字符串匹配的KMP风格算法",
		"    vector<int> string_matching_optimized(const string& pattern) const {",
		"        vector<int> result;",
		"        if (pattern.length() > n) return result;",
		"",
		"        DoubleHash pattern_hash(pattern);",
		"        auto target_hash = pattern_hash.get_hash(0, pattern.length() - 1);",
		"",
		"        for (int i = 0; i <= n - (int)pattern.length(); i++) {",
		"            if (get_hash(i, i + pattern.length() - 1) == target_hash) { result.push_back(i); }",
		"        }",
		"",
		"        return result;",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Rolling_Hash\SingleHash.h
s("06_string_algorithms_rolling_hash_singlehash_h", {
	t({
		"/*",
		" * 单哈希滚动哈希",
		" * 时间复杂度: 预处理O(n), 查询O(1)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 字符串哈希、子串比较、快速字符串匹配",
		" */",
		"struct SingleHash {",
		"    static const int MOD = 1e9 + 7;",
		"    static const int BASE = 31;",
		"",
		"    vector<long long> hash, power;",
		"    string s;",
		"    int n;",
		"",
		"    SingleHash(const string& str) : s(str), n(str.length()) {",
		"        hash.resize(n + 1);",
		"        power.resize(n + 1);",
		"        build();",
		"    }",
		"",
		"   private:",
		"    void build() {",
		"        power[0] = 1;",
		"        hash[0] = 0;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            power[i + 1] = (power[i] * BASE) % MOD;",
		"            hash[i + 1] = (hash[i] * BASE + (s[i] - 'a' + 1)) % MOD;",
		"        }",
		"    }",
		"",
		"   public:",
		"    // 获取子串s[l..r]的哈希值",
		"    long long get_hash(int l, int r) const {",
		"        long long result = (hash[r + 1] - (hash[l] * power[r - l + 1]) % MOD + MOD) % MOD;",
		"        return result;",
		"    }",
		"",
		"    // 比较两个子串是否相等",
		"    bool equal(int l1, int r1, int l2, int r2) const { return get_hash(l1, r1) == get_hash(l2, r2); }",
		"",
		"    // 计算字符串哈希值（静态方法）",
		"    static long long compute_hash(const string& str) {",
		"        long long result = 0;",
		"        long long pow = 1;",
		"",
		"        for (char c : str) {",
		"            result = (result + (c - 'a' + 1) * pow) % MOD;",
		"            pow = (pow * BASE) % MOD;",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 在文本中查找模式串",
		"    vector<int> find_pattern(const string& pattern) const {",
		"        vector<int> positions;",
		"        if (pattern.length() > n) return positions;",
		"",
		"        long long pattern_hash = compute_hash(pattern);",
		"        int len = pattern.length();",
		"",
		"        for (int i = 0; i <= n - len; i++) {",
		"            if (get_hash(i, i + len - 1) == pattern_hash) {",
		"                // 双重检查避免哈希冲突",
		"                bool match = true;",
		"                for (int j = 0; j < len; j++) {",
		"                    if (s[i + j] != pattern[j]) {",
		"                        match = false;",
		"                        break;",
		"                    }",
		"                }",
		"                if (match) { positions.push_back(i); }",
		"            }",
		"        }",
		"",
		"        return positions;",
		"    }",
		"",
		"    // 最长公共前缀",
		"    int lcp(int i, int j) const {",
		"        int left = 0, right = min(n - i, n - j);",
		"        int result = 0;",
		"",
		"        while (left <= right) {",
		"            int mid = (left + right) / 2;",
		"            if (equal(i, i + mid - 1, j, j + mid - 1)) {",
		"                result = mid;",
		"                left = mid + 1;",
		"            } else {",
		"                right = mid - 1;",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 计算所有长度为k的子串的哈希值",
		"    vector<long long> get_all_substrings_hash(int k) const {",
		"        vector<long long> hashes;",
		"        if (k > n) return hashes;",
		"",
		"        for (int i = 0; i <= n - k; i++) { hashes.push_back(get_hash(i, i + k - 1)); }",
		"",
		"        return hashes;",
		"    }",
		"",
		"    // 找到最长重复子串",
		"    pair<int, int> longest_repeated_substring() const {",
		"        int left = 1, right = n;",
		"        int max_len = 0;",
		"        int position = -1;",
		"",
		"        while (left <= right) {",
		"            int mid = (left + right) / 2;",
		"",
		"            unordered_map<long long, int> hash_pos;",
		"            bool found = false;",
		"",
		"            for (int i = 0; i <= n - mid; i++) {",
		"                long long h = get_hash(i, i + mid - 1);",
		"                if (hash_pos.count(h)) {",
		"                    max_len = mid;",
		"                    position = hash_pos[h];",
		"                    found = true;",
		"                    break;",
		"                } else {",
		"                    hash_pos[h] = i;",
		"                }",
		"            }",
		"",
		"            if (found) {",
		"                left = mid + 1;",
		"            } else {",
		"                right = mid - 1;",
		"            }",
		"        }",
		"",
		"        return {max_len, position};",
		"    }",
		"",
		"    // 计算字符串的周期",
		"    vector<int> find_periods() const {",
		"        vector<int> periods;",
		"",
		"        for (int period = 1; period <= n / 2; period++) {",
		"            bool is_period = true;",
		"",
		"            for (int i = 0; i + period < n; i++) {",
		"                if (!equal(i, i, i + period, i + period)) {",
		"                    is_period = false;",
		"                    break;",
		"                }",
		"            }",
		"",
		"            if (is_period) { periods.push_back(period); }",
		"        }",
		"",
		"        return periods;",
		"    }",
		"};",
		"",
		"// 增量哈希 - 支持动态修改",
		"struct IncrementalHash {",
		"    static const int MOD = 1e9 + 7;",
		"    static const int BASE = 31;",
		"",
		"    vector<long long> hash, power;",
		"    string s;",
		"    int n;",
		"",
		"    IncrementalHash(const string& str) : s(str), n(str.length()) {",
		"        hash.resize(n + 1);",
		"        power.resize(n + 1);",
		"        build();",
		"    }",
		"",
		"   private:",
		"    void build() {",
		"        power[0] = 1;",
		"        hash[0] = 0;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            power[i + 1] = (power[i] * BASE) % MOD;",
		"            hash[i + 1] = (hash[i] * BASE + (s[i] - 'a' + 1)) % MOD;",
		"        }",
		"    }",
		"",
		"    long long mod_pow(long long base, long long exp, long long mod) const {",
		"        long long result = 1;",
		"        while (exp > 0) {",
		"            if (exp % 2 == 1) { result = (result * base) % mod; }",
		"            base = (base * base) % mod;",
		"            exp /= 2;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    long long mod_inverse(long long a) const { return mod_pow(a, MOD - 2, MOD); }",
		"",
		"   public:",
		"    // 修改位置i的字符",
		"    void update(int i, char new_char) {",
		"        long long old_contrib = ((s[i] - 'a' + 1) * power[n - i - 1]) % MOD;",
		"        long long new_contrib = ((new_char - 'a' + 1) * power[n - i - 1]) % MOD;",
		"",
		"        for (int j = i + 1; j <= n; j++) { hash[j] = (hash[j] - old_contrib + new_contrib + MOD) % MOD; }",
		"",
		"        s[i] = new_char;",
		"    }",
		"",
		"    // 获取子串哈希值",
		"    long long get_hash(int l, int r) const {",
		"        long long result = (hash[r + 1] - (hash[l] * power[r - l + 1]) % MOD + MOD) % MOD;",
		"        return result;",
		"    }",
		"",
		"    // 插入字符（在位置i之前插入）",
		"    void insert(int i, char c) {",
		"        s.insert(i, 1, c);",
		"        n++;",
		"",
		"        // 重新构建（简化实现）",
		"        hash.resize(n + 1);",
		"        power.resize(n + 1);",
		"        build();",
		"    }",
		"",
		"    // 删除位置i的字符",
		"    void erase(int i) {",
		"        s.erase(i, 1);",
		"        n--;",
		"",
		"        // 重新构建（简化实现）",
		"        hash.resize(n + 1);",
		"        power.resize(n + 1);",
		"        build();",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Suffix_Structures\LCP.h
s("06_string_algorithms_suffix_structures_lcp_h", {
	t({
		"/**",
		" * LCP数组和相关算法",
		" * 功能：基于后缀数组构建LCP数组，支持快速LCP查询和各种字符串分析",
		" * 时间复杂度：构建 O(n)，RMQ查询 O(log n)",
		" * 空间复杂度：O(n log n)",
		" * 适用场景：最长公共前缀查询、字符串分析、后缀树模拟",
		" */",
		"struct LCPArray {",
		"    vector<int> lcp;",
		"    vector<int> sa, rk;",
		"    string s;",
		"    int n;",
		"",
		"    LCPArray(const vector<int>& suffix_array, const string& str) : sa(suffix_array), s(str), n(str.length()) {",
		"        build_rank();",
		"        build_lcp();",
		"    }",
		"",
		"   private:",
		"    void build_rank() {",
		"        rk.resize(n);",
		"        for (int i = 0; i < n; i++) { rk[sa[i]] = i; }",
		"    }",
		"",
		"    void build_lcp() {",
		"        lcp.resize(n);",
		"        int k = 0;",
		"        for (int i = 0; i < n; i++) {",
		"            if (rk[i] == 0) {",
		"                lcp[0] = 0;",
		"                k = 0;",
		"                continue;",
		"            }",
		"            if (k > 0) k--;",
		"            int j = sa[rk[i] - 1];",
		"            while (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;",
		"            lcp[rk[i]] = k;",
		"        }",
		"    }",
		"",
		"   public:",
		"    // 获取LCP数组",
		"    vector<int> get_lcp() const { return lcp; }",
		"",
		"    // 计算两个后缀的LCP (朴素方法)",
		"    int suffix_lcp(int i, int j) const {",
		"        if (i == j) return n - i;",
		"        int ri = rk[i], rj = rk[j];",
		"        if (ri > rj) swap(ri, rj);",
		"        int res = lcp[ri + 1];",
		"        for (int k = ri + 2; k <= rj; k++) { res = min(res, lcp[k]); }",
		"        return res;",
		"    }",
		"",
		"    // 使用单调栈计算LCP的应用",
		"    // 计算以每个位置为右端点的最长公共前缀区间",
		"    vector<pair<int, int>> longest_common_prefix_intervals() const {",
		"        vector<pair<int, int>> intervals(n);",
		"        stack<pair<int, int>> st;  // {lcp_value, start_index}",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            int start = i;",
		"            while (!st.empty() && st.top().first > lcp[i]) {",
		"                auto [val, idx] = st.top();",
		"                st.pop();",
		"                intervals[i - 1] = {val, idx};",
		"                start = idx;",
		"            }",
		"            if (st.empty() || st.top().first < lcp[i]) { st.push({lcp[i], start}); }",
		"        }",
		"",
		"        while (!st.empty()) {",
		"            auto [val, idx] = st.top();",
		"            st.pop();",
		"            intervals[n - 1] = {val, idx};",
		"        }",
		"",
		"        return intervals;",
		"    }",
		"",
		"    // 计算重复子串",
		"    vector<tuple<int, int, int>> find_repeated_substrings(int min_length = 1) const {",
		"        vector<tuple<int, int, int>> result;  // {length, start, count}",
		"",
		"        for (int i = 1; i < n; i++) {",
		"            if (lcp[i] >= min_length) {",
		"                // 找到相同前缀的区间",
		"                int j = i;",
		"                while (j < n && lcp[j] >= lcp[i]) j++;",
		"",
		"                int count = j - i + 1;",
		"                result.push_back({lcp[i], sa[i], count});",
		"",
		"                i = j - 1;  // 跳过已处理的部分",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 计算最长重复子串",
		"    pair<int, int> longest_repeated_substring() const {",
		"        int max_len = 0, pos = -1;",
		"        for (int i = 1; i < n; i++) {",
		"            if (lcp[i] > max_len) {",
		"                max_len = lcp[i];",
		"                pos = sa[i];",
		"            }",
		"        }",
		"        return {max_len, pos};",
		"    }",
		"",
		"    // 计算出现次数至少为k的最长重复子串",
		"    pair<int, int> longest_repeated_substring_k_times(int k) const {",
		"        int max_len = 0, pos = -1;",
		"",
		"        for (int len = 1; len <= n; len++) {",
		"            vector<int> groups;",
		"            int count = 1;",
		"",
		"            for (int i = 1; i < n; i++) {",
		"                if (lcp[i] >= len) {",
		"                    count++;",
		"                } else {",
		"                    if (count >= k) { groups.push_back(len); }",
		"                    count = 1;",
		"                }",
		"            }",
		"            if (count >= k) { groups.push_back(len); }",
		"",
		"            if (!groups.empty() && len > max_len) {",
		"                max_len = len;",
		"                // 找到第一个长度为len的重复子串位置",
		"                count = 1;",
		"                for (int i = 1; i < n; i++) {",
		"                    if (lcp[i] >= len) {",
		"                        count++;",
		"                        if (count == k) {",
		"                            pos = sa[i - count + 1];",
		"                            break;",
		"                        }",
		"                    } else {",
		"                        count = 1;",
		"                    }",
		"                }",
		"            }",
		"        }",
		"",
		"        return {max_len, pos};",
		"    }",
		"",
		"    // 计算不重叠的最长重复子串",
		"    pair<int, vector<int>> non_overlapping_repeated_substring() const {",
		"        int max_len = 0;",
		"        vector<int> positions;",
		"",
		"        for (int len = n / 2; len >= 1; len--) {",
		"            vector<int> candidates;",
		"",
		"            for (int i = 1; i < n; i++) {",
		"                if (lcp[i] >= len) {",
		"                    candidates.push_back(sa[i - 1]);",
		"                    candidates.push_back(sa[i]);",
		"                }",
		"            }",
		"",
		"            if (candidates.empty()) continue;",
		"",
		"            sort(candidates.begin(), candidates.end());",
		"            candidates.erase(unique(candidates.begin(), candidates.end()), candidates.end());",
		"",
		"            // 贪心选择不重叠的子串",
		"            vector<int> selected;",
		"            int last_end = -1;",
		"",
		"            for (int pos : candidates) {",
		"                if (pos >= last_end) {",
		"                    selected.push_back(pos);",
		"                    last_end = pos + len;",
		"                }",
		"            }",
		"",
		"            if (selected.size() >= 2) {",
		"                max_len = len;",
		"                positions = selected;",
		"                break;",
		"            }",
		"        }",
		"",
		"        return {max_len, positions};",
		"    }",
		"",
		"    // 计算所有回文子串（结合Manacher算法思想）",
		"    vector<pair<int, int>> palindromic_substrings() const {",
		"        vector<pair<int, int>> palindromes;",
		"",
		"        // 这里需要构造一个新的字符串来检测回文",
		"        string rev_s = s;",
		"        reverse(rev_s.begin(), rev_s.end());",
		"",
		"        // 使用后缀数组的思想来找回文",
		"        // 实际应用中建议结合其他算法如Manacher",
		"",
		"        return palindromes;",
		"    }",
		"};",
		"",
		"// 稀疏表优化的LCP查询",
		"struct SparseLCP {",
		"    vector<vector<int>> st;",
		"    vector<int> lg;",
		"    int n;",
		"",
		"    SparseLCP(const vector<int>& lcp) {",
		"        n = lcp.size();",
		"        lg.resize(n + 1);",
		"        for (int i = 2; i <= n; i++) { lg[i] = lg[i / 2] + 1; }",
		"",
		"        st.assign(lg[n] + 1, vector<int>(n));",
		"        copy(lcp.begin(), lcp.end(), st[0].begin());",
		"",
		"        for (int i = 1; i <= lg[n]; i++) {",
		"            for (int j = 0; j + (1 << i) <= n; j++) { st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]); }",
		"        }",
		"    }",
		"",
		"    // O(1) 查询区间最小值",
		"    int query(int l, int r) const {",
		"        if (l > r) return 0;",
		"        int k = lg[r - l + 1];",
		"        return min(st[k][l], st[k][r - (1 << k) + 1]);",
		"    }",
		"",
		"    // O(1) LCP查询（需要配合rank数组）",
		"    int lcp_query(int i, int j, const vector<int>& rk) const {",
		"        if (i == j) return n - i;",
		"        int ri = rk[i], rj = rk[j];",
		"        if (ri > rj) swap(ri, rj);",
		"        return query(ri + 1, rj);",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Suffix_Structures\SuffixArray.h
s("06_string_algorithms_suffix_structures_suffixarray_h", {
	t({
		"/**",
		" * 后缀数组（Suffix Array）",
		" * 功能：构建字符串的后缀数组和LCP数组，支持各种字符串查询",
		" * 时间复杂度：构建 O(n log n)，查询依具体操作而定",
		" * 空间复杂度：O(n)",
		" * 适用场景：字符串匹配、最长公共前缀、子串计数、字典序比较",
		" */",
		"struct SuffixArray {",
		"    string s;",
		"    int n;",
		"    vector<int> sa, rank, lcp;",
		"",
		"    SuffixArray(const string& str) : s(str), n(str.length()) {",
		"        build_sa();",
		"        build_lcp();",
		"    }",
		"",
		"    void build_sa() {",
		"        sa.resize(n);",
		"        rank.resize(n);",
		"",
		"        vector<int> cnt(256, 0);",
		"        for (int i = 0; i < n; i++) cnt[s[i]]++;",
		"        for (int i = 1; i < 256; i++) cnt[i] += cnt[i - 1];",
		"        for (int i = n - 1; i >= 0; i--) sa[--cnt[s[i]]] = i;",
		"",
		"        rank[sa[0]] = 0;",
		"        for (int i = 1; i < n; i++) { rank[sa[i]] = rank[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]); }",
		"",
		"        for (int k = 1; k < n; k <<= 1) {",
		"            auto cmp = [&](int i, int j) {",
		"                if (rank[i] != rank[j]) return rank[i] < rank[j];",
		"                int ri = (i + k < n) ? rank[i + k] : -1;",
		"                int rj = (j + k < n) ? rank[j + k] : -1;",
		"                return ri < rj;",
		"            };",
		"",
		"            sort(sa.begin(), sa.end(), cmp);",
		"",
		"            vector<int> new_rank(n);",
		"            new_rank[sa[0]] = 0;",
		"            for (int i = 1; i < n; i++) { new_rank[sa[i]] = new_rank[sa[i - 1]] + cmp(sa[i - 1], sa[i]); }",
		"            rank = new_rank;",
		"",
		"            if (rank[sa[n - 1]] == n - 1) break;",
		"        }",
		"    }",
		"",
		"    void build_lcp() {",
		"        lcp.resize(n - 1);",
		"        int k = 0;",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            if (rank[i] == n - 1) {",
		"                k = 0;",
		"                continue;",
		"            }",
		"",
		"            int j = sa[rank[i] + 1];",
		"            while (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;",
		"            lcp[rank[i]] = k;",
		"",
		"            if (k > 0) k--;",
		"        }",
		"    }",
		"",
		"    // 比较两个后缀的字典序",
		"    bool suffix_compare(int i, int j) { return rank[i] < rank[j]; }",
		"",
		"    // 查找字符串t在s中的所有出现位置",
		"    vector<int> find_all_occurrences(const string& t) {",
		"        vector<int> result;",
		"        int m = t.length();",
		"",
		"        // 二分查找第一个匹配位置",
		"        int left = 0, right = n - 1;",
		"        while (left <= right) {",
		"            int mid = (left + right) / 2;",
		"            string suffix = s.substr(sa[mid], min(m, n - sa[mid]));",
		"            if (suffix < t) {",
		"                left = mid + 1;",
		"            } else {",
		"                right = mid - 1;",
		"            }",
		"        }",
		"",
		"        int start = left;",
		"",
		"        // 二分查找最后一个匹配位置",
		"        left = 0;",
		"        right = n - 1;",
		"        while (left <= right) {",
		"            int mid = (left + right) / 2;",
		"            string suffix = s.substr(sa[mid], min(m, n - sa[mid]));",
		"            if (suffix <= t) {",
		"                left = mid + 1;",
		"            } else {",
		"                right = mid - 1;",
		"            }",
		"        }",
		"",
		"        int end = right;",
		"",
		"        // 收集所有匹配位置",
		"        for (int i = start; i <= end; i++) {",
		"            if (sa[i] + m <= n && s.substr(sa[i], m) == t) { result.push_back(sa[i]); }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 最长公共前缀查询（区间最小值查询）",
		"    int query_lcp(int i, int j) {",
		"        if (i == j) return n - i;",
		"",
		"        int ri = rank[i], rj = rank[j];",
		"        if (ri > rj) swap(ri, rj);",
		"",
		"        int min_lcp = lcp[ri];",
		"        for (int k = ri + 1; k < rj; k++) { min_lcp = min(min_lcp, lcp[k]); }",
		"",
		"        return min_lcp;",
		"    }",
		"",
		"    // 字典序第k小的后缀",
		"    int kth_suffix(int k) { return sa[k]; }",
		"",
		"    // 后缀的排名",
		"    int suffix_rank(int i) { return rank[i]; }",
		"",
		"    // 不同子串的数量",
		"    long long distinct_substrings() {",
		"        long long total = (long long)n * (n + 1) / 2;",
		"        for (int i = 0; i < n - 1; i++) { total -= lcp[i]; }",
		"        return total;",
		"    }",
		"};",
	})
}),

-- 06_String_Algorithms\Suffix_Structures\SuffixTree.h
s("06_string_algorithms_suffix_structures_suffixtree_h", {
	t({
		"/**",
		" * 后缀树（Suffix Tree）",
		" * 功能：构建字符串的后缀树，支持快速子串匹配、最长公共子串等操作",
		" * 时间复杂度：构建 O(n)，查询 O(m)",
		" * 空间复杂度：O(n)",
		" * 适用场景：字符串匹配、最长公共子串、后缀相关查询",
		" */",
		"struct SuffixTree {",
		"    struct Node {",
		"        map<char, int> next;",
		"        int start, end;  // 边标签的范围 [start, end)",
		"        int suffix_link;",
		"        int suffix_index;",
		"",
		"        Node() : start(-1), end(-1), suffix_link(-1), suffix_index(-1) {}",
		"    };",
		"",
		"    string text;",
		"    vector<Node> nodes;",
		"    int node_count;",
		"    int active_node, active_edge, active_length;",
		"    int remaining;",
		"    int root, leaf_end;",
		"",
		"    SuffixTree(const string& s) : text(s + \"$\"), node_count(0) {",
		"        int n = text.length();",
		"        leaf_end = n - 1;",
		"        root = new_node(-1, -1);",
		"        active_node = root;",
		"        active_edge = -1;",
		"        active_length = 0;",
		"        remaining = 0;",
		"",
		"        for (int i = 0; i < n; i++) { extend(i); }",
		"",
		"        set_suffix_index(root, 0);",
		"    }",
		"",
		"   private:",
		"    int new_node(int start, int end) {",
		"        nodes.push_back(Node());",
		"        int idx = node_count++;",
		"        nodes[idx].start = start;",
		"        nodes[idx].end = end;",
		"        return idx;",
		"    }",
		"",
		"    int edge_length(int node) {",
		"        if (nodes[node].end == -1) return leaf_end - nodes[node].start + 1;",
		"        return nodes[node].end - nodes[node].start;",
		"    }",
		"",
		"    bool walk_down(int node) {",
		"        if (active_length >= edge_length(node)) {",
		"            active_edge += edge_length(node);",
		"            active_length -= edge_length(node);",
		"            active_node = node;",
		"            return true;",
		"        }",
		"        return false;",
		"    }",
		"",
		"    void extend(int pos) {",
		"        leaf_end = pos;",
		"        remaining++;",
		"        int last_new_node = -1;",
		"",
		"        while (remaining > 0) {",
		"            if (active_length == 0) { active_edge = pos; }",
		"",
		"            char edge_char = text[active_edge];",
		"            if (nodes[active_node].next.find(edge_char) == nodes[active_node].next.end()) {",
		"                // 创建新叶子节点",
		"                int leaf = new_node(pos, -1);",
		"                nodes[active_node].next[edge_char] = leaf;",
		"",
		"                if (last_new_node != -1) {",
		"                    nodes[last_new_node].suffix_link = active_node;",
		"                    last_new_node = -1;",
		"                }",
		"            } else {",
		"                int next_node = nodes[active_node].next[edge_char];",
		"                if (walk_down(next_node)) { continue; }",
		"",
		"                if (text[nodes[next_node].start + active_length] == text[pos]) {",
		"                    if (last_new_node != -1 && active_node != root) {",
		"                        nodes[last_new_node].suffix_link = active_node;",
		"                        last_new_node = -1;",
		"                    }",
		"                    active_length++;",
		"                    break;",
		"                }",
		"",
		"                // 分裂边",
		"                int split = new_node(nodes[next_node].start, nodes[next_node].start + active_length);",
		"                nodes[active_node].next[edge_char] = split;",
		"",
		"                int leaf = new_node(pos, -1);",
		"                nodes[split].next[text[pos]] = leaf;",
		"                nodes[next_node].start += active_length;",
		"                nodes[split].next[text[nodes[next_node].start]] = next_node;",
		"",
		"                if (last_new_node != -1) { nodes[last_new_node].suffix_link = split; }",
		"                last_new_node = split;",
		"            }",
		"",
		"            remaining--;",
		"            if (active_node == root && active_length > 0) {",
		"                active_length--;",
		"                active_edge = pos - remaining + 1;",
		"            } else if (active_node != root) {",
		"                active_node = nodes[active_node].suffix_link;",
		"            }",
		"        }",
		"    }",
		"",
		"    void set_suffix_index(int node, int label_height) {",
		"        bool is_leaf = true;",
		"        for (auto& edge : nodes[node].next) {",
		"            is_leaf = false;",
		"            set_suffix_index(edge.second, label_height + edge_length(edge.second));",
		"        }",
		"        if (is_leaf) { nodes[node].suffix_index = text.length() - label_height; }",
		"    }",
		"",
		"   public:",
		"    // 检查子串是否存在",
		"    bool contains(const string& pattern) {",
		"        int current = root;",
		"        int i = 0;",
		"",
		"        while (i < pattern.length()) {",
		"            char c = pattern[i];",
		"            if (nodes[current].next.find(c) == nodes[current].next.end()) { return false; }",
		"",
		"            int next_node = nodes[current].next[c];",
		"            int start = nodes[next_node].start;",
		"            int end = (nodes[next_node].end == -1) ? leaf_end : nodes[next_node].end;",
		"",
		"            for (int j = start; j <= end && i < pattern.length(); j++, i++) {",
		"                if (text[j] != pattern[i]) { return false; }",
		"            }",
		"            current = next_node;",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 获取所有后缀",
		"    vector<int> get_all_suffixes() {",
		"        vector<int> suffixes;",
		"",
		"        function<void(int)> dfs = [&](int node) {",
		"            if (nodes[node].suffix_index != -1) { suffixes.push_back(nodes[node].suffix_index); }",
		"            for (auto& edge : nodes[node].next) { dfs(edge.second); }",
		"        };",
		"",
		"        dfs(root);",
		"        return suffixes;",
		"    }",
		"};",
	})
}),

-- 07_Search_and_Sort\Binary_Search\BinarySearch.h
s("07_search_and_sort_binary_search_binarysearch_h", {
	t({
		"/**",
		" * 二分搜索算法集合",
		" * 功能：提供整数和实数的二分搜索模板",
		" * 时间复杂度：O(log n)",
		" * 空间复杂度：O(1)",
		" * 适用场景：单调性搜索、最值查找、区间搜索",
		" */",
		"struct BinarySearch {",
		"    // 整数二分搜索 - 查找最后一个满足条件的值",
		"    template <typename T, typename F>",
		"    static T binary_search_last(T lo, T hi, F check) {",
		"        T ans = lo - 1;",
		"        while (lo <= hi) {",
		"            T mid = lo + (hi - lo) / 2;",
		"            if (check(mid)) {",
		"                ans = mid;",
		"                lo = mid + 1;",
		"            } else {",
		"                hi = mid - 1;",
		"            }",
		"        }",
		"        return ans;",
		"    }",
		"",
		"    // 整数二分搜索 - 查找第一个满足条件的值",
		"    template <typename T, typename F>",
		"    static T binary_search_first(T lo, T hi, F check) {",
		"        T ans = hi + 1;",
		"        while (lo <= hi) {",
		"            T mid = lo + (hi - lo) / 2;",
		"            if (check(mid)) {",
		"                ans = mid;",
		"                hi = mid - 1;",
		"            } else {",
		"                lo = mid + 1;",
		"            }",
		"        }",
		"        return ans;",
		"    }",
		"",
		"    // 实数二分搜索",
		"    template <typename F>",
		"    static double binary_search_real(double lo, double hi, F check, double eps = 1e-9) {",
		"        while (hi - lo > eps) {",
		"            double mid = (lo + hi) / 2;",
		"            if (check(mid)) {",
		"                hi = mid;",
		"            } else {",
		"                lo = mid;",
		"            }",
		"        }",
		"        return lo;",
		"    }",
		"",
		"    // 三分搜索 - 查找单峰函数的最值",
		"    template <typename F>",
		"    static double ternary_search(double lo, double hi, F func, double eps = 1e-9) {",
		"        while (hi - lo > eps) {",
		"            double m1 = lo + (hi - lo) / 3;",
		"            double m2 = hi - (hi - lo) / 3;",
		"            if (func(m1) > func(m2)) {",
		"                hi = m2;",
		"            } else {",
		"                lo = m1;",
		"            }",
		"        }",
		"        return (lo + hi) / 2;",
		"    }",
		"};",
	})
}),

-- 07_Search_and_Sort\Binary_Search\TernarySearch.h
s("07_search_and_sort_binary_search_ternarysearch_h", {
	t({
		"/**",
		" * 三分搜索算法",
		" * 功能：在单峰/单谷函数上查找极值点",
		" * 时间复杂度：O(log n)",
		" * 空间复杂度：O(1)",
		" * 适用场景：单峰函数最值查找、最优化问题",
		" */",
		"struct TernarySearch {",
		"    // 实数三分搜索 - 查找单峰函数的最大值点",
		"    template <typename F>",
		"    static double find_maximum(double lo, double hi, F func, double eps = 1e-9) {",
		"        while (hi - lo > eps) {",
		"            double m1 = lo + (hi - lo) / 3;",
		"            double m2 = hi - (hi - lo) / 3;",
		"            if (func(m1) < func(m2)) {",
		"                lo = m1;",
		"            } else {",
		"                hi = m2;",
		"            }",
		"        }",
		"        return (lo + hi) / 2;",
		"    }",
		"",
		"    // 实数三分搜索 - 查找单谷函数的最小值点",
		"    template <typename F>",
		"    static double find_minimum(double lo, double hi, F func, double eps = 1e-9) {",
		"        while (hi - lo > eps) {",
		"            double m1 = lo + (hi - lo) / 3;",
		"            double m2 = hi - (hi - lo) / 3;",
		"            if (func(m1) > func(m2)) {",
		"                lo = m1;",
		"            } else {",
		"                hi = m2;",
		"            }",
		"        }",
		"        return (lo + hi) / 2;",
		"    }",
		"",
		"    // 整数三分搜索 - 查找单峰函数的最大值点",
		"    template <typename F>",
		"    static int find_maximum_int(int lo, int hi, F func) {",
		"        while (hi - lo > 2) {",
		"            int m1 = lo + (hi - lo) / 3;",
		"            int m2 = hi - (hi - lo) / 3;",
		"            if (func(m1) < func(m2)) {",
		"                lo = m1;",
		"            } else {",
		"                hi = m2;",
		"            }",
		"        }",
		"",
		"        int best = lo;",
		"        for (int i = lo + 1; i <= hi; i++) {",
		"            if (func(i) > func(best)) { best = i; }",
		"        }",
		"        return best;",
		"    }",
		"",
		"    // 整数三分搜索 - 查找单谷函数的最小值点",
		"    template <typename F>",
		"    static int find_minimum_int(int lo, int hi, F func) {",
		"        while (hi - lo > 2) {",
		"            int m1 = lo + (hi - lo) / 3;",
		"            int m2 = hi - (hi - lo) / 3;",
		"            if (func(m1) > func(m2)) {",
		"                lo = m1;",
		"            } else {",
		"                hi = m2;",
		"            }",
		"        }",
		"",
		"        int best = lo;",
		"        for (int i = lo + 1; i <= hi; i++) {",
		"            if (func(i) < func(best)) { best = i; }",
		"        }",
		"        return best;",
		"    }",
		"};",
	})
}),

-- 07_Search_and_Sort\Sorting\MergeSort.h
s("07_search_and_sort_sorting_mergesort_h", {
	t({
		"/**",
		" * 归并排序算法集合",
		" * 功能：提供各种归并排序的实现，包括逆序对计数",
		" * 时间复杂度：O(n log n)",
		" * 空间复杂度：O(n)",
		" * 适用场景：稳定排序、逆序对计数、分治算法",
		" */",
		"struct MergeSort {",
		"    // 标准归并排序",
		"    template <typename T>",
		"    static void merge_sort(vector<T>& arr) {",
		"        if (arr.size() <= 1) return;",
		"        vector<T> temp(arr.size());",
		"        merge_sort_helper(arr, 0, arr.size() - 1, temp);",
		"    }",
		"",
		"   private:",
		"    template <typename T>",
		"    static void merge_sort_helper(vector<T>& arr, int left, int right, vector<T>& temp) {",
		"        if (left >= right) return;",
		"",
		"        int mid = left + (right - left) / 2;",
		"        merge_sort_helper(arr, left, mid, temp);",
		"        merge_sort_helper(arr, mid + 1, right, temp);",
		"        merge(arr, left, mid, right, temp);",
		"    }",
		"",
		"    template <typename T>",
		"    static void merge(vector<T>& arr, int left, int mid, int right, vector<T>& temp) {",
		"        int i = left, j = mid + 1, k = left;",
		"",
		"        while (i <= mid && j <= right) {",
		"            if (arr[i] <= arr[j]) {",
		"                temp[k++] = arr[i++];",
		"            } else {",
		"                temp[k++] = arr[j++];",
		"            }",
		"        }",
		"",
		"        while (i <= mid) temp[k++] = arr[i++];",
		"        while (j <= right) temp[k++] = arr[j++];",
		"",
		"        for (i = left; i <= right; i++) { arr[i] = temp[i]; }",
		"    }",
		"",
		"   public:",
		"    // 计算逆序对数量",
		"    template <typename T>",
		"    static long long count_inversions(vector<T>& arr) {",
		"        if (arr.size() <= 1) return 0;",
		"        vector<T> temp(arr.size());",
		"        return count_inversions_helper(arr, 0, arr.size() - 1, temp);",
		"    }",
		"",
		"   private:",
		"    template <typename T>",
		"    static long long count_inversions_helper(vector<T>& arr, int left, int right, vector<T>& temp) {",
		"        if (left >= right) return 0;",
		"",
		"        int mid = left + (right - left) / 2;",
		"        long long inv_count = 0;",
		"",
		"        inv_count += count_inversions_helper(arr, left, mid, temp);",
		"        inv_count += count_inversions_helper(arr, mid + 1, right, temp);",
		"        inv_count += merge_and_count(arr, left, mid, right, temp);",
		"",
		"        return inv_count;",
		"    }",
		"",
		"    template <typename T>",
		"    static long long merge_and_count(vector<T>& arr, int left, int mid, int right, vector<T>& temp) {",
		"        int i = left, j = mid + 1, k = left;",
		"        long long inv_count = 0;",
		"",
		"        while (i <= mid && j <= right) {",
		"            if (arr[i] <= arr[j]) {",
		"                temp[k++] = arr[i++];",
		"            } else {",
		"                temp[k++] = arr[j++];",
		"                inv_count += (mid - i + 1);  // 所有左边剩余元素都与arr[j]构成逆序对",
		"            }",
		"        }",
		"",
		"        while (i <= mid) temp[k++] = arr[i++];",
		"        while (j <= right) temp[k++] = arr[j++];",
		"",
		"        for (i = left; i <= right; i++) { arr[i] = temp[i]; }",
		"",
		"        return inv_count;",
		"    }",
		"",
		"   public:",
		"    // 自底向上的归并排序（迭代版本）",
		"    template <typename T>",
		"    static void merge_sort_iterative(vector<T>& arr) {",
		"        int n = arr.size();",
		"        if (n <= 1) return;",
		"",
		"        vector<T> temp(n);",
		"",
		"        for (int size = 1; size < n; size *= 2) {",
		"            for (int left = 0; left < n - size; left += 2 * size) {",
		"                int mid = left + size - 1;",
		"                int right = min(left + 2 * size - 1, n - 1);",
		"                merge(arr, left, mid, right, temp);",
		"            }",
		"        }",
		"    }",
		"};",
	})
}),

-- 07_Search_and_Sort\Sorting\QuickSort.h
s("07_search_and_sort_sorting_quicksort_h", {
	t({
		"/**",
		" * 快速排序算法集合",
		" * 时间复杂度：平均O(n log n)，最坏O(n²)",
		" * 空间复杂度：O(log n)（递归栈）",
		" * 适用场景：通用排序，不稳定排序",
		" */",
		"struct QuickSort {",
		"    // Lomuto分区方案",
		"    template <typename T>",
		"    static int partition(vector<T>& arr, int left, int right) {",
		"        T pivot = arr[right];",
		"        int i = left - 1;",
		"",
		"        for (int j = left; j < right; j++) {",
		"            if (arr[j] <= pivot) {",
		"                i++;",
		"                swap(arr[i], arr[j]);",
		"            }",
		"        }",
		"        swap(arr[i + 1], arr[right]);",
		"        return i + 1;",
		"    }",
		"",
		"    // Hoare分区方案",
		"    template <typename T>",
		"    static int hoare_partition(vector<T>& arr, int left, int right) {",
		"        T pivot = arr[left];",
		"        int i = left - 1, j = right + 1;",
		"",
		"        while (true) {",
		"            do { i++; } while (arr[i] < pivot);",
		"            do { j--; } while (arr[j] > pivot);",
		"            if (i >= j) return j;",
		"            swap(arr[i], arr[j]);",
		"        }",
		"    }",
		"",
		"    // 标准快速排序",
		"    template <typename T>",
		"    static void quicksort(vector<T>& arr, int left, int right) {",
		"        if (left >= right) return;",
		"",
		"        int pivot = partition(arr, left, right);",
		"        quicksort(arr, left, pivot - 1);",
		"        quicksort(arr, pivot + 1, right);",
		"    }",
		"",
		"    template <typename T>",
		"    static void quicksort(vector<T>& arr) {",
		"        if (!arr.empty()) quicksort(arr, 0, arr.size() - 1);",
		"    }",
		"",
		"    // 三路快速排序（处理重复元素）",
		"    template <typename T>",
		"    static pair<int, int> three_way_partition(vector<T>& arr, int left, int right) {",
		"        T pivot = arr[left];",
		"        int lt = left, i = left + 1, gt = right;",
		"",
		"        while (i <= gt) {",
		"            if (arr[i] < pivot) {",
		"                swap(arr[lt++], arr[i++]);",
		"            } else if (arr[i] > pivot) {",
		"                swap(arr[i], arr[gt--]);",
		"            } else {",
		"                i++;",
		"            }",
		"        }",
		"",
		"        return {lt, gt};",
		"    }",
		"",
		"    template <typename T>",
		"    static void three_way_quicksort(vector<T>& arr, int left, int right) {",
		"        if (left >= right) return;",
		"",
		"        auto [lt, gt] = three_way_partition(arr, left, right);",
		"        three_way_quicksort(arr, left, lt - 1);",
		"        three_way_quicksort(arr, gt + 1, right);",
		"    }",
		"",
		"    // 随机化快速排序",
		"    template <typename T>",
		"    static void randomized_quicksort(vector<T>& arr, int left, int right) {",
		"        if (left >= right) return;",
		"",
		"        int random_index = left + rand() % (right - left + 1);",
		"        swap(arr[random_index], arr[right]);",
		"",
		"        int pivot = partition(arr, left, right);",
		"        randomized_quicksort(arr, left, pivot - 1);",
		"        randomized_quicksort(arr, pivot + 1, right);",
		"    }",
		"",
		"    // 迭代版快速排序",
		"    template <typename T>",
		"    static void iterative_quicksort(vector<T>& arr) {",
		"        if (arr.empty()) return;",
		"",
		"        stack<pair<int, int>> st;",
		"        st.push({0, (int)arr.size() - 1});",
		"",
		"        while (!st.empty()) {",
		"            auto [left, right] = st.top();",
		"            st.pop();",
		"",
		"            if (left >= right) continue;",
		"",
		"            int pivot = partition(arr, left, right);",
		"            st.push({left, pivot - 1});",
		"            st.push({pivot + 1, right});",
		"        }",
		"    }",
		"",
		"    // 插入排序（用于混合排序）",
		"    template <typename T>",
		"    static void insertion_sort(vector<T>& arr, int left, int right) {",
		"        for (int i = left + 1; i <= right; i++) {",
		"            T key = arr[i];",
		"            int j = i - 1;",
		"            while (j >= left && arr[j] > key) {",
		"                arr[j + 1] = arr[j];",
		"                j--;",
		"            }",
		"            arr[j + 1] = key;",
		"        }",
		"    }",
		"",
		"    // 混合排序（小数组使用插入排序）",
		"    template <typename T>",
		"    static void hybrid_quicksort(vector<T>& arr, int left, int right, int threshold = 10) {",
		"        if (left >= right) return;",
		"",
		"        if (right - left + 1 <= threshold) {",
		"            insertion_sort(arr, left, right);",
		"            return;",
		"        }",
		"",
		"        int pivot = partition(arr, left, right);",
		"        hybrid_quicksort(arr, left, pivot - 1, threshold);",
		"        hybrid_quicksort(arr, pivot + 1, right, threshold);",
		"    }",
		"",
		"    // 堆排序（用于内省排序）",
		"    template <typename T>",
		"    static void heapsort(vector<T>& arr, int left, int right) {",
		"        vector<T> temp(arr.begin() + left, arr.begin() + right + 1);",
		"        make_heap(temp.begin(), temp.end());",
		"        sort_heap(temp.begin(), temp.end());",
		"        copy(temp.begin(), temp.end(), arr.begin() + left);",
		"    }",
		"",
		"    // 内省排序（Introsort）",
		"    template <typename T>",
		"    static void introsort_helper(vector<T>& arr, int left, int right, int depth_limit) {",
		"        if (left >= right) return;",
		"",
		"        if (depth_limit == 0) {",
		"            heapsort(arr, left, right);",
		"            return;",
		"        }",
		"",
		"        if (right - left + 1 <= 16) {",
		"            insertion_sort(arr, left, right);",
		"            return;",
		"        }",
		"",
		"        int pivot = partition(arr, left, right);",
		"        introsort_helper(arr, left, pivot - 1, depth_limit - 1);",
		"        introsort_helper(arr, pivot + 1, right, depth_limit - 1);",
		"    }",
		"",
		"    template <typename T>",
		"    static void introsort(vector<T>& arr) {",
		"        if (arr.empty()) return;",
		"        int max_depth = 2 * log2(arr.size());",
		"        introsort_helper(arr, 0, arr.size() - 1, max_depth);",
		"    }",
		"",
		"    // 尾递归优化",
		"    template <typename T>",
		"    static void tail_recursive_quicksort(vector<T>& arr, int left, int right) {",
		"        while (left < right) {",
		"            int pivot = partition(arr, left, right);",
		"",
		"            if (pivot - left < right - pivot) {",
		"                tail_recursive_quicksort(arr, left, pivot - 1);",
		"                left = pivot + 1;",
		"            } else {",
		"                tail_recursive_quicksort(arr, pivot + 1, right);",
		"                right = pivot - 1;",
		"            }",
		"        }",
		"    }",
		"",
		"    // 快速选择（第k小元素）",
		"    template <typename T>",
		"    static T quickselect(vector<T>& arr, int left, int right, int k) {",
		"        if (left == right) return arr[left];",
		"",
		"        int pivot = partition(arr, left, right);",
		"",
		"        if (k == pivot) {",
		"            return arr[k];",
		"        } else if (k < pivot) {",
		"            return quickselect(arr, left, pivot - 1, k);",
		"        } else {",
		"            return quickselect(arr, pivot + 1, right, k);",
		"        }",
		"    }",
		"",
		"    template <typename T>",
		"    static T kth_element(vector<T> arr, int k) {",
		"        return quickselect(arr, 0, arr.size() - 1, k - 1);",
		"    }",
		"",
		"    // 中位数的中位数选择pivot",
		"    template <typename T>",
		"    static T median_of_medians(vector<T>& arr, int left, int right, int k) {",
		"        if (right - left < 5) {",
		"            insertion_sort(arr, left, right);",
		"            return arr[left + k];",
		"        }",
		"",
		"        vector<T> medians;",
		"        for (int i = left; i <= right; i += 5) {",
		"            int group_right = min(i + 4, right);",
		"            insertion_sort(arr, i, group_right);",
		"            medians.push_back(arr[i + (group_right - i) / 2]);",
		"        }",
		"",
		"        T pivot = median_of_medians(medians, 0, medians.size() - 1, medians.size() / 2);",
		"",
		"        int pivot_index = find(arr.begin() + left, arr.begin() + right + 1, pivot) - arr.begin();",
		"        swap(arr[pivot_index], arr[right]);",
		"",
		"        int partition_index = partition(arr, left, right);",
		"        int relative_pos = partition_index - left;",
		"",
		"        if (k == relative_pos) {",
		"            return arr[partition_index];",
		"        } else if (k < relative_pos) {",
		"            return median_of_medians(arr, left, partition_index - 1, k);",
		"        } else {",
		"            return median_of_medians(arr, partition_index + 1, right, k - relative_pos - 1);",
		"        }",
		"    }",
		"};",
	})
}),

-- 08_Miscellaneous\Query_Algorithms\MoAlgorithm.h
s("08_miscellaneous_query_algorithms_moalgorithm_h", {
	t({
		"/**",
		" * 莫队算法",
		" * 时间复杂度：O((n+q)√n)",
		" * 空间复杂度：O(n)",
		" * 适用场景：离线区间查询，支持添加/删除操作",
		" */",
		"struct MoAlgorithm {",
		"    struct Query {",
		"        int l, r, id, block;",
		"        bool operator<(const Query& other) const {",
		"            if (block != other.block) return block < other.block;",
		"            return (block & 1) ? (r < other.r) : (r > other.r);",
		"        }",
		"    };",
		"",
		"    vector<Query> queries;",
		"    vector<int> arr;",
		"    vector<long long> answers;",
		"    int n, q, block_size;",
		"",
		"    int curr_l, curr_r;",
		"    long long curr_answer;",
		"",
		"    MoAlgorithm(const vector<int>& data) : arr(data), n(data.size()) {",
		"        block_size = max(1, (int)sqrt(n));",
		"        curr_l = 0;",
		"        curr_r = -1;",
		"        curr_answer = 0;",
		"    }",
		"",
		"    void add_query(int l, int r, int id) {",
		"        queries.push_back({l, r, id, l / block_size});",
		"        q = queries.size();",
		"    }",
		"",
		"    virtual void add_element(int pos) = 0;",
		"    virtual void remove_element(int pos) = 0;",
		"    virtual long long get_answer() { return curr_answer; }",
		"",
		"    vector<long long> solve() {",
		"        answers.resize(q);",
		"        sort(queries.begin(), queries.end());",
		"",
		"        for (const auto& query : queries) {",
		"            while (curr_l > query.l) {",
		"                curr_l--;",
		"                add_element(curr_l);",
		"            }",
		"            while (curr_l < query.l) {",
		"                remove_element(curr_l);",
		"                curr_l++;",
		"            }",
		"",
		"            while (curr_r < query.r) {",
		"                curr_r++;",
		"                add_element(curr_r);",
		"            }",
		"            while (curr_r > query.r) {",
		"                remove_element(curr_r);",
		"                curr_r--;",
		"            }",
		"",
		"            answers[query.id] = get_answer();",
		"        }",
		"",
		"        return answers;",
		"    }",
		"};",
		"",
		"/**",
		" * 区间不同元素个数查询",
		" */",
		"struct DistinctElementsMo : public MoAlgorithm {",
		"    vector<int> cnt;",
		"    int distinct_count;",
		"",
		"    DistinctElementsMo(const vector<int>& data) : MoAlgorithm(data) {",
		"        int max_val = *max_element(data.begin(), data.end());",
		"        cnt.resize(max_val + 1, 0);",
		"        distinct_count = 0;",
		"    }",
		"",
		"    void add_element(int pos) override {",
		"        if (cnt[arr[pos]] == 0) distinct_count++;",
		"        cnt[arr[pos]]++;",
		"    }",
		"",
		"    void remove_element(int pos) override {",
		"        cnt[arr[pos]]--;",
		"        if (cnt[arr[pos]] == 0) distinct_count--;",
		"    }",
		"",
		"    long long get_answer() override { return distinct_count; }",
		"};",
		"",
		"/**",
		" * 区间平方和查询",
		" */",
		"struct SquareSumMo : public MoAlgorithm {",
		"    long long sum, square_sum;",
		"",
		"    SquareSumMo(const vector<int>& data) : MoAlgorithm(data) {",
		"        sum = 0;",
		"        square_sum = 0;",
		"    }",
		"",
		"    void add_element(int pos) override {",
		"        square_sum += 2LL * sum * arr[pos] + 1LL * arr[pos] * arr[pos];",
		"        sum += arr[pos];",
		"    }",
		"",
		"    void remove_element(int pos) override {",
		"        sum -= arr[pos];",
		"        square_sum -= 2LL * sum * arr[pos] + 1LL * arr[pos] * arr[pos];",
		"    }",
		"",
		"    long long get_answer() override { return square_sum; }",
		"};",
		"",
		"/**",
		" * 带修改的莫队算法",
		" * 时间复杂度：O(n^(5/3))",
		" * 空间复杂度：O(n)",
		" */",
		"struct ModifiableMoAlgorithm {",
		"    struct Query {",
		"        int l, r, t, id;",
		"    };",
		"",
		"    struct Modification {",
		"        int pos, old_val, new_val;",
		"    };",
		"",
		"    vector<Query> queries;",
		"    vector<Modification> modifications;",
		"    vector<int> arr, original_arr;",
		"    vector<long long> answers;",
		"    int n, q, m, block_size;",
		"",
		"    int curr_l, curr_r, curr_t;",
		"",
		"    ModifiableMoAlgorithm(const vector<int>& data) : arr(data), original_arr(data), n(data.size()) {",
		"        block_size = max(1, (int)cbrt(n * n));",
		"        curr_l = 0;",
		"        curr_r = -1;",
		"        curr_t = -1;",
		"    }",
		"",
		"    void add_query(int l, int r, int t, int id) { queries.push_back({l, r, t, id}); }",
		"",
		"    void add_modification(int pos, int new_val) {",
		"        modifications.push_back({pos, arr[pos], new_val});",
		"        arr[pos] = new_val;",
		"        m = modifications.size();",
		"    }",
		"",
		"    virtual void add_element(int pos) = 0;",
		"    virtual void remove_element(int pos) = 0;",
		"    virtual void apply_modification(int mod_id) = 0;",
		"    virtual void undo_modification(int mod_id) = 0;",
		"    virtual long long get_answer() = 0;",
		"",
		"    vector<long long> solve() {",
		"        answers.resize(queries.size());",
		"        arr = original_arr;",
		"",
		"        sort(queries.begin(), queries.end(), [&](const Query& a, const Query& b) {",
		"            int block_a = a.l / block_size;",
		"            int block_b = b.l / block_size;",
		"            if (block_a != block_b) return block_a < block_b;",
		"",
		"            int block_r_a = a.r / block_size;",
		"            int block_r_b = b.r / block_size;",
		"            if (block_r_a != block_r_b) return block_r_a < block_r_b;",
		"",
		"            return a.t < b.t;",
		"        });",
		"",
		"        for (const auto& query : queries) {",
		"            while (curr_t < query.t) {",
		"                curr_t++;",
		"                apply_modification(curr_t);",
		"            }",
		"            while (curr_t > query.t) {",
		"                undo_modification(curr_t);",
		"                curr_t--;",
		"            }",
		"",
		"            while (curr_l > query.l) {",
		"                curr_l--;",
		"                add_element(curr_l);",
		"            }",
		"            while (curr_l < query.l) {",
		"                remove_element(curr_l);",
		"                curr_l++;",
		"            }",
		"            while (curr_r < query.r) {",
		"                curr_r++;",
		"                add_element(curr_r);",
		"            }",
		"            while (curr_r > query.r) {",
		"                remove_element(curr_r);",
		"                curr_r--;",
		"            }",
		"",
		"            answers[query.id] = get_answer();",
		"        }",
		"",
		"        return answers;",
		"    }",
		"};",
	})
}),

-- 10_Contest_Specific\CodeForces\template.h
s("10_contest_specific_codeforces_template_h", {
	t({
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"",
		"using ll = long long;",
		"using ull = unsigned long long;",
		"using pii = pair<int, int>;",
		"using pll = pair<ll, ll>;",
		"using vi = vector<int>;",
		"using vll = vector<ll>;",
		"using vvi = vector<vi>;",
		"using vvl = vector<vll>;",
		"",
		"constexpr int MOD = 1e9 + 7;",
		"constexpr int INF = 0x3f3f3f3f;",
		"constexpr ll LINF = 0x3f3f3f3f3f3f3f3f;",
		"",
		"#ifndef ONLINE_JUDGE",
		"#define dbg(x) cerr << #x << \" = \" << x << '\\n'",
		"#define dbg2(x, y) cerr << #x << \" = \" << x << \", \" << #y << \" = \" << y << '\\n'",
		"#define dbgv(v)                        \\",
		"    cerr << #v << \": \";                \\",
		"    for (auto x : v) cerr << x << ' '; \\",
		"    cerr << '\\n'",
		"#else",
		"#define dbg(x)",
		"#define dbg2(x, y)",
		"#define dbgv(v)",
		"#endif",
		"",
		"void solve() {",
		"    ",
		"}",
		"",
		"int main() {",
		"    ios::sync_with_stdio(false);",
		"    cin.tie(nullptr);",
		"    ",
		"    int t = 1;",
		"    // cin >> t;",
		"    while (t--) solve();",
		"    ",
		"    return 0;",
		"}",
	})
}),

-- 12_Utilities\BigInteger.h
s("12_utilities_biginteger_h", {
	t({
		"/**",
		" * 大整数类",
		" * 加减法复杂度：O(max(n,m))；乘法：O(n*m)；除法：O(n*m)",
		" * 空间复杂度：O(n)",
		" * 支持任意精度整数运算，包含高精度与低精度优化运算",
		" */",
		"struct BigInt {",
		"    vector<int> digits;",
		"    bool negative = false;",
		"    static constexpr int BASE = 10000;",
		"    static constexpr int WIDTH = 4;",
		"",
		"    void normalize() {",
		"        while (digits.size() > 1 && digits.back() == 0) digits.pop_back();",
		"        if (digits.size() == 1 && digits[0] == 0) negative = false;",
		"    }",
		"",
		"    int compare_abs(const BigInt& other) const {",
		"        if (digits.size() != other.digits.size()) {",
		"            return digits.size() < other.digits.size() ? -1 : 1;",
		"        }",
		"        for (int i = digits.size() - 1; i >= 0; i--) {",
		"            if (digits[i] != other.digits[i]) {",
		"                return digits[i] < other.digits[i] ? -1 : 1;",
		"            }",
		"        }",
		"        return 0;",
		"    }",
		"",
		"    BigInt() : digits{0} {",
		"    }",
		"",
		"    template <typename T>",
		"    BigInt(T x)",
		"        requires integral<T>",
		"    {",
		"        negative = x < 0;",
		"        x = std::abs(x);",
		"        digits.clear();",
		"        if (x == 0) {",
		"            digits.push_back(0);",
		"        } else {",
		"            while (x) {",
		"                digits.push_back(x % BASE);",
		"                x /= BASE;",
		"            }",
		"        }",
		"    }",
		"",
		"    BigInt(const string& s) {",
		"        digits.clear();",
		"        negative = false;",
		"",
		"        if (s.empty()) {",
		"            digits.push_back(0);",
		"            return;",
		"        }",
		"",
		"        int start = 0;",
		"        if (s[0] == '-') {",
		"            negative = true;",
		"            start = 1;",
		"        } else if (s[0] == '+') {",
		"            start = 1;",
		"        }",
		"",
		"        for (int i = s.length(); i > start; i -= WIDTH) {",
		"            int num = 0;",
		"            for (int j = max(start, i - WIDTH); j < i; j++) {",
		"                num = num * 10 + (s[j] - '0');",
		"            }",
		"            digits.push_back(num);",
		"        }",
		"        normalize();",
		"    }",
		"",
		"    auto operator<=>(const BigInt& other) const {",
		"        if (negative != other.negative) {",
		"            return negative ? strong_ordering::less : strong_ordering::greater;",
		"        }",
		"",
		"        int cmp = compare_abs(other);",
		"        if (negative) cmp = -cmp;",
		"",
		"        return cmp < 0 ? strong_ordering::less : cmp > 0 ? strong_ordering::greater : strong_ordering::equal;",
		"    }",
		"",
		"    bool operator==(const BigInt& other) const = default;",
		"",
		"    // =================== 高精度 + 高精度 ===================",
		"    BigInt operator+(const BigInt& other) const {",
		"        if (negative != other.negative) {",
		"            return negative ? other - (-*this) : *this - (-other);",
		"        }",
		"",
		"        BigInt result;",
		"        result.negative = negative;",
		"        result.digits.clear();",
		"",
		"        int carry = 0;",
		"        size_t max_size = max(digits.size(), other.digits.size());",
		"",
		"        for (size_t i = 0; i < max_size || carry; i++) {",
		"            int sum = carry;",
		"            if (i < digits.size()) sum += digits[i];",
		"            if (i < other.digits.size()) sum += other.digits[i];",
		"",
		"            result.digits.push_back(sum % BASE);",
		"            carry = sum / BASE;",
		"        }",
		"",
		"        result.normalize();",
		"        return result;",
		"    }",
		"",
		"    BigInt operator-(const BigInt& other) const {",
		"        if (negative != other.negative) {",
		"            return *this + (-other);",
		"        }",
		"",
		"        if (negative) {",
		"            return -((-*this) - (-other));",
		"        }",
		"",
		"        if (compare_abs(other) < 0) {",
		"            return -(other - *this);",
		"        }",
		"",
		"        BigInt result;",
		"        result.digits.clear();",
		"",
		"        int borrow = 0;",
		"        for (size_t i = 0; i < digits.size(); i++) {",
		"            int diff = digits[i] - borrow;",
		"            if (i < other.digits.size()) diff -= other.digits[i];",
		"",
		"            if (diff < 0) {",
		"                diff += BASE;",
		"                borrow = 1;",
		"            } else {",
		"                borrow = 0;",
		"            }",
		"",
		"            result.digits.push_back(diff);",
		"        }",
		"",
		"        result.normalize();",
		"        return result;",
		"    }",
		"",
		"    BigInt operator*(const BigInt& other) const {",
		"        BigInt result;",
		"        result.negative = negative ^ other.negative;",
		"        result.digits.assign(digits.size() + other.digits.size(), 0);",
		"",
		"        for (size_t i = 0; i < digits.size(); i++) {",
		"            for (size_t j = 0; j < other.digits.size(); j++) {",
		"                long long prod = 1LL * digits[i] * other.digits[j];",
		"                result.digits[i + j] += prod;",
		"",
		"                if (result.digits[i + j] >= BASE) {",
		"                    result.digits[i + j + 1] += result.digits[i + j] / BASE;",
		"                    result.digits[i + j] %= BASE;",
		"                }",
		"            }",
		"        }",
		"",
		"        result.normalize();",
		"        return result;",
		"    }",
		"",
		"    BigInt operator/(const BigInt& other) const {",
		"        if (other.is_zero()) throw invalid_argument(\"Division by zero\");",
		"",
		"        if (compare_abs(other) < 0) {",
		"            return BigInt(0);",
		"        }",
		"",
		"        BigInt result;",
		"        result.negative = negative ^ other.negative;",
		"        result.digits.clear();",
		"",
		"        BigInt dividend;",
		"        BigInt divisor = other.abs();",
		"",
		"        for (int i = digits.size() - 1; i >= 0; i--) {",
		"            dividend = dividend * BASE + digits[i];",
		"",
		"            int quotient = 0;",
		"            if (dividend.compare_abs(divisor) >= 0) {",
		"                int left = 0, right = BASE - 1;",
		"                while (left <= right) {",
		"                    int mid = (left + right) / 2;",
		"                    BigInt temp = divisor * mid;",
		"                    if (temp.compare_abs(dividend) <= 0) {",
		"                        quotient = mid;",
		"                        left = mid + 1;",
		"                    } else {",
		"                        right = mid - 1;",
		"                    }",
		"                }",
		"                dividend = dividend - divisor * quotient;",
		"            }",
		"",
		"            result.digits.push_back(quotient);",
		"        }",
		"",
		"        reverse(result.digits.begin(), result.digits.end());",
		"        result.normalize();",
		"        return result;",
		"    }",
		"",
		"    BigInt operator%(const BigInt& other) const {",
		"        if (other.is_zero()) throw invalid_argument(\"Modulo by zero\");",
		"",
		"        BigInt quotient = *this / other;",
		"        BigInt remainder = *this - quotient * other;",
		"",
		"        if (remainder.negative && !other.negative) {",
		"            remainder = remainder + other;",
		"        } else if (!remainder.negative && other.negative) {",
		"            remainder = remainder + other;",
		"        }",
		"",
		"        return remainder;",
		"    }",
		"",
		"    // =================== 高精度 + 低精度（优化版本）===================",
		"",
		"    template <typename T>",
		"    BigInt operator+(T x) const",
		"        requires integral<T>",
		"    {",
		"        if (x == 0) return *this;",
		"",
		"        bool x_negative = x < 0;",
		"        x = std::abs(x);",
		"",
		"        if (negative != x_negative) {",
		"            return negative ? BigInt(x) - (-*this) : *this - BigInt(x);",
		"        }",
		"",
		"        BigInt result = *this;",
		"        int carry = x;",
		"",
		"        for (size_t i = 0; i < result.digits.size() && carry; i++) {",
		"            result.digits[i] += carry;",
		"            carry = result.digits[i] / BASE;",
		"            result.digits[i] %= BASE;",
		"        }",
		"",
		"        while (carry) {",
		"            result.digits.push_back(carry % BASE);",
		"            carry /= BASE;",
		"        }",
		"",
		"        result.normalize();",
		"        return result;",
		"    }",
		"",
		"    template <typename T>",
		"    BigInt operator-(T x) const",
		"        requires integral<T>",
		"    {",
		"        return *this + (-x);",
		"    }",
		"",
		"    template <typename T>",
		"    BigInt operator*(T x) const",
		"        requires integral<T>",
		"    {",
		"        if (x == 0) return BigInt(0);",
		"",
		"        BigInt result;",
		"        result.negative = negative ^ (x < 0);",
		"        result.digits.clear();",
		"",
		"        x = std::abs(x);",
		"        long long carry = 0;",
		"",
		"        for (int digit : digits) {",
		"            carry += 1LL * digit * x;",
		"            result.digits.push_back(carry % BASE);",
		"            carry /= BASE;",
		"        }",
		"",
		"        while (carry) {",
		"            result.digits.push_back(carry % BASE);",
		"            carry /= BASE;",
		"        }",
		"",
		"        result.normalize();",
		"        return result;",
		"    }",
		"",
		"    template <typename T>",
		"    BigInt operator/(T x) const",
		"        requires integral<T>",
		"    {",
		"        if (x == 0) throw invalid_argument(\"Division by zero\");",
		"",
		"        BigInt result;",
		"        result.negative = negative ^ (x < 0);",
		"        result.digits.clear();",
		"",
		"        x = std::abs(x);",
		"        long long remainder = 0;",
		"",
		"        for (int i = digits.size() - 1; i >= 0; i--) {",
		"            remainder = remainder * BASE + digits[i];",
		"            result.digits.push_back(remainder / x);",
		"            remainder %= x;",
		"        }",
		"",
		"        reverse(result.digits.begin(), result.digits.end());",
		"        result.normalize();",
		"        return result;",
		"    }",
		"",
		"    template <typename T>",
		"    T operator%(T x) const",
		"        requires integral<T>",
		"    {",
		"        if (x == 0) throw invalid_argument(\"Modulo by zero\");",
		"",
		"        x = std::abs(x);",
		"        long long remainder = 0;",
		"",
		"        for (int i = digits.size() - 1; i >= 0; i--) {",
		"            remainder = (remainder * BASE + digits[i]) % x;",
		"        }",
		"",
		"        return negative ? -remainder : remainder;",
		"    }",
		"",
		"    // =================== 支持交换律 ===================",
		"    template <typename T>",
		"    friend BigInt operator+(T x, const BigInt& big)",
		"        requires integral<T>",
		"    {",
		"        return big + x;",
		"    }",
		"",
		"    template <typename T>",
		"    friend BigInt operator*(T x, const BigInt& big)",
		"        requires integral<T>",
		"    {",
		"        return big * x;",
		"    }",
		"",
		"    // =================== 复合赋值运算符 ===================",
		"    BigInt& operator+=(const BigInt& other) {",
		"        return *this = *this + other;",
		"    }",
		"    BigInt& operator-=(const BigInt& other) {",
		"        return *this = *this - other;",
		"    }",
		"    BigInt& operator*=(const BigInt& other) {",
		"        return *this = *this * other;",
		"    }",
		"    BigInt& operator/=(const BigInt& other) {",
		"        return *this = *this / other;",
		"    }",
		"    BigInt& operator%=(const BigInt& other) {",
		"        return *this = *this % other;",
		"    }",
		"",
		"    template <typename T>",
		"    BigInt& operator+=(T x)",
		"        requires integral<T>",
		"    {",
		"        return *this = *this + x;",
		"    }",
		"    template <typename T>",
		"    BigInt& operator-=(T x)",
		"        requires integral<T>",
		"    {",
		"        return *this = *this - x;",
		"    }",
		"    template <typename T>",
		"    BigInt& operator*=(T x)",
		"        requires integral<T>",
		"    {",
		"        return *this = *this * x;",
		"    }",
		"    template <typename T>",
		"    BigInt& operator/=(T x)",
		"        requires integral<T>",
		"    {",
		"        return *this = *this / x;",
		"    }",
		"",
		"    // =================== 工具函数 ===================",
		"    BigInt operator-() const {",
		"        BigInt result = *this;",
		"        if (!result.is_zero()) result.negative = !result.negative;",
		"        return result;",
		"    }",
		"",
		"    BigInt abs() const {",
		"        BigInt result = *this;",
		"        result.negative = false;",
		"        return result;",
		"    }",
		"",
		"    bool is_zero() const {",
		"        return digits.size() == 1 && digits[0] == 0;",
		"    }",
		"    bool is_even() const {",
		"        return (digits[0] % 2) == 0;",
		"    }",
		"    bool is_odd() const {",
		"        return (digits[0] % 2) == 1;",
		"    }",
		"",
		"    // 快速幂",
		"    template <typename T>",
		"    BigInt power(T exp) const",
		"        requires integral<T>",
		"    {",
		"        if (exp == 0) return BigInt(1);",
		"        if (exp == 1) return *this;",
		"        if (exp < 0) throw invalid_argument(\"Negative exponent\");",
		"",
		"        BigInt result = power(exp / 2);",
		"        result *= result;",
		"        if (exp & 1) result *= *this;",
		"        return result;",
		"    }",
		"",
		"    // 最大公约数",
		"    BigInt gcd(const BigInt& other) const {",
		"        if (other.is_zero()) return this->abs();",
		"        return other.gcd(*this % other);",
		"    }",
		"",
		"    // 快速模幂：(this^exp) % mod",
		"    template <typename T>",
		"    BigInt power_mod(T exp, const BigInt& mod) const",
		"        requires integral<T>",
		"    {",
		"        if (mod == BigInt(1)) return BigInt(0);",
		"",
		"        BigInt result(1);",
		"        BigInt base = *this % mod;",
		"",
		"        while (exp > 0) {",
		"            if (exp & 1) {",
		"                result = (result * base) % mod;",
		"            }",
		"            base = (base * base) % mod;",
		"            exp >>= 1;",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // =================== 输入输出 ===================",
		"    string to_string() const {",
		"        if (digits.empty()) return \"0\";",
		"",
		"        string result;",
		"        if (negative) result += \"-\";",
		"",
		"        result += std::to_string(digits.back());",
		"        for (int i = digits.size() - 2; i >= 0; i--) {",
		"            string part = std::to_string(digits[i]);",
		"            result += string(WIDTH - part.length(), '0') + part;",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    friend ostream& operator<<(ostream& os, const BigInt& num) {",
		"        return os << num.to_string();",
		"    }",
		"",
		"    friend istream& operator>>(istream& is, BigInt& num) {",
		"        string s;",
		"        is >> s;",
		"        num = BigInt(s);",
		"        return is;",
		"    }",
		"",
		"    // =================== 静态工具函数 ===================",
		"",
		"    // 阶乘",
		"    static BigInt factorial(int n) {",
		"        BigInt result(1);",
		"        for (int i = 2; i <= n; i++) {",
		"            result *= i;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 组合数C(n,k) - 优化版本",
		"    static BigInt combination(int n, int k) {",
		"        if (k > n || k < 0) return BigInt(0);",
		"        if (k == 0 || k == n) return BigInt(1);",
		"",
		"        k = min(k, n - k);  // 优化：选择较小的k",
		"        BigInt numerator(1), denominator(1);",
		"        for (int i = 0; i < k; i++) {",
		"            numerator *= (n - i);    // 高精×低精",
		"            denominator *= (i + 1);  // 高精×低精",
		"        }",
		"        return numerator / denominator;  // 高精÷高精",
		"    }",
		"",
		"    // 整数平方根",
		"    BigInt sqrt() const {",
		"        if (negative) throw invalid_argument(\"Square root of negative number\");",
		"        if (is_zero()) return BigInt(0);",
		"",
		"        BigInt left(1), right = *this;",
		"        BigInt result(1);",
		"",
		"        while (left <= right) {",
		"            BigInt mid = (left + right) / BigInt(2);",
		"            BigInt square = mid * mid;",
		"",
		"            if (square <= *this) {",
		"                result = mid;",
		"                left = mid + BigInt(1);",
		"            } else {",
		"                right = mid - BigInt(1);",
		"            }",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 静态开方函数（支持外部调用）",
		"    static BigInt sqrt_bigint(const BigInt& n) {",
		"        return n.sqrt();",
		"    }",
		"",
		"    // =================== 实用应用函数 ===================",
		"",
		"    // 大数阶乘除法",
		"    static BigInt factorial_div(int n, int k) {",
		"        BigInt result(1);",
		"        for (int i = 1; i <= n; i++) {",
		"            result *= i;",
		"        }",
		"        return result / k;  // 高精÷低精，O(n)",
		"    }",
		"",
		"    // Catalan数：C_n = C(2n,n)/(n+1)",
		"    static BigInt catalan(int n) {",
		"        return combination(2 * n, n) / (n + 1);",
		"    }",
		"",
		"    // 斐波那契数列第n项",
		"    static BigInt fibonacci(int n) {",
		"        if (n <= 1) return BigInt(n);",
		"",
		"        BigInt a(0), b(1);",
		"        for (int i = 2; i <= n; i++) {",
		"            BigInt temp = a + b;",
		"            a = b;",
		"            b = temp;",
		"        }",
		"        return b;",
		"    }",
		"};",
	})
}),

-- 12_Utilities\Fraction.h
s("12_utilities_fraction_h", {
	t({
		"/**",
		" * 分数类",
		" * 时间复杂度：四则运算O(log(min(a,b)))，化简O(log(min(a,b)))",
		" * 空间复杂度：O(1)",
		" * 适用场景：精确分数运算、有理数计算",
		" */",
		"struct Fraction {",
		"    long long num, den;  // 分子，分母",
		"",
		"    Fraction() : num(0), den(1) {}",
		"    Fraction(long long n) : num(n), den(1) {}",
		"    Fraction(long long n, long long d) : num(n), den(d) {",
		"        if (den < 0) {",
		"            num = -num;",
		"            den = -den;",
		"        }",
		"        reduce();",
		"    }",
		"",
		"    // 约分",
		"    void reduce() {",
		"        if (den == 0) { throw invalid_argument(\"Denominator cannot be zero\"); }",
		"        long long g = gcd(std::abs(num), std::abs(den));",
		"        num /= g;",
		"        den /= g;",
		"    }",
		"",
		"    // 运算符重载",
		"    Fraction operator+(const Fraction& other) const {",
		"        return Fraction(num * other.den + other.num * den, den * other.den);",
		"    }",
		"",
		"    Fraction operator-(const Fraction& other) const {",
		"        return Fraction(num * other.den - other.num * den, den * other.den);",
		"    }",
		"",
		"    Fraction operator*(const Fraction& other) const { return Fraction(num * other.num, den * other.den); }",
		"",
		"    Fraction operator/(const Fraction& other) const {",
		"        if (other.num == 0) { throw invalid_argument(\"Division by zero\"); }",
		"        return Fraction(num * other.den, den * other.num);",
		"    }",
		"",
		"    Fraction operator-() const { return Fraction(-num, den); }",
		"",
		"    Fraction& operator+=(const Fraction& other) { return *this = *this + other; }",
		"    Fraction& operator-=(const Fraction& other) { return *this = *this - other; }",
		"    Fraction& operator*=(const Fraction& other) { return *this = *this * other; }",
		"    Fraction& operator/=(const Fraction& other) { return *this = *this / other; }",
		"",
		"    // 比较运算符",
		"    bool operator==(const Fraction& other) const { return num * other.den == other.num * den; }",
		"    bool operator!=(const Fraction& other) const { return !(*this == other); }",
		"    bool operator<(const Fraction& other) const { return num * other.den < other.num * den; }",
		"    bool operator<=(const Fraction& other) const { return *this < other || *this == other; }",
		"    bool operator>(const Fraction& other) const { return !(*this <= other); }",
		"    bool operator>=(const Fraction& other) const { return !(*this < other); }",
		"",
		"    // 工具函数",
		"    Fraction abs() const { return Fraction(std::abs(num), den); }",
		"",
		"    Fraction reciprocal() const {",
		"        if (num == 0) { throw invalid_argument(\"Cannot take reciprocal of zero\"); }",
		"        return Fraction(den, num);",
		"    }",
		"",
		"    double to_double() const { return (double)num / den; }",
		"",
		"    string to_string() const {",
		"        if (den == 1) { return std::to_string(num); }",
		"        return std::to_string(num) + \"/\" + std::to_string(den);",
		"    }",
		"",
		"    bool is_integer() const { return den == 1; }",
		"    bool is_zero() const { return num == 0; }",
		"    bool is_positive() const { return num > 0; }",
		"    bool is_negative() const { return num < 0; }",
		"",
		"    // 连分数表示",
		"    vector<long long> to_continued_fraction() const {",
		"        vector<long long> result;",
		"        long long a = num, b = den;",
		"",
		"        while (b != 0) {",
		"            result.push_back(a / b);",
		"            long long temp = a % b;",
		"            a = b;",
		"            b = temp;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    static Fraction from_continued_fraction(const vector<long long>& cf) {",
		"        if (cf.empty()) return Fraction(0);",
		"",
		"        Fraction result(cf.back());",
		"        for (int i = cf.size() - 2; i >= 0; i--) { result = result.reciprocal() + Fraction(cf[i]); }",
		"        return result;",
		"    }",
		"",
		"    static Fraction approximate(double x, long long max_denominator = 1000000) {",
		"        if (std::abs(x) < 1e-15) return Fraction(0);",
		"",
		"        bool negative = x < 0;",
		"        if (negative) x = -x;",
		"",
		"        long long best_num = 1, best_den = 1;",
		"        double best_error = std::abs(x - 1.0);",
		"",
		"        for (long long den = 1; den <= max_denominator; den++) {",
		"            long long num = (long long)round(x * den);",
		"            double error = std::abs(x - (double)num / den);",
		"",
		"            if (error < best_error) {",
		"                best_error = error;",
		"                best_num = num;",
		"                best_den = den;",
		"",
		"                if (error < 1e-15) break;",
		"            }",
		"        }",
		"",
		"        return Fraction(negative ? -best_num : best_num, best_den);",
		"    }",
		"",
		"    Fraction power(long long exp) const {",
		"        if (exp == 0) return Fraction(1);",
		"        if (exp < 0) return reciprocal().power(-exp);",
		"",
		"        Fraction result(1);",
		"        Fraction base = *this;",
		"",
		"        while (exp > 0) {",
		"            if (exp & 1) result *= base;",
		"            base *= base;",
		"            exp >>= 1;",
		"        }",
		"        return result;",
		"    }",
		"",
		"    friend ostream& operator<<(ostream& os, const Fraction& f) { return os << f.to_string(); }",
		"",
		"    friend istream& operator>>(istream& is, Fraction& f) {",
		"        string input;",
		"        is >> input;",
		"",
		"        size_t slash_pos = input.find('/');",
		"        if (slash_pos != string::npos) {",
		"            long long n = stoll(input.substr(0, slash_pos));",
		"            long long d = stoll(input.substr(slash_pos + 1));",
		"            f = Fraction(n, d);",
		"        } else {",
		"            long long n = stoll(input);",
		"            f = Fraction(n);",
		"        }",
		"        return is;",
		"    }",
		"};",
		"",
		"// 数学函数命名空间",
		"namespace FractionMath {",
		"// 计算两个分数的最大公约数",
		"Fraction gcd(const Fraction& a, const Fraction& b) {",
		"    if (b.is_zero()) return a.abs();",
		"    return gcd(b, Fraction(a.num * b.den - b.num * a.den, a.den * b.den));",
		"}",
		"",
		"// 计算两个分数的最小公倍数",
		"Fraction lcm(const Fraction& a, const Fraction& b) { return (a * b).abs() / gcd(a, b); }",
		"",
		"// 分数的阶乘（仅对正整数）",
		"Fraction factorial(long long n) {",
		"    if (n < 0) throw invalid_argument(\"Factorial of negative number\");",
		"",
		"    Fraction result(1);",
		"    for (long long i = 2; i <= n; i++) { result *= Fraction(i); }",
		"    return result;",
		"}",
		"",
		"// 组合数C(n, k)",
		"Fraction combination(long long n, long long k) {",
		"    if (k > n || k < 0) return Fraction(0);",
		"    if (k == 0 || k == n) return Fraction(1);",
		"",
		"    k = min(k, n - k);  // 优化计算",
		"",
		"    Fraction result(1);",
		"    for (long long i = 0; i < k; i++) {",
		"        result *= Fraction(n - i);",
		"        result /= Fraction(i + 1);",
		"    }",
		"    return result;",
		"}",
		"}",
	})
}),

}
