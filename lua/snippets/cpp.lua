local ls = require("luasnip") -- 引入 LuaSnip

-- 定义一些快捷函数
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node
local d = ls.dynamic_node
local sn = ls.snippet_node
ls.add_snippets("cpp", {
    s("acm", {
        t({ "#include <bits/stdc++.h>",
            "using i64 = long long;",
            "using namespace std;" ,
            "",
            "int main() {",
            "\tcin.tie(nullptr);",
            "\tios::sync_with_stdio(false);",
            "",
            "\t" }), i(1),
        t({ "", "",
            "\treturn 0;",
            "",
            "}" }),
    }),
    s("acms", {
        t({ "#include <bits/stdc++.h>",
            "using i64 = long long;",
            "using namespace std;" ,
            "" }),
        t({ "", "void solve() {" }),
        t({ "", "\t" }), i(1, ""),
        t({ "", "}", "" }),
        t({ "", "int main() {",
            "\tcin.tie(nullptr);",
            "\tios::sync_with_stdio(false);" }),
        t({ "", "\tint t; cin >> t;" }),
        t({ "", "\twhile (t--) { solve(); }" }),
        t({ "", "\treturn 0;", }),
        t({ "", "}" }),
    }),
    s("DSU", {
        t({ "struct DSU {",
            "\tstd::vector<int> f, siz;",
            "\t",
            "\tDSU() {}",
            "\tDSU(int n) {",
            "\t\tinit(n);",
            "\t}",
            "\tvoid init(int n) {",
            "\t\tf.resize(n);",
            "\t\tstd::iota(f.begin(), f.end(), 0);",
            "\t\tsiz.assign(n, 1);",
            "\t}",
            "\tint find(int x) {",
            "\t\twhile (x != f[x]) {",
            "\t\t\tx = f[x] = f[f[x]];",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "\tbool same(int x, int y) {",
            "\t\treturn find(x) == find(y);",
            "\t}",
            "\tbool merge(int x, int y) {",
            "\t\tx = find(x);",
            "\t\ty = find(y);",
            "\t\tif (x == y) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\tsiz[x] += siz[y];",
            "\t\tf[y] = x;",
            "\t\treturn true;",
            "\t}",
            "\tint size(int x) {",
            "\t\treturn siz[find(x)];",
            "\t}",
            "};", })
    }),
    s("FenwickTree", {
        t({
                "template<typename T>",
                "struct FenwickTree {",
                "    vector<T> a;",
                "    int n;",
                "",
                "    FenwickTree(int size) : n(size) {",
                "        a.assign(n, 0);",
                "    }",
                "",
                "    int lowbit(int x) {",
                "        return x & -x;",
                "    }",
                "",
                "    void update(int x, T d) {",
                "        while (x <= n) {",
                "            a[x] += d;",
                "            x += lowbit(x);",
                "        }",
                "    }",
                "",
                "    T query(int x) {",
                "        T res = 0;",
                "        while (x > 0) {",
                "            res += a[x];",
                "            x -= lowbit(x);",
                "        }",
                "        return res;",
                "    }",
                "};"
        })
    }),
    s("LazySegmentTree", {
        t({
            "template<class Info, class Tag>",
            "struct LazySegmentTree {",
            "    int n;",
            "    vector<Info> info;",
            "    vector<Tag> tag;",
            "    LazySegmentTree() : n(0) {}",
            "    LazySegmentTree(int n_, Info v_ = Info()) {",
            "        init(n_, v_);",
            "    }",
            "    void init(int n_, Info v_ = Info()) {",
            "        init(vector(n_, v_));",
            "    }",
            "    template<class T>",
            "    LazySegmentTree(vector<T> init_) {",
            "        init(init_);",
            "    }",
            "    template<class T>",
            "    void init(vector<T> init_) {",
            "        n = init_.size();",
            "        info.assign(4 << __lg(n), Info());",
            "        tag.assign(4 << __lg(n), Tag());",
            "        function<void(int, int, int)> build = [&](int p, int l, int r) {",
            "            if (r - l == 1) {",
            "                info[p] = init_[l];",
            "                return;",
            "            }",
            "            int m = (l + r) >> 1;",
            "            build(p << 1, l, m);",
            "            build(p << 1 | 1, m, r);",
            "            pull(p);",
            "        };",
            "        build(1, 0, n);",
            "    }",
            "    void pull(int p) {",
            "        info[p] = info[p << 1] + info[p << 1 | 1];",
            "    }",
            "    void apply(int p, const Tag & v) {",
            "        info[p].apply(v);",
            "        tag[p].apply(v);",
            "    }",
            "    void push(int p) {",
            "        apply(p << 1, tag[p]);",
            "        apply(p << 1 | 1, tag[p]);",
            "        tag[p] = Tag();",
            "    }",
            "    Info rangeQuery(int p, int l, int r, int x, int y) {",
            "        if (l >= y || r <= x) {",
            "            return Info();",
            "        }",
            "        if (l >= x && r <= y) {",
            "            return info[p];",
            "        }",
            "        int m  = (l + r) >> 1;",
            "        push(p);",
            "        return rangeQuery(p << 1, l, m, x, y) + rangeQuery(p << 1 | 1, m, r, x, y);",
            "    }",
            "    Info rangeQuery(int l, int r) {",
            "        return rangeQuery(1, 0, n, l, r);",
            "    }",
            "    void rangeApply(int p, int l, int r, int x, int y, const Tag & v) {",
            "        if (l >= y || r <= x) {",
            "            return;",
            "        }",
            "        if (x <= l && r <= y) {",
            "            apply(p, v);",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        push(p);",
            "        rangeApply(p << 1, l, m, x, y, v);",
            "        rangeApply(p << 1 | 1, m, r, x, y, v);",
            "        pull(p);",
            "    }",
            "    void rangeApply(int l, int r, const Tag & v) {",
            "        rangeApply(1, 0, n, l, r, v);",
            "    }",
            "};",
            "struct Tag {",
            "    int add = 0;",
            "    void apply(const Tag & t) & {",
            "        add += t.add;",
            "    }",
            "};",
            "struct Info {",
            "    i64 sum = 0;",
            "    int len = 1;",
            "    Info () {}",
            "    Info (i64 sum_, int len_ = 1) : sum(sum_), len(len_) {}",
            "    void apply(const Tag & t) & {",
            "        sum += t.add * len;",
            "    }",
            "};",
            "Info operator+(const Info & a, const Info & b) {",
            "    return {a.sum + b.sum, a.len + b.len};",
            "}"
        })
    }),
})
