local ls = require("luasnip")

-- 定义一些快捷函数
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node
local c = ls.choice_node

return {
    s("ds", {
        t({
            "#include <iostream>",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "",
        }),
        t({
            "int main()",
            "{",
            "	solve();",
            "	return 0;",
            "}"
        }),
        i(0)
    }),

    s("dss", {
        t({
            "#include <iostream>",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "",
        }),
        t({
            "int main()",
            "{",
            "	int t;",
            "	for (cin >> t; t --; )",
            "		solve();",
            "	return 0;",
            "}"
        }),
        i(0)
    }),

    s("normal", {
        t({
            "#include <bits/stdc++.h>",
            "#define int long long",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "signed main()",
            "{",
            "	IOS;",
            "	solve();",
            "	return 0;",
            "}"
        }),
        i(0)
    }),

    s("normals", {
        t({
            "#include <bits/stdc++.h>",
            "#define int long long",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "signed main()",
            "{",
            "	IOS;",
            "	int t;",
            "	for (cin >> t; t --; )",
            "		solve();",
            "	return 0;",
            "}"
        }),
        i(0)
    }),

    s("normalcase", {
        t({
            "#include <bits/stdc++.h>",
            "#define int long long",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "signed main()",
            "{",
            "	IOS;",
            "	int t;",
            "	cin >> t;",
            "	for (int i = 1; i <= t; i ++)",
            "	{",
            "		cout << \"Case \" << i << \": \";",
            "		solve();",
            "	}",
            "	return 0;",
            "}"

        }),
        i(0)
    }),

    s("headers", {
        t({
            "#include <iostream>",
            "#include <algorithm>",
            "#include <string.h>",
            "#include <sstream>",
            "#include <cctype>",
            "#include <string>",
            "#include <iomanip>",
            "#include <cmath>",
            "#include <vector>",
            "#include <queue>",
            "#include <deque>",
            "#include <stack>",
            "#include <map>",
            "#include <set>",
        }),
    }),

    s("DSU", {
        t({ "struct DSU",
            "{",
            "   vector<int> f, siz;",
            "   ",
            "   DSU() {}",
            "   DSU(int n) {init(n);}",
            "   ",
            "   void init(int n) ",
            "   {",
            "       f.resize(n + 1);",
            "       iota(f.begin(), f.end(), 0);",
            "       siz.assign(n + 1, 1);",
            "   }",
            "   ",
            "   int find(int x) ",
            "   {",
            "       while (x != f[x])",
            "           x = f[x] = f[f[x]];",
            "       return x;",
            "   }",
            "   ",
            "   bool same(int x, int y) {return find(x) == find(y);}",
            "   ",
            "   bool merge(int x, int y) ",
            "   {",
            "       x = find(x);",
            "       y = find(y);",
            "       if (x == y) ",
            "           return false;",
            "       siz[x] += siz[y];",
            "       f[y] = x;",
            "       return true;",
            "   }",
            "   ",
            "   int size(int x) {return siz[find(x)];}",
            "};" })
    }),

    s("qpow", {
        t({ "long long qpow(long long a, long long b)",
            "{",
            "	long long tmp = 1;",
            "	while (b)",
            "	{",
            "		if (b & 1)",
            "			tmp *= a;",
            "		a *= a;",
            "		b >>= 1;",
            "	}",
            "	return tmp;",
            "}" })
    }),

    s("qpowM", {
        t({ "long long qpow(long long a, long long b)",
            "{",
            "	long long tmp = 1;",
            "	a %= MOD;",
            "	while (b)",
            "	{",
            "		if (b & 1)",
            "			tmp = tmp * a % MOD;",
            "		a = a * a % MOD;",
            "		b >>= 1;",
            "	}",
            "	return tmp;",
            "}",
            "long long inv(long long x) { return qpow(x, MOD - 2);}" })
    }),

    s("Dijkstra", {
        t({ "",
            "struct GRA",
            "{",
            "	int n;",
            "	vector<bool> vis;",
            "	vector<int> dist, p;",
            "	vector<vector<pair<int, int>>> adj;",
            "	GRA(int n_) {init(n_);}",
            "	void init(int n_)",
            "	{",
            "		n = n_;",
            "		adj.resize(n + 1);",
            "		p.resize(n + 1, -1);",
            "		dist.resize(n + 1, inf);",
            "		vis.resize(n + 1, false);",
            "	}",
            "	vector<int> find_path(int x)",
            "	{",
            "		vector<int> path;",
            "		while (p[x] != -1)",
            "		{",
            "			path.push_back(x);",
            "			x = p[x];",
            "		}",
            "		return vector<int>(rall(path));",
            "	}",
            "	struct cmp {bool operator()(const pair<int, int> x, pair<int, int> y) const {return x.second > y.second;}};",
            "	void dijkstra(int u)",
            "	{",
            "		priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;",
            "		dist[u] = 0;",
            "		q.push({u, dist[u]});",
            "		while (!q.empty())",
            "		{",
            "			auto [pre, dis] = q.top();  q.pop();",
            "			if (vis[pre])   continue;",
            "			vis[pre] = true;",
            "			for (auto [to, val] : adj[pre])",
            "			{",
            "				if (!vis[to] && dis + val < dist[to])",
            "				{",
            "					dist[to] = dist[pre] + val;",
            "					p[to] = pre;",
            "					q.push({to, dist[to]});",
            "				}",
            "			}",
            "		}",
            "	}",
            "};",
            "" })
    }),

    s("ChainBuild", {
        t({ "struct ChainBuild",
            "{",
            "   int n, m, cnt = 1;",
            "   vector<int> head;",
            "   vector<int> nxt;",
            "   vector<int> to;",
            "   vector<int> val;",
            "",
            "   ChainBuild() {}",
            "   ChainBuild(int n_) : n(n_), m(2 * n_) { init(); }",
            "   ChainBuild(int n_, int m_) : n(n_), m(2 * m_) { init(); }",
            "",
            "   void init()",
            "   {",
            "       head.resize(n + 1, 0);",
            "       nxt.resize(m + 1);",
            "       to.resize(m + 1);",
            "       val.resize(m + 1);",
            "   }",
            "",
            "   void clear()",
            "   {",
            "       cnt = 1;",
            "       head.resize(n + 1, 0);",
            "   }",
            "",
            "   void addEdge(int u, int v, int w = 0)",
            "   {",
            "       nxt[cnt] = head[u];",
            "       to[cnt] = v;",
            "       val[cnt] = w;",
            "       head[u] = cnt ++;",
            "   }",
            "};" })
    }),

    s("TreeChain", {
        t({
            "struct TreeChain",
            "{",
            "   int cnt;",
            "   vector<int> fa, son, dep, siz, top, dfn, sge;",
            "",
            "   TreeChain(int n) : fa(n + 2), son(n + 2, 0), dep(n + 2, 0), siz(n + 2), top(n + 2), dfn(n + 2), sge(n + 2), cnt(0) {}",
            "",
            "   void dfs1(ChainBuild &e, int u, int f)",
            "   {",
            "       fa[u] = f;",
            "       dep[u] = dep[f] + 1;",
            "       siz[u] = 1;",
            "",
            "       for (int ei = e.head[u]; ei; ei = e.nxt[ei])",
            "       {",
            "           int v = e.to[ei];",
            "           if (v == f)",
            "               continue;",
            "           dfs1(e, v, u);",
            "           siz[u] += siz[v];",
            "           if (siz[v] > siz[son[u]])",
            "               son[u] = v;",
            "       }",
            "   }",
            "",
            "   void dfs2(ChainBuild &e, int u, int t)",
            "   {",
            "       dfn[u] = ++ cnt;",
            "       sge[cnt] = u;",
            "       top[u] = t;",
            "",
            "       if (!son[u])",
            "           return;",
            "       dfs2(e, son[u], t);",
            "",
            "       for (int ei = e.head[u]; ei; ei = e.nxt[ei])",
            "       {",
            "           int v = e.to[ei];",
            "           if (v != fa[u] && v != son[u])",
            "               dfs2(e, v, v);",
            "       }",
            "   }",
            "",
            "   void build(ChainBuild &e, int root)",
            "   {",
            "       dfs1(e, root, 0);",
            "       dfs2(e, root, root);",
            "   }",
            "",
            "   void modifyPath(SegTree<Info, Laz> &seg, int u, int v, Laz tag)",
            "   {",
            "       while (top[u] != top[v])",
            "       {",
            "           if (dep[top[u]] < dep[top[v]])",
            "               swap(u, v);",
            "           seg.modify(dfn[top[u]], dfn[u], tag);",
            "           u = fa[top[u]];",
            "       }",
            "       if (dep[u] > dep[v])",
            "           swap(u, v);",
            "       seg.modify(dfn[u], dfn[v], tag);",
            "   }",
            "",
            "   Info queryPath(SegTree<Info, Laz> &seg, int u, int v)",
            "   {",
            "       Info res;",
            "       while (top[u] != top[v])",
            "       {",
            "           if (dep[top[u]] < dep[top[v]])",
            "               swap(u, v);",
            "           res = res + seg.query(dfn[top[u]], dfn[u]);",
            "           u = fa[top[u]];",
            "       }",
            "       if (dep[u] > dep[v])",
            "           swap(u, v);",
            "       return res + seg.query(dfn[u], dfn[v]);",
            "   }",
            "",
            "   void modifySubtree(SegTree<Info, Laz> &seg, int u, Laz tag)",
            "   {",
            "       seg.modify(dfn[u], dfn[u] + siz[u] - 1, tag);",
            "   }",
            "",
            "   Info querySubtree(SegTree<Info, Laz> &seg, int u)",
            "   {",
            "       return seg.query(dfn[u], dfn[u] + siz[u] - 1);",
            "   }",
            "",
            "   int lca(int u, int v)",
            "   {",
            "       while (top[u] != top[v])",
            "       {",
            "           if (dep[top[u]] >= dep[top[v]])",
            "               u = fa[top[u]];",
            "           else",
            "               v = fa[top[v]];",
            "       }",
            "       return (dfn[u] <= dfn[v] ? u : v);",
            "   }",
            "};"
        })
    })
}
