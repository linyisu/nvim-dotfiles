local ls = require("luasnip") -- 引入 LuaSnip

-- 定义一些快捷函数
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

-- 定义 C++ 代码片段
ls.add_snippets("cpp", {
	s("normal", {
		t({
			"#include <bits/stdc++.h>",
			"#define int long long",
			"#define inf 0x3f3f3f3f3f3f3f3f",
			"#define iinf 0x3f3f3f3f",
			"#define all(x) begin(x), end(x)",
			"#define rall(x) rbegin(x), rend(x)",
			"#define _endl \"\\n\"",
			"#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"using namespace std;",
			"",
			"void solve()",
			"{",
			"	"
		}),
		i(1, ""), -- 插入点 1
		t({
			"",
			"}",
			"",
			"signed main()",
			"{",
			"	IOS;",
			"	solve();",
			"	return 0;",
			"}"
		})
	}),
	s("normals", {
        t({
            "#include <bits/stdc++.h>",
            "#define int long long",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define iinf 0x3f3f3f3f",
            "#define all(x) begin(x), end(x)",
            "#define rall(x) rbegin(x), rend(x)",
            "#define _endl \"\\n\"",
            "#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "signed main()",
            "{",
            "	IOS;",
            "	int t;",
			"	for (cin >> t; t --; )",
			"		solve();",
            "	return 0;",
            "}"
        })
    }),
    s("poj", {
        t({
            "#include <iostream>",
            "#include <algorithm>",
            "#include <string.h>",
            "#include <sstream>",
            "#include <cctype>",
            "#include <string>",
            "#include <iomanip>",
			"#include <cmath>",
            "#include <vector>",
            "#include <queue>",
            "#include <deque>",
            "#include <stack>",
            "#include <map>",
            "#include <set>",
            "#define int long long",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define iinf 0x3f3f3f3f",
            "#define all(x) begin(x), end(x)",
            "#define rall(x) rbegin(x), rend(x)",
            "#define _endl \"\\n\"",
            "#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "signed main()",
            "{",
            "	int t = 1;",
            '	// scanf("%lld", &t);',
            "	while (t --)",
			"		solve();",
            "	return 0;",
            "}"
        })
	}),
	s("headInclude", {
		t({
			"#include <bits/stdc++.h>",
			"#define int long long",
			"#define inf 0x3f3f3f3f3f3f3f3f",
			"#define iinf 0x3f3f3f3f",
			"#define all(x) begin(x), end(x)",
			"#define rall(x) rbegin(x), rend(x)",
			"#define _endl \"\\n\"",
			"#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"using namespace std;"
		})
	}),
	s("main", {
		t({
			"signed main()",
			"{",
			"    IOS;",
			"    solve();",
			"    return 0;",
			"}"
		})
	}),
	s("mains", {
		t({
			"signed main()",
			"{",
			"    IOS;",
			"    int t;",
			"    for (cin >> t; t --; )",
			"        solve();",
			"    return 0;",
			"}"
		})
	}),
	s("KRUSKAL", {
		t({ "struct node",
			"{",
			"	int st, to, len;",
			"	bool operator<(const node y)  const {return len < y.len;}",
			"};",
			"void solve()",
			"{",
			"	int n, m;  cin >> n >> m;",
			"	DSU dsu(n);",
			"	vector<node> v;",
            "",
            "",
			"	sort(all(v));",
			"	auto Kruskal = [&]() -> int",
			"	{",
			"		int ans = 0, cnt = 0;",
			"		for (int i=0;i<v.size();i++)",
			"		{",
			"			auto cur = v[i];",
			"			if (!dsu.same(cur.st, cur.to))",
			"			{",
			"				cnt ++;",
			"				ans += cur.len;",
			"				dsu.merge(cur.st, cur.to);",
			"			}",
			"		}",
			"		return (cnt == n - 1 ? ans : -1);",
			"	};",
            "	auto x = Kruskal();",
			"}",
			"" })
	}),
	s("Prim", {
		t({ "struct node",
			"{",
			"	int id, val;",
			"	bool operator< (const node other) const {return val > other.val;}",
			"};",
			"",
			"void solve()",
			"{",
			"	int n, m;   cin >> n >> m;",
			"	vector<vector<node>> adj(n + 1);",
			"	for (int i=0;i<m;i++)",
			"	{",
			"		int a, b, c;",
			"		cin >> a >> b >> c;",
			"		adj[a].push_back({b, c});",
			"		adj[b].push_back({a, c});",
			"	}",
			"	auto Prim = [&]() -> int",
			"	{",
			"		vector<bool> vis(n + 1, false);",
			"		priority_queue<node> q;",
			"		q.push({1, 0});",
			"		",
			"		int ans = 0, cnt = 0;",
			"		while (!q.empty())",
			"		{",
			"			auto cur = q.top(); q.pop();",
			"			if (vis[cur.id]) continue;",
			"			cnt ++;",
			"			ans += cur.val;",
			"			vis[cur.id] = true;",
			"",
			"			for (auto [to, val] : adj[cur.id])",
			"				if (!vis[to])",
			"					q.push({to, val});",
			"		}",
			"		return (cnt == n ? ans : -1);",
			"	};",
			"	auto x = Prim();",
			"}" })
	}),
	s("Floyd", {
		t({ "for (int k=1;k<=n;k++)",
			"	for (int i=1;i<=n;i++)",
			"		for (int j=1;j<=n;j++)",
			"			if (dis[i][k] != inf && dis[k][j] != inf && dis[i][k] + dis[k][j] < dis[i][j])",
			"				dis[i][j] = dis[i][k] + dis[k][j];" })
	}),
	s("TopoSort", {
		t({ "auto TopoSort = [&]() -> vector<int>",
			"{",
			"	vector<int> arr;",
			"	vector<bool> vis(n + 1, false);",
			"	priority_queue<int> q;",
			"	for (int i=1;i<=n;i++)",
			"		if (!in[i])	q.push(i);",
			"",
			"	while (!q.empty())",
			"	{",
			"		auto x = q.top();   q.pop();",
			"		vis[x] = true;",
			"		arr.push_back(x);",
			"",
			"		for (auto to : adj[x])",
			"		{",
			"			in[to] --;",
			"			if (!in[to] && !vis[to])",
			"				q.push(to);",
			"		}",
			"	}",
			"	return arr;",
			"};" })
	}),
    s("mod", {
        t({ "const int MOD = " })
    }),
    s("pi", {
        t({ "const double pi = acos(-1);",
            "" })
    }),
    s("qpow", {
		t({ "int qpow(int a, int b)",
			"{",
			"	int tmp = 1;",
			"	a %= MOD;",
			"	while (b)",
			"	{",
			"		if (b & 1)",
			"			tmp = tmp * a % MOD;",
			"		a = a * a % MOD;",
			"		b >>= 1;",
			"	}",
			"	return tmp;",
			"}",
			"",
			"int inv(int x) { return qpow(x, MOD - 2);}" })
	}),
    s("case", {
        t({ "for (int i=1;i<=t;i++)",
            "{",
            '	cout << "Case " << i << ":" << _endl;',
            "	solve();",
            "}"})
    }),
	s("spfa", {
		t({ "auto spfa = [&](int u) -> bool",
			"	{",
			"		queue<int> q;",
			"		vector<int> updCnt(n + 5, 0);",
			"		vector<bool> enter(n + 5, false);",
			"		dist[u] = 0;",
			"		q.push(u);",
			"		enter[u] = true;",
			"",
			"		while (!q.empty())",
			"		{",
			"			auto x = q.front();   q.pop();",
			"			enter[x] = false;",
			"",
			"			for (auto [to, val] : adj[x])",
			"			{",
			"				if (val + dist[x] < dist[to])",
			"				{",
			"					dist[to] = dist[x] + val;",
			"					if (enter[x])   continue;",
			"					if (updCnt[to] ++ == n)",
			"						return true;",
			"					q.push(to);",
			"					enter[to] = true;",
			"				}",
			"			}",
			"		}",
			"		return false;",
			"	};" })
	}),
	s("Dijkstra", {
		t({ "",
			"struct GRA",
			"{",
			"	int n;",
			"	vector<bool> vis;",
			"	vector<int> dist, p;",
			"	vector<vector<pair<int, int>>> adj;",
			"	GRA(int n_) {init(n_);}",
			"	void init(int n_)",
			"	{",
			"		n = n_;",
			"		adj.resize(n + 1);",
			"		p.resize(n + 1, -1);",
			"		dist.resize(n + 1, inf);",
			"		vis.resize(n + 1, false);",
			"	}",
			"	vector<int> find_path(int x)",
			"	{",
			"		vector<int> path;",
			"		while (p[x] != -1)",
			"		{",
			"			path.push_back(x);",
			"			x = p[x];",
			"		}",
			"		return vector<int>(rall(path));",
			"	}",
			"	struct cmp {bool operator()(const pair<int, int> x, pair<int, int> y) const {return x.second > y.second;}};",
			"	void dijkstra(int u)",
			"	{",
			"		priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;",
			"		dist[u] = 0;",
			"		q.push({u, dist[u]});",
			"		while (!q.empty())",
			"		{",
			"			auto [pre, dis] = q.top();  q.pop();",
			"			if (vis[pre])   continue;",
			"			vis[pre] = true;",
			"			for (auto [to, val] : adj[pre])",
			"			{",
			"				if (!vis[to] && dis + val < dist[to])",
			"				{",
			"					dist[to] = dist[pre] + val;",
			"					p[to] = pre;",
			"					q.push({to, dist[to]});",
			"				}",
			"			}",
			"		}",
			"	}",
			"};",
			"" })
	}),
	s("segTree", {
		t({
			"template <typename T, class Info, class Laz>",
			"struct SegTree ",
			"{",
			"    int n;",
			"    vector<T> arr;",
			"    vector<Laz> laz;",
			"    vector<Info> info;",
			"",
			"    SegTree() : n(0) {}",
			"    SegTree(int n_) : n(n_), arr(n + 5), laz(4 * n), info(4 * n) {}",
			"",
			"    void build() { build(1, n, 1); }",
			"",
			"    void build(int l, int r, int u) ",
			"    {",
			"        if (l == r) ",
			"        {",
			"            info[u] = Info(arr[l]);",
			"            return;",
			"        }",
			"",
			"        int mid = (l + r) >> 1;",
			"        build(l, mid, u << 1);",
			"        build(mid + 1, r, u << 1 | 1);",
			"        push_up(u);",
			"    }",
			"",
			"    void apply(int u, Laz tag, int len) ",
			"    {",
			"        laz[u].apply(tag);",
			"        info[u].apply(tag, len);",
			"    }",
			"",
			"    void push_up(int u) { info[u] = info[u << 1] + info[u << 1 | 1]; }",
			"",
			"    void push_down(int u, int llen, int rlen) ",
			"    {",
			"        apply(u << 1, laz[u], llen);",
			"        apply(u << 1 | 1, laz[u], rlen);",
			"        laz[u] = Laz();",
			"    }",
			"",
			"    void modify(int l, int r, Laz tag) { modify(l, r, tag, 1, n, 1); }",
			"",
			"    void modify(int jobl, int jobr, Laz tag, int l, int r, int u) ",
			"    {",
			"        if (jobl <= l && jobr >= r) ",
			"        {",
			"            apply(u, tag, r - l + 1);",
			"            return;",
			"        }",
			"",
			"        int mid = (l + r) >> 1;",
			"        push_down(u, mid - l + 1, r - mid);",
			"        if (jobl <= mid) modify(jobl, jobr, tag, l, mid, u << 1);",
			"        if (jobr > mid) modify(jobl, jobr, tag, mid + 1, r, u << 1 | 1);",
			"        push_up(u);",
			"    }",
			"",
			"    Info query(int l, int r) { return query(l, r, 1, n, 1); }",
			"",
			"    Info query(int jobl, int jobr, int l, int r, int u) ",
			"    {",
			"        if (jobl <= l && jobr >= r) return info[u];",
			"",
			"        int mid = (l + r) >> 1;",
			"        push_down(u, mid - l + 1, r - mid);",
			"        if (jobl <= mid && jobr > mid) return query(jobl, jobr, l, mid, u << 1) + query(jobl, jobr, mid + 1, r, u << 1 | 1);",
			"        else if (jobl <= mid) return query(jobl, jobr, l, mid, u << 1);",
			"        else if (jobr > mid) return query(jobl, jobr, mid + 1, r, u << 1 | 1);",
			"        return Info();",
			"    }",
			"};",
			"",
			"struct Laz ",
			"{",
			"    int add = 0;",
			"    void apply(const Laz &tag) ",
			"    { ",
			"        if (tag.add)",
			"        {",
			"            add += tag.add; ",
			"        }",
			"    }",
			"};",
			"",
			"template <typename T>",
			"struct Info ",
			"{",
			"    int sum = 0;",
			"    Info() {}",
			"    Info(T x) : sum(x) {}",
			"    void apply(const Laz &tag, int len) ",
			"    {",
			"        if (tag.add) ",
			"        {",
			"            sum += tag.add * len;",
			"        }",
			"    }",
			"",
			"    Info operator+(const Info &a) const ",
			"    {",
			"        Info res;",
			"        res.sum = sum + a.sum;",
			"        return res;",
			"    }",
			"};"
		})
	}),
	s("ChainBuild", {
		t({ "struct ChainBuild",
			"{",
			"    int n, m, cnt = 1;",
			"    vector<int> head;",
			"    vector<int> nxt;",
			"    vector<int> to;",
			"    vector<int> val;",
			"",
			"    ChainBuild() {}",
			"    ChainBuild(int n_) : n(n_), m(2 * n_) { init(); }",
			"    ChainBuild(int n_, int m_) : n(n_), m(2 * m_) { init(); }",
			"",
			"    void init()",
			"    {",
			"        head.resize(n + 1, 0);",
			"        nxt.resize(m + 1);",
			"        to.resize(m + 1);",
			"        val.resize(m + 1);",
			"    }",
			"",
			"    void clear()",
			"    {",
			"        cnt = 1;",
			"        head.resize(n + 1, 0);",
			"    }",
			"",
			"    void addEdge(int u, int v, int w = 0)",
			"    {",
			"        nxt[cnt] = head[u];",
			"        to[cnt] = v;",
			"        val[cnt] = w;",
			"        head[u] = cnt ++;",
			"    }",
			"};" })
	}),
	s("DSU", {
		t({ "struct DSU",
			"{",
			"    vector<int> f, siz;",
			"    ",
			"    DSU() {}",
			"    DSU(int n) {init(n);}",
			"    ",
			"    void init(int n) ",
			"    {",
			"        f.resize(n + 1);",
			"        iota(f.begin(), f.end(), 0);",
			"        siz.assign(n + 1, 1);",
			"    }",
			"    ",
			"    int find(int x) ",
			"    {",
			"        while (x != f[x])",
			"            x = f[x] = f[f[x]];",
			"        return x;",
			"    }",
			"    ",
			"    bool same(int x, int y) {return find(x) == find(y);}",
			"    ",
			"    bool merge(int x, int y) ",
			"    {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y) ",
			"            return false;",
			"        siz[x] += siz[y];",
			"        f[y] = x;",
			"        return true;",
			"    }",
			"    ",
			"    int size(int x) {return siz[find(x)];}",
			"};" })
	}),
	s("I128", {
		t({
			"using i128 = __int128;",
			"ostream &operator<<(ostream &os, i128 n) ",
			"{",
			"    if (n == 0) { return os << 0; }",
			"    string s;",
			"    while (n > 0) ",
			"    {",
			"        s += char('0' + n % 10);",
			"        n /= 10;",
			"    }",
			"    reverse(s.begin(), s.end());",
			"    return os << s;",
			"}",
			"i128 toi128(const string &s) ",
			"{",
			"    i128 n = 0;",
			"    for (auto c : s) { n = n * 10 + (c - '0'); }",
			"    return n;",
			"}",
			"i128 sqrti128(i128 n) ",
			"{",
			"    i128 lo = 0, hi = 1e16;",
			"    while (lo < hi) ",
			"    {",
			"        i128 x = (lo + hi + 1) / 2;",
			"        if (x * x <= n) ",
			"            lo = x;",
			"        else ",
			"            hi = x - 1;",
			"    }",
			"    return lo;",
			"}",
			"i128 gcd(i128 a, i128 b) { return b ? gcd(b, a % b) : a; }"
		})
	}),
	s("FHQTreap", {
		t({
			"std::mt19937 rng(std::random_device{}());",
			"struct FHQ",
			"{",
			"    struct node",
			"    {",
			"        int l, r;",
			"        int val;",
			"        int rnd;",
			"        int siz;",
			"    };",
			"",
			"    int n;",
			"    int cur = 0, root = 0;",
			"    vector<node> fhq;",
			"",
			"    FHQ() {}",
			"    FHQ(int n_): n(n_ + 5), fhq(n) {}",
			"    int newNode(int val)",
			"    {",
			"        fhq[++ cur].val = val;",
			"        fhq[cur].rnd = rng();",
			"        fhq[cur].siz = 1;",
			"        return cur;",
			"    }",
			"    void push_up(int u) { fhq[u].siz = fhq[fhq[u].l].siz + fhq[fhq[u].r].siz + 1; }",
			"    void split(int u, int val, int &x, int &y)",
			"    {",
			"        if (u == 0)",
			"        {",
			"            x = y = 0;",
			"            return;",
			"        }",
			"        if (fhq[u].val <= val)",
			"        {",
			"            x = u;",
			"            split(fhq[u].r, val, fhq[u].r, y);",
			"        }",
			"        else",
			"        {",
			"            y = u;",
			"            split(fhq[u].l, val, x, fhq[u].l);",
			"        }",
			"        push_up(u);",
			"    }",
			"    int merge(int x, int y)",
			"    {",
			"        if (x == 0 || y == 0)",
			"            return x + y;",
			"        if (fhq[x].rnd > fhq[y].rnd)",
			"        {",
			"            fhq[x].r = merge(fhq[x].r, y);",
			"            push_up(x);",
			"            return x;",
			"        }",
			"        else",
			"        {",
			"            fhq[y].l = merge(x, fhq[y].l);",
			"            push_up(y);",
			"            return y;",
			"        }",
			"    }",
			"    void insert(int val)",
			"    {",
			"        int x, y;",
			"        split(root, val, x, y);",
			"        root = merge(merge(x, newNode(val)), y);",
			"    }",
			"    void erase(int val)",
			"    {",
			"        int x, y, z;",
			"        split(root, val, x, z);",
			"        split(x, val - 1, x, y);",
			"        y = merge(fhq[y].l, fhq[y].r);",
			"        root = merge(merge(x, y), z);",
			"    }",
			"    int rank(int u)",
			"    {",
			"        int x, y;",
			"        split(root, u - 1, x, y);",
			"        int ans = fhq[x].siz + 1;",
			"        root = merge(x, y);",
			"        return ans;",
			"    }",
			"    int index(int rank)",
			"    {",
			"        int u = root;",
			"        while (u)",
			"        {",
			"            if (fhq[fhq[u].l].siz + 1 == rank)",
			"                break;",
			"            else if (fhq[fhq[u].l].siz >= rank)",
			"                u = fhq[u].l;",
			"            else",
			"            {",
			"                rank -= fhq[fhq[u].l].siz + 1;",
			"                u = fhq[u].r;",
			"            }",
			"        }",
			"        return fhq[u].val;",
			"    }",
			"    int pre(int val)",
			"    {",
			"        int x, y;",
			"        split(root, val - 1, x, y);",
			"        int u = x;",
			"        while (fhq[u].r)",
			"            u = fhq[u].r;",
			"        int ans = fhq[u].val;",
			"        merge(x, y);",
			"        return ans;",
			"    }",
			"    int post(int val)",
			"    {",
			"        int x, y;",
			"        split(root, val, x, y);",
			"        int u = y;",
			"        while (fhq[u].l)",
			"            u = fhq[u].l;",
			"        int ans = fhq[u].val;",
			"        merge(x, y);",
			"        return ans;",
			"    }",
			"};"
		})
	}),
	s("AVL", {
		t({
			"struct AVL",
			"{",
			"    int MAX = INT_MAX;",
			"    int MIN = INT_MIN;",
			"    int n;",
			"    int head = 0, cur = 0;",
			"    vector<int> key, h, l, r, cnt, siz;",
			"    AVL(int n_): n(n_ + 1), key(n, 0), h(n, 0), ",
			"        l(n, 0), r(n, 0), cnt(n, 0), siz(n, 0) {}",
			"",
			"    void push_up(int u)",
			"    {",
			"        h[u] = max(h[l[u]], h[r[u]]) + 1;",
			"        siz[u] = siz[l[u]] + siz[r[u]] + cnt[u];",
			"    }",
			"    int leftRotate(int u)",
			"    {",
			"        int v = r[u];",
			"        r[u] = l[v];",
			"        l[v] = u;",
			"        push_up(u);",
			"        push_up(v);",
			"        return v;",
			"    }",
			"    int rightRotate(int u)",
			"    {",
			"        int v = l[u];",
			"        l[u] = r[v];",
			"        r[v] = u;",
			"        push_up(u);",
			"        push_up(v);",
			"        return v;",
			"    }",
			"    int adjust(int u)",
			"    {",
			"        int lh = h[l[u]];",
			"        int rh = h[r[u]];",
			"        if (lh - rh > 1)",
			"        {",
			"            if (h[l[l[u]]] >= h[r[l[u]]])",
			"                u = rightRotate(u);",
			"            else",
			"            {",
			"                l[u] = leftRotate(l[u]);",
			"                u = rightRotate(u);",
			"            }",
			"        }",
			"        else if (rh - lh > 1)",
			"        {",
			"            if (h[r[r[u]]] >= h[l[r[u]]])",
			"                u = leftRotate(u);",
			"            else",
			"            {",
			"                r[u] = rightRotate(r[u]);",
			"                u = leftRotate(u);",
			"            }",
			"        }",
			"        return u;",
			"    }",
			"    int small(int u, int k)",
			"    {",
			"        if (u == 0)",
			"            return 0;",
			"        if (key[u] >= k)",
			"            return small(l[u], k);",
			"        else",
			"            return siz[l[u]] + cnt[u] + small(r[u], k);",
			"    }",
			"    int index(int u, int k)",
			"    {",
			"        if (siz[l[u]] >= k)",
			"            return index(l[u], k);",
			"        else if (siz[l[u]] + cnt[u] < k)",
			"            return index(r[u], k - siz[l[u]] - cnt[u]);",
			"        return key[u];",
			"    }",
			"    int pre(int u, int k)",
			"    {",
			"        if (u == 0)",
			"            return MIN;",
			"        if (key[u] >= k)",
			"            return pre(l[u], k);",
			"        else",
			"            return max(key[u], pre(r[u], k));",
			"    }",
			"    int post(int u, int k)",
			"    {",
			"        if (u == 0)",
			"            return MAX;",
			"        if (key[u] <= k)",
			"            return post(r[u], k);",
			"        else",
			"            return min(key[u], post(l[u], k));",
			"    }",
			"    int rank(int k) { return small(head, k) + 1; }",
			"    int index(int k) { return index(head, k); }",
			"    int pre(int k) { return pre(head, k); }",
			"    int post(int k) { return post(head, k); }",
			"    void insert(int k) { head = insert(head, k); }",
			"    void erase(int k) ",
			"    {",
			"        if (rank(k) != rank(k + 1))",
			"            head = erase(head, k);",
			"    }",
			"    int insert(int u, int k)",
			"    {",
			"        if (u == 0)",
			"        {",
			"            key[++ cur] = k;",
			"            cnt[cur] = siz[cur] = h[cur] = 1;",
			"            return cur;",
			"        }",
			"        if (key[u] == k)",
			"            cnt[u] ++;",
			"        else if (key[u] > k)",
			"            l[u] = insert(l[u], k);",
			"        else",
			"            r[u] = insert(r[u], k);",
			"        push_up(u);",
			"        return adjust(u);",
			"    }",
			"    int erase(int u, int k)",
			"    {",
			"        if (key[u] < k)",
			"            r[u] = erase(r[u], k);",
			"        else if (key[u] > k)",
			"            l[u] = erase(l[u], k);",
			"        else",
			"        {",
			"            if (cnt[u] > 1)",
			"                cnt[u] --;",
			"            else",
			"            {",
			"                if (!l[u] && !r[u])",
			"                    return 0;",
			"                else if (l[u] && !r[u])",
			"                    u = l[u];",
			"                else if (!l[u] && r[u])",
			"                    u = r[u];",
			"                else",
			"                {",
			"                    int most = r[u];",
			"                    while (l[most])",
			"                        most = l[most];",
			"                    r[u] = eraseMost(r[u], most);",
			"                    l[most] = l[u];",
			"                    r[most] = r[u];",
			"                    u = most;",
			"                }",
			"            }",
			"        }",
			"        push_up(u);",
			"        return adjust(u);",
			"    }",
			"    int eraseMost(int u, int most)",
			"    {",
			"        if (u == most)",
			"            return r[u];",
			"        else",
			"        {",
			"            l[u] = eraseMost(l[u], most);",
			"            push_up(u);",
			"            return adjust(u);",
			"        }",
			"    }",
			"};"
		})
	}),
	s("TreeChain", {
		t({
			"struct TreeChain",
			"{",
			"    int cnt;",
			"    vector<int> fa, son, dep, siz, top, dfn, sge;",
			"",
			"    TreeChain(int n) : fa(n + 2), son(n + 2, 0), dep(n + 2, 0), siz(n + 2), top(n + 2), dfn(n + 2), sge(n + 2), cnt(0) {}",
			"",
			"    void dfs1(ChainBuild &e, int u, int f)",
			"    {",
			"        fa[u] = f;",
			"        dep[u] = dep[f] + 1;",
			"        siz[u] = 1;",
			"",
			"        for (int ei = e.head[u]; ei; ei = e.nxt[ei])",
			"        {",
			"            int v = e.to[ei];",
			"            if (v == f)",
			"                continue;",
			"            dfs1(e, v, u);",
			"            siz[u] += siz[v];",
			"            if (siz[v] > siz[son[u]])",
			"                son[u] = v;",
			"        }",
			"    }",
			"",
			"    void dfs2(ChainBuild &e, int u, int t)",
			"    {",
			"        dfn[u] = ++ cnt;",
			"        sge[cnt] = u;",
			"        top[u] = t;",
			"",
			"        if (!son[u])",
			"            return;",
			"        dfs2(e, son[u], t);",
			"",
			"        for (int ei = e.head[u]; ei; ei = e.nxt[ei])",
			"        {",
			"            int v = e.to[ei];",
			"            if (v != fa[u] && v != son[u])",
			"                dfs2(e, v, v);",
			"        }",
			"    }",
			"",
			"    void build(ChainBuild &e, int root)",
			"    {",
			"        dfs1(e, root, 0);",
			"        dfs2(e, root, root);",
			"    }",
			"",
			"    void modifyPath(SegTree<Info, Laz> &seg, int u, int v, Laz tag)",
			"    {",
			"        while (top[u] != top[v])",
			"        {",
			"            if (dep[top[u]] < dep[top[v]])",
			"                swap(u, v);",
			"            seg.modify(dfn[top[u]], dfn[u], tag);",
			"            u = fa[top[u]];",
			"        }",
			"        if (dep[u] > dep[v])",
			"            swap(u, v);",
			"        seg.modify(dfn[u], dfn[v], tag);",
			"    }",
			"",
			"    Info queryPath(SegTree<Info, Laz> &seg, int u, int v)",
			"    {",
			"        Info res;",
			"        while (top[u] != top[v])",
			"        {",
			"            if (dep[top[u]] < dep[top[v]])",
			"                swap(u, v);",
			"            res = res + seg.query(dfn[top[u]], dfn[u]);",
			"            u = fa[top[u]];",
			"        }",
			"        if (dep[u] > dep[v])",
			"            swap(u, v);",
			"        return res + seg.query(dfn[u], dfn[v]);",
			"    }",
			"",
			"    void modifySubtree(SegTree<Info, Laz> &seg, int u, Laz tag)",
			"    {",
			"        seg.modify(dfn[u], dfn[u] + siz[u] - 1, tag);",
			"    }",
			"",
			"    Info querySubtree(SegTree<Info, Laz> &seg, int u)",
			"    {",
			"        return seg.query(dfn[u], dfn[u] + siz[u] - 1);",
			"    }",
			"",
			"    int lca(int u, int v)",
			"    {",
			"        while (top[u] != top[v])",
			"        {",
			"            if (dep[top[u]] >= dep[top[v]])",
			"                u = fa[top[u]];",
			"            else",
			"                v = fa[top[v]];",
			"        }",
			"        return (dfn[u] <= dfn[v] ? u : v);",
			"    }",
			"};"
		})
	}),
})


local generated = require("snippets.generated_snippets")
ls.add_snippets("cpp", generated)