local ls = require("luasnip") -- 引入 LuaSnip

-- 定义一些快捷函数
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

return {
	s("normal", {
		t({
			"#include <bits/stdc++.h>",
			"#define int long long",
			"#define inf 0x3f3f3f3f3f3f3f3f",
			"#define iinf 0x3f3f3f3f",
			"#define all(x) begin(x), end(x)",
			"#define rall(x) rbegin(x), rend(x)",
			"#define _endl \"\\n\"",
			"#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"using namespace std;",
			"",
			"void solve()",
			"{",
			"	"
		}),
		i(1, ""), -- 插入点 1
		t({
			"",
			"}",
			"",
			"signed main()",
			"{",
			"	IOS;",
			"	solve();",
			"	return 0;",
			"}"
		})
	}),
	s("normals", {
        t({
            "#include <bits/stdc++.h>",
            "#define int long long",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define iinf 0x3f3f3f3f",
            "#define all(x) begin(x), end(x)",
            "#define rall(x) rbegin(x), rend(x)",
            "#define _endl \"\\n\"",
            "#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "signed main()",
            "{",
            "	IOS;",
            "	int t;",
			"	for (cin >> t; t --; )",
			"		solve();",
            "	return 0;",
            "}"
        })
    }),
    s("poj", {
        t({
            "#include <iostream>",
            "#include <algorithm>",
            "#include <string.h>",
            "#include <sstream>",
            "#include <cctype>",
            "#include <string>",
            "#include <iomanip>",
			"#include <cmath>",
            "#include <vector>",
            "#include <queue>",
            "#include <deque>",
            "#include <stack>",
            "#include <map>",
            "#include <set>",
            "#define int long long",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define iinf 0x3f3f3f3f",
            "#define all(x) begin(x), end(x)",
            "#define rall(x) rbegin(x), rend(x)",
            "#define _endl \"\\n\"",
            "#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "using namespace std;",
            "",
            "void solve()",
            "{",
            "	"
        }),
        i(1, ""),
        t({
            "",
            "}",
            "",
            "signed main()",
            "{",
            "	int t = 1;",
            '	// scanf("%lld", &t);',
            "	while (t --)",
			"		solve();",
            "	return 0;",
            "}"
        })
	}),
	s("headInclude", {
		t({
			"#include <bits/stdc++.h>",
			"#define int long long",
			"#define inf 0x3f3f3f3f3f3f3f3f",
			"#define iinf 0x3f3f3f3f",
			"#define all(x) begin(x), end(x)",
			"#define rall(x) rbegin(x), rend(x)",
			"#define _endl \"\\n\"",
			"#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"using namespace std;"
		})
	}),
	s("main", {
		t({
			"signed main()",
			"{",
			"    IOS;",
			"    solve();",
			"    return 0;",
			"}"
		})
	}),
	s("mains", {
		t({
			"signed main()",
			"{",
			"    IOS;",
			"    int t;",
			"    for (cin >> t; t --; )",
			"        solve();",
			"    return 0;",
			"}"
		})
	}),
	s("KRUSKAL", {
		t({ "struct node",
			"{",
			"	int st, to, len;",
			"	bool operator<(const node y)  const {return len < y.len;}",
			"};",
			"void solve()",
			"{",
			"	int n, m;  cin >> n >> m;",
			"	DSU dsu(n);",
			"	vector<node> v;",
            "",
            "",
			"	sort(all(v));",
			"	auto Kruskal = [&]() -> int",
			"	{",
			"		int ans = 0, cnt = 0;",
			"		for (int i=0;i<v.size();i++)",
			"		{",
			"			auto cur = v[i];",
			"			if (!dsu.same(cur.st, cur.to))",
			"			{",
			"				cnt ++;",
			"				ans += cur.len;",
			"				dsu.merge(cur.st, cur.to);",
			"			}",
			"		}",
			"		return (cnt == n - 1 ? ans : -1);",
			"	};",
            "	auto x = Kruskal();",
			"}",
			"" })
	}),
	s("Prim", {
		t({ "struct node",
			"{",
			"	int id, val;",
			"	bool operator< (const node other) const {return val > other.val;}",
			"};",
			"",
			"void solve()",
			"{",
			"	int n, m;   cin >> n >> m;",
			"	vector<vector<node>> adj(n + 1);",
			"	for (int i=0;i<m;i++)",
			"	{",
			"		int a, b, c;",
			"		cin >> a >> b >> c;",
			"		adj[a].push_back({b, c});",
			"		adj[b].push_back({a, c});",
			"	}",
			"	auto Prim = [&]() -> int",
			"	{",
			"		vector<bool> vis(n + 1, false);",
			"		priority_queue<node> q;",
			"		q.push({1, 0});",
			"		",
			"		int ans = 0, cnt = 0;",
			"		while (!q.empty())",
			"		{",
			"			auto cur = q.top(); q.pop();",
			"			if (vis[cur.id]) continue;",
			"			cnt ++;",
			"			ans += cur.val;",
			"			vis[cur.id] = true;",
			"",
			"			for (auto [to, val] : adj[cur.id])",
			"				if (!vis[to])",
			"					q.push({to, val});",
			"		}",
			"		return (cnt == n ? ans : -1);",
			"	};",
			"	auto x = Prim();",
			"}" })
	}),
	s("Floyd", {
		t({ "for (int k=1;k<=n;k++)",
			"	for (int i=1;i<=n;i++)",
			"		for (int j=1;j<=n;j++)",
			"			if (dis[i][k] != inf && dis[k][j] != inf && dis[i][k] + dis[k][j] < dis[i][j])",
			"				dis[i][j] = dis[i][k] + dis[k][j];" })
	}),
	s("TopoSort", {
		t({ "auto TopoSort = [&]() -> vector<int>",
			"{",
			"	vector<int> arr;",
			"	vector<bool> vis(n + 1, false);",
			"	priority_queue<int> q;",
			"	for (int i=1;i<=n;i++)",
			"		if (!in[i])	q.push(i);",
			"",
			"	while (!q.empty())",
			"	{",
			"		auto x = q.top();   q.pop();",
			"		vis[x] = true;",
			"		arr.push_back(x);",
			"",
			"		for (auto to : adj[x])",
			"		{",
			"			in[to] --;",
			"			if (!in[to] && !vis[to])",
			"				q.push(to);",
			"		}",
			"	}",
			"	return arr;",
			"};" })
	}),
    s("qpow", {
		t({ "int qpow(int a, int b)",
			"{",
			"	int tmp = 1;",
			"	a %= MOD;",
			"	while (b)",
			"	{",
			"		if (b & 1)",
			"			tmp = tmp * a % MOD;",
			"		a = a * a % MOD;",
			"		b >>= 1;",
			"	}",
			"	return tmp;",
			"}",
			"",
			"int inv(int x) { return qpow(x, MOD - 2);}" })
	}),
    s("case", {
        t({ "for (int i = 1; i <= t; i ++)",
            "{",
            '	cout << "Case " << i << ":" << _endl;',
            "	solve();",
            "}"})
    }),
	s("spfa", {
		t({ "auto spfa = [&](int u) -> bool",
			"	{",
			"		queue<int> q;",
			"		vector<int> updCnt(n + 5, 0);",
			"		vector<bool> enter(n + 5, false);",
			"		dist[u] = 0;",
			"		q.push(u);",
			"		enter[u] = true;",
			"",
			"		while (!q.empty())",
			"		{",
			"			auto x = q.front();   q.pop();",
			"			enter[x] = false;",
			"",
			"			for (auto [to, val] : adj[x])",
			"			{",
			"				if (val + dist[x] < dist[to])",
			"				{",
			"					dist[to] = dist[x] + val;",
			"					if (enter[x])   continue;",
			"					if (updCnt[to] ++ == n)",
			"						return true;",
			"					q.push(to);",
			"					enter[to] = true;",
			"				}",
			"			}",
			"		}",
			"		return false;",
			"	};" })
	}),
	s("Dijkstra", {
		t({ "",
			"struct GRA",
			"{",
			"	int n;",
			"	vector<bool> vis;",
			"	vector<int> dist, p;",
			"	vector<vector<pair<int, int>>> adj;",
			"	GRA(int n_) {init(n_);}",
			"	void init(int n_)",
			"	{",
			"		n = n_;",
			"		adj.resize(n + 1);",
			"		p.resize(n + 1, -1);",
			"		dist.resize(n + 1, inf);",
			"		vis.resize(n + 1, false);",
			"	}",
			"	vector<int> find_path(int x)",
			"	{",
			"		vector<int> path;",
			"		while (p[x] != -1)",
			"		{",
			"			path.push_back(x);",
			"			x = p[x];",
			"		}",
			"		return vector<int>(rall(path));",
			"	}",
			"	struct cmp {bool operator()(const pair<int, int> x, pair<int, int> y) const {return x.second > y.second;}};",
			"	void dijkstra(int u)",
			"	{",
			"		priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;",
			"		dist[u] = 0;",
			"		q.push({u, dist[u]});",
			"		while (!q.empty())",
			"		{",
			"			auto [pre, dis] = q.top();  q.pop();",
			"			if (vis[pre])   continue;",
			"			vis[pre] = true;",
			"			for (auto [to, val] : adj[pre])",
			"			{",
			"				if (!vis[to] && dis + val < dist[to])",
			"				{",
			"					dist[to] = dist[pre] + val;",
			"					p[to] = pre;",
			"					q.push({to, dist[to]});",
			"				}",
			"			}",
			"		}",
			"	}",
			"};",
			"" })
	}),
	s("ChainBuild", {
		t({ "struct ChainBuild",
			"{",
			"    int n, m, cnt = 1;",
			"    vector<int> head;",
			"    vector<int> nxt;",
			"    vector<int> to;",
			"    vector<int> val;",
			"",
			"    ChainBuild() {}",
			"    ChainBuild(int n_) : n(n_), m(2 * n_) { init(); }",
			"    ChainBuild(int n_, int m_) : n(n_), m(2 * m_) { init(); }",
			"",
			"    void init()",
			"    {",
			"        head.resize(n + 1, 0);",
			"        nxt.resize(m + 1);",
			"        to.resize(m + 1);",
			"        val.resize(m + 1);",
			"    }",
			"",
			"    void clear()",
			"    {",
			"        cnt = 1;",
			"        head.resize(n + 1, 0);",
			"    }",
			"",
			"    void addEdge(int u, int v, int w = 0)",
			"    {",
			"        nxt[cnt] = head[u];",
			"        to[cnt] = v;",
			"        val[cnt] = w;",
			"        head[u] = cnt ++;",
			"    }",
			"};" })
	}),
	s("DSU", {
		t({ "struct DSU",
			"{",
			"    vector<int> f, siz;",
			"    ",
			"    DSU() {}",
			"    DSU(int n) {init(n);}",
			"    ",
			"    void init(int n) ",
			"    {",
			"        f.resize(n + 1);",
			"        iota(f.begin(), f.end(), 0);",
			"        siz.assign(n + 1, 1);",
			"    }",
			"    ",
			"    int find(int x) ",
			"    {",
			"        while (x != f[x])",
			"            x = f[x] = f[f[x]];",
			"        return x;",
			"    }",
			"    ",
			"    bool same(int x, int y) {return find(x) == find(y);}",
			"    ",
			"    bool merge(int x, int y) ",
			"    {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y) ",
			"            return false;",
			"        siz[x] += siz[y];",
			"        f[y] = x;",
			"        return true;",
			"    }",
			"    ",
			"    int size(int x) {return siz[find(x)];}",
			"};" })
	}),
	s("TreeChain", {
		t({
			"struct TreeChain",
			"{",
			"    int cnt;",
			"    vector<int> fa, son, dep, siz, top, dfn, sge;",
			"",
			"    TreeChain(int n) : fa(n + 2), son(n + 2, 0), dep(n + 2, 0), siz(n + 2), top(n + 2), dfn(n + 2), sge(n + 2), cnt(0) {}",
			"",
			"    void dfs1(ChainBuild &e, int u, int f)",
			"    {",
			"        fa[u] = f;",
			"        dep[u] = dep[f] + 1;",
			"        siz[u] = 1;",
			"",
			"        for (int ei = e.head[u]; ei; ei = e.nxt[ei])",
			"        {",
			"            int v = e.to[ei];",
			"            if (v == f)",
			"                continue;",
			"            dfs1(e, v, u);",
			"            siz[u] += siz[v];",
			"            if (siz[v] > siz[son[u]])",
			"                son[u] = v;",
			"        }",
			"    }",
			"",
			"    void dfs2(ChainBuild &e, int u, int t)",
			"    {",
			"        dfn[u] = ++ cnt;",
			"        sge[cnt] = u;",
			"        top[u] = t;",
			"",
			"        if (!son[u])",
			"            return;",
			"        dfs2(e, son[u], t);",
			"",
			"        for (int ei = e.head[u]; ei; ei = e.nxt[ei])",
			"        {",
			"            int v = e.to[ei];",
			"            if (v != fa[u] && v != son[u])",
			"                dfs2(e, v, v);",
			"        }",
			"    }",
			"",
			"    void build(ChainBuild &e, int root)",
			"    {",
			"        dfs1(e, root, 0);",
			"        dfs2(e, root, root);",
			"    }",
			"",
			"    void modifyPath(SegTree<Info, Laz> &seg, int u, int v, Laz tag)",
			"    {",
			"        while (top[u] != top[v])",
			"        {",
			"            if (dep[top[u]] < dep[top[v]])",
			"                swap(u, v);",
			"            seg.modify(dfn[top[u]], dfn[u], tag);",
			"            u = fa[top[u]];",
			"        }",
			"        if (dep[u] > dep[v])",
			"            swap(u, v);",
			"        seg.modify(dfn[u], dfn[v], tag);",
			"    }",
			"",
			"    Info queryPath(SegTree<Info, Laz> &seg, int u, int v)",
			"    {",
			"        Info res;",
			"        while (top[u] != top[v])",
			"        {",
			"            if (dep[top[u]] < dep[top[v]])",
			"                swap(u, v);",
			"            res = res + seg.query(dfn[top[u]], dfn[u]);",
			"            u = fa[top[u]];",
			"        }",
			"        if (dep[u] > dep[v])",
			"            swap(u, v);",
			"        return res + seg.query(dfn[u], dfn[v]);",
			"    }",
			"",
			"    void modifySubtree(SegTree<Info, Laz> &seg, int u, Laz tag)",
			"    {",
			"        seg.modify(dfn[u], dfn[u] + siz[u] - 1, tag);",
			"    }",
			"",
			"    Info querySubtree(SegTree<Info, Laz> &seg, int u)",
			"    {",
			"        return seg.query(dfn[u], dfn[u] + siz[u] - 1);",
			"    }",
			"",
			"    int lca(int u, int v)",
			"    {",
			"        while (top[u] != top[v])",
			"        {",
			"            if (dep[top[u]] >= dep[top[v]])",
			"                u = fa[top[u]];",
			"            else",
			"                v = fa[top[v]];",
			"        }",
			"        return (dfn[u] <= dfn[v] ? u : v);",
			"    }",
			"};"
		})
	})
}
