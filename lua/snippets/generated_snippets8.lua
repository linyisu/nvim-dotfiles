-- Auto-generated LuaSnip snippets
local ls = require("luasnip") -- 引入 LuaSnip
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

return {

-- 05_Geometry\2D\ConvexHull.h
s("05_geometry_2d_convexhull_h", {
	t({
		"/**",
		" * 二维凸包算法模板",
		" * 时间复杂度：O(n log n)",
		" * 空间复杂度：O(n)",
		" * 适用场景：求点集的凸包，凸包相关计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 使用Point类（需要包含Point.h）",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator<(const Point& p) const { return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"// Andrew算法求凸包",
		"vector<Point> convex_hull(vector<Point> points) {",
		"    int n = points.size();",
		"    if (n <= 1) return points;",
		"",
		"    sort(points.begin(), points.end());",
		"",
		"    // 构建下凸包",
		"    vector<Point> hull;",
		"    for (int i = 0; i < n; i++) {",
		"        while (hull.size() >= 2 &&",
		"               (hull[hull.size() - 1] - hull[hull.size() - 2]).cross(points[i] - hull[hull.size() - 2]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    // 构建上凸包",
		"    int lower_size = hull.size();",
		"    for (int i = n - 2; i >= 0; i--) {",
		"        while (hull.size() > lower_size &&",
		"               (hull[hull.size() - 1] - hull[hull.size() - 2]).cross(points[i] - hull[hull.size() - 2]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    if (hull.size() > 1) hull.pop_back();  // 移除重复的起点",
		"    return hull;",
		"}",
		"",
		"// Graham扫描法求凸包",
		"vector<Point> graham_scan(vector<Point> points) {",
		"    int n = points.size();",
		"    if (n <= 1) return points;",
		"",
		"    // 找到最下方的点（y坐标最小，相同时x坐标最小）",
		"    int bottom = 0;",
		"    for (int i = 1; i < n; i++) {",
		"        if (points[i].y < points[bottom].y ||",
		"            (abs(points[i].y - points[bottom].y) < EPS && points[i].x < points[bottom].x)) {",
		"            bottom = i;",
		"        }",
		"    }",
		"    swap(points[0], points[bottom]);",
		"",
		"    Point pivot = points[0];",
		"",
		"    // 按极角排序",
		"    sort(points.begin() + 1, points.end(), [&](const Point& a, const Point& b) {",
		"        double cross_val = (a - pivot).cross(b - pivot);",
		"        if (abs(cross_val) > EPS) return cross_val > 0;",
		"        return pivot.distance(a) < pivot.distance(b);",
		"    });",
		"",
		"    vector<Point> hull;",
		"    for (const Point& p : points) {",
		"        while (hull.size() >= 2 &&",
		"               (hull[hull.size() - 1] - hull[hull.size() - 2]).cross(p - hull[hull.size() - 2]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(p);",
		"    }",
		"",
		"    return hull;",
		"}",
		"",
		"// 判断点是否在凸多边形内（射线法）",
		"bool point_in_convex_polygon(const Point& p, const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    if (n < 3) return false;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        Point a = poly[i];",
		"        Point b = poly[(i + 1) % n];",
		"        if ((b - a).cross(p - a) < -EPS) {",
		"            return false;  // 在边的右侧，不在凸包内",
		"        }",
		"    }",
		"    return true;",
		"}",
		"",
		"// 判断点是否在任意多边形内（射线法）",
		"bool point_in_polygon(const Point& p, const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    bool inside = false;",
		"",
		"    for (int i = 0, j = n - 1; i < n; j = i++) {",
		"        if (((poly[i].y > p.y) != (poly[j].y > p.y)) &&",
		"            (p.x < (poly[j].x - poly[i].x) * (p.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) {",
		"            inside = !inside;",
		"        }",
		"    }",
		"    return inside;",
		"}",
		"",
		"// 多边形面积（有向面积，逆时针为正）",
		"double polygon_area(const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    if (n < 3) return 0;",
		"",
		"    double area = 0;",
		"    for (int i = 0; i < n; i++) { area += poly[i].cross(poly[(i + 1) % n]); }",
		"    return area / 2.0;",
		"}",
		"",
		"// 多边形周长",
		"double polygon_perimeter(const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    if (n < 2) return 0;",
		"",
		"    double perimeter = 0;",
		"    for (int i = 0; i < n; i++) { perimeter += poly[i].distance(poly[(i + 1) % n]); }",
		"    return perimeter;",
		"}",
		"",
		"// 凸包直径（旋转卡壳算法）",
		"double convex_hull_diameter(const vector<Point>& hull) {",
		"    int n = hull.size();",
		"    if (n <= 1) return 0;",
		"    if (n == 2) return hull[0].distance(hull[1]);",
		"",
		"    double max_dist = 0;",
		"    int j = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        Point edge = hull[(i + 1) % n] - hull[i];",
		"",
		"        // 找到与当前边距离最大的点",
		"        while (true) {",
		"            int next_j = (j + 1) % n;",
		"            Point to_j = hull[j] - hull[i];",
		"            Point to_next_j = hull[next_j] - hull[i];",
		"",
		"            if (edge.cross(to_next_j) > edge.cross(to_j)) {",
		"                j = next_j;",
		"            } else {",
		"                break;",
		"            }",
		"        }",
		"",
		"        max_dist = max(max_dist, hull[i].distance(hull[j]));",
		"        max_dist = max(max_dist, hull[(i + 1) % n].distance(hull[j]));",
		"    }",
		"",
		"    return max_dist;",
		"}",
		"",
		"// 最小外接矩形面积（旋转卡壳）",
		"double min_bounding_rectangle_area(const vector<Point>& hull) {",
		"    int n = hull.size();",
		"    if (n <= 2) return 0;",
		"",
		"    double min_area = 1e18;",
		"    int right = 1, top = 1, left = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        Point edge = hull[(i + 1) % n] - hull[i];",
		"        Point normal(-edge.y, edge.x);  // 法向量",
		"",
		"        // 找到四个方向的极值点",
		"        while ((hull[(right + 1) % n] - hull[right]).dot(edge) > EPS) { right = (right + 1) % n; }",
		"        while ((hull[(top + 1) % n] - hull[top]).dot(normal) > EPS) { top = (top + 1) % n; }",
		"        while ((hull[(left + 1) % n] - hull[left]).dot(edge) < -EPS) { left = (left + 1) % n; }",
		"",
		"        // 计算矩形面积",
		"        double width = (hull[right] - hull[left]).dot(edge) / edge.norm();",
		"        double height = (hull[top] - hull[i]).dot(normal) / normal.norm();",
		"        min_area = min(min_area, width * height);",
		"    }",
		"",
		"    return min_area;",
		"}",
		"",
		"// 最小外接圆（Welzl算法的简化版本）",
		"struct Circle {",
		"    Point center;",
		"    double radius;",
		"    Circle() : radius(0) {}",
		"    Circle(const Point& c, double r) : center(c), radius(r) {}",
		"    bool contains(const Point& p) const { return center.distance(p) <= radius + EPS; }",
		"};",
		"",
		"Circle smallest_enclosing_circle(vector<Point> points) {",
		"    random_shuffle(points.begin(), points.end());",
		"",
		"    Circle circle;",
		"    int n = points.size();",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        if (!circle.contains(points[i])) {",
		"            circle = Circle(points[i], 0);",
		"            for (int j = 0; j < i; j++) {",
		"                if (!circle.contains(points[j])) {",
		"                    circle = Circle((points[i] + points[j]) * 0.5, points[i].distance(points[j]) * 0.5);",
		"                    for (int k = 0; k < j; k++) {",
		"                        if (!circle.contains(points[k])) {",
		"                            // 三点确定圆",
		"                            Point a = points[i], b = points[j], c = points[k];",
		"                            double d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));",
		"                            if (abs(d) > EPS) {",
		"                                double ux =",
		"                                    ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) +",
		"                                     (c.x * c.x + c.y * c.y) * (a.y - b.y)) /",
		"                                    d;",
		"                                double uy =",
		"                                    ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) +",
		"                                     (c.x * c.x + c.y * c.y) * (b.x - a.x)) /",
		"                                    d;",
		"                                Point center(ux, uy);",
		"                                circle = Circle(center, center.distance(a));",
		"                            }",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    return circle;",
		"}",
	})
}),

-- 05_Geometry\2D\Geometry2D.h
s("05_geometry_2d_geometry2d_h", {
	t({
		"/**",
		" * 完整的二维几何模板",
		" * 包含：点、向量、直线、线段、圆、多边形等所有基本几何类型和算法",
		" * 时间复杂度：各操作复杂度见具体函数注释",
		" * 空间复杂度：O(1) 到 O(n)",
		" * 适用场景：各种二维几何问题的完整解决方案",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 精度比较函数",
		"int sgn(double x) { return (x > EPS) - (x < -EPS); }",
		"",
		"// 二维点/向量类",
		"struct Point {",
		"    double x, y;",
		"",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"",
		"    // 基本运算",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    Point operator-() const { return Point(-x, -y); }",
		"",
		"    Point& operator+=(const Point& p) {",
		"        x += p.x;",
		"        y += p.y;",
		"        return *this;",
		"    }",
		"    Point& operator-=(const Point& p) {",
		"        x -= p.x;",
		"        y -= p.y;",
		"        return *this;",
		"    }",
		"    Point& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        return *this;",
		"    }",
		"    Point& operator/=(double t) {",
		"        x /= t;",
		"        y /= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算",
		"    bool operator<(const Point& p) const { return sgn(x - p.x) ? x < p.x : y < p.y; }",
		"    bool operator==(const Point& p) const { return !sgn(x - p.x) && !sgn(y - p.y); }",
		"    bool operator!=(const Point& p) const { return !(*this == p); }",
		"",
		"    // 向量运算",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"",
		"    // 长度和距离",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point& p) const { return (*this - p).norm2(); }",
		"",
		"    // 角度和旋转",
		"    double angle() const { return atan2(y, x); }",
		"    Point rotate(double theta) const {",
		"        double c = cos(theta), s = sin(theta);",
		"        return Point(x * c - y * s, x * s + y * c);",
		"    }",
		"    Point rotate90() const { return Point(-y, x); }",
		"    Point normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point() : *this / len;",
		"    }",
		"",
		"    // 输入输出",
		"    void read() { cin >> x >> y; }",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \"\\n\"; }",
		"};",
		"",
		"using Vector = Point;",
		"",
		"// 全局几何函数",
		"double cross(const Point& a, const Point& b) { return a.cross(b); }",
		"double dot(const Point& a, const Point& b) { return a.dot(b); }",
		"double distance(const Point& a, const Point& b) { return a.distance(b); }",
		"",
		"// 三点关系判断",
		"double orientation(const Point& a, const Point& b, const Point& c) { return cross(b - a, c - a); }",
		"",
		"// 二维直线类",
		"struct Line {",
		"    Point a, b;",
		"",
		"    Line() {}",
		"    Line(const Point& a, const Point& b) : a(a), b(b) {}",
		"    Line(double x1, double y1, double x2, double y2) : a(x1, y1), b(x2, y2) {}",
		"",
		"    // 从一般式方程构造 Ax + By + C = 0",
		"    Line(double A, double B, double C) {",
		"        if (abs(A) < EPS) {",
		"            a = Point(0, -C / B);",
		"            b = Point(1, -C / B);",
		"        } else if (abs(B) < EPS) {",
		"            a = Point(-C / A, 0);",
		"            b = Point(-C / A, 1);",
		"        } else {",
		"            a = Point(0, -C / B);",
		"            b = Point(1, (-C - A) / B);",
		"        }",
		"    }",
		"",
		"    Point direction() const { return b - a; }",
		"    Point normal() const { return (b - a).rotate90(); }",
		"    Point point_at(double t) const { return a + direction() * t; }",
		"",
		"    // 点到直线距离",
		"    double distance_to_point(const Point& p) const { return abs(cross(p - a, direction())) / direction().norm(); }",
		"",
		"    // 点在直线上的投影",
		"    Point project_point(const Point& p) const {",
		"        Vector dir = direction();",
		"        double t = dot(p - a, dir) / dir.norm2();",
		"        return point_at(t);",
		"    }",
		"",
		"    // 直线交点",
		"    Point intersection(const Line& other) const {",
		"        Vector d1 = direction(), d2 = other.direction();",
		"        double det = cross(d1, d2);",
		"        if (abs(det) < EPS) return Point(1e18, 1e18);  // 平行",
		"        double t = cross(other.a - a, d2) / det;",
		"        return point_at(t);",
		"    }",
		"",
		"    bool is_parallel(const Line& other) const { return abs(cross(direction(), other.direction())) < EPS; }",
		"};",
		"",
		"// 线段类",
		"struct Segment {",
		"    Point a, b;",
		"",
		"    Segment() {}",
		"    Segment(const Point& a, const Point& b) : a(a), b(b) {}",
		"",
		"    double length() const { return distance(a, b); }",
		"    Point midpoint() const { return (a + b) * 0.5; }",
		"    Line to_line() const { return Line(a, b); }",
		"",
		"    // 点到线段距离",
		"    double distance_to_point(const Point& p) const {",
		"        Vector ap = p - a, ab = b - a;",
		"        double t = dot(ap, ab) / ab.norm2();",
		"        if (t < 0) return distance(p, a);",
		"        if (t > 1) return distance(p, b);",
		"        return distance(p, a + ab * t);",
		"    }",
		"",
		"    // 判断点是否在线段上",
		"    bool contains_point(const Point& p) const { return abs(cross(p - a, b - a)) < EPS && dot(p - a, p - b) <= EPS; }",
		"",
		"    // 线段相交判断",
		"    bool intersects(const Segment& other) const {",
		"        Point A = a, B = b, C = other.a, D = other.b;",
		"        double c1 = cross(B - A, C - A);",
		"        double c2 = cross(B - A, D - A);",
		"        double c3 = cross(D - C, A - C);",
		"        double c4 = cross(D - C, B - C);",
		"",
		"        if (abs(c1) < EPS && abs(c2) < EPS) {  // 共线",
		"            return max(min(A.x, B.x), min(C.x, D.x)) <= min(max(A.x, B.x), max(C.x, D.x)) + EPS &&",
		"                   max(min(A.y, B.y), min(C.y, D.y)) <= min(max(A.y, B.y), max(C.y, D.y)) + EPS;",
		"        }",
		"",
		"        return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0;",
		"    }",
		"",
		"    // 线段交点",
		"    Point intersection(const Segment& other) const {",
		"        Line l1 = to_line(), l2 = other.to_line();",
		"        Point inter = l1.intersection(l2);",
		"        if (inter.x > 1e17) return inter;",
		"        if (contains_point(inter) && other.contains_point(inter)) return inter;",
		"        return Point(1e18, 1e18);",
		"    }",
		"};",
		"",
		"// 圆类",
		"struct Circle {",
		"    Point center;",
		"    double radius;",
		"",
		"    Circle() : radius(0) {}",
		"    Circle(const Point& c, double r) : center(c), radius(r) {}",
		"    Circle(double x, double y, double r) : center(x, y), radius(r) {}",
		"",
		"    double area() const { return PI * radius * radius; }",
		"    double circumference() const { return 2 * PI * radius; }",
		"",
		"    // 点与圆的关系：-1内部，0边界，1外部",
		"    int point_relation(const Point& p) const {",
		"        double d = distance(center, p);",
		"        return sgn(d - radius);",
		"    }",
		"",
		"    bool contains(const Point& p) const { return point_relation(p) <= 0; }",
		"    bool on_circle(const Point& p) const { return point_relation(p) == 0; }",
		"",
		"    // 直线与圆的交点",
		"    vector<Point> line_intersection(const Line& line) const {",
		"        vector<Point> result;",
		"        double d = line.distance_to_point(center);",
		"        if (d > radius + EPS) return result;",
		"",
		"        Point proj = line.project_point(center);",
		"        if (abs(d - radius) < EPS) {",
		"            result.push_back(proj);",
		"        } else {",
		"            double delta = sqrt(radius * radius - d * d);",
		"            Vector unit_dir = line.direction().normalize();",
		"            result.push_back(proj + unit_dir * delta);",
		"            result.push_back(proj - unit_dir * delta);",
		"        }",
		"        return result;",
		"    }",
		"",
		"    // 两圆交点",
		"    vector<Point> circle_intersection(const Circle& other) const {",
		"        vector<Point> result;",
		"        double d = distance(center, other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        if (d > r1 + r2 + EPS || d < abs(r1 - r2) - EPS || d < EPS) return result;",
		"",
		"        double a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);",
		"        double h = sqrt(r1 * r1 - a * a);",
		"        Point mid = center + (other.center - center) * (a / d);",
		"",
		"        if (abs(h) < EPS) {",
		"            result.push_back(mid);",
		"        } else {",
		"            Vector perp = ((other.center - center) / d).rotate90();",
		"            result.push_back(mid + perp * h);",
		"            result.push_back(mid - perp * h);",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// 三点确定圆",
		"Circle circumcircle(const Point& a, const Point& b, const Point& c) {",
		"    double d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));",
		"    if (abs(d) < EPS) return Circle(Point(0, 0), -1);",
		"",
		"    double ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) + (b.x * b.x + b.y * b.y) * (c.y - a.y) +",
		"                 (c.x * c.x + c.y * c.y) * (a.y - b.y)) /",
		"                d;",
		"    double uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) + (b.x * b.x + b.y * b.y) * (a.x - c.x) +",
		"                 (c.x * c.x + c.y * c.y) * (b.x - a.x)) /",
		"                d;",
		"",
		"    Point center(ux, uy);",
		"    return Circle(center, distance(center, a));",
		"}",
		"",
		"// 多边形类",
		"struct Polygon {",
		"    vector<Point> vertices;",
		"",
		"    Polygon() {}",
		"    Polygon(const vector<Point>& v) : vertices(v) {}",
		"",
		"    int size() const { return vertices.size(); }",
		"    Point& operator[](int i) { return vertices[i]; }",
		"    const Point& operator[](int i) const { return vertices[i]; }",
		"",
		"    // 多边形面积（有向面积）",
		"    double area() const {",
		"        double res = 0;",
		"        int n = size();",
		"        for (int i = 0; i < n; i++) { res += cross(vertices[i], vertices[(i + 1) % n]); }",
		"        return res / 2;",
		"    }",
		"",
		"    // 多边形周长",
		"    double perimeter() const {",
		"        double res = 0;",
		"        int n = size();",
		"        for (int i = 0; i < n; i++) { res += distance(vertices[i], vertices[(i + 1) % n]); }",
		"        return res;",
		"    }",
		"",
		"    // 判断点是否在多边形内（射线法）",
		"    bool contains_point(const Point& p) const {",
		"        int n = size();",
		"        bool inside = false;",
		"        for (int i = 0, j = n - 1; i < n; j = i++) {",
		"            if (((vertices[i].y > p.y) != (vertices[j].y > p.y)) &&",
		"                (p.x < (vertices[j].x - vertices[i].x) * (p.y - vertices[i].y) / (vertices[j].y - vertices[i].y) +",
		"                           vertices[i].x)) {",
		"                inside = !inside;",
		"            }",
		"        }",
		"        return inside;",
		"    }",
		"};",
		"",
		"// 凸包算法（Andrew算法）",
		"vector<Point> convex_hull(vector<Point> points) {",
		"    sort(points.begin(), points.end());",
		"    int n = points.size();",
		"    if (n <= 1) return points;",
		"",
		"    vector<Point> hull;",
		"    // 下凸包",
		"    for (int i = 0; i < n; i++) {",
		"        while (hull.size() >= 2 && orientation(hull[hull.size() - 2], hull[hull.size() - 1], points[i]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    // 上凸包",
		"    int lower_size = hull.size();",
		"    for (int i = n - 2; i >= 0; i--) {",
		"        while (hull.size() > lower_size &&",
		"               orientation(hull[hull.size() - 2], hull[hull.size() - 1], points[i]) <= EPS) {",
		"            hull.pop_back();",
		"        }",
		"        hull.push_back(points[i]);",
		"    }",
		"",
		"    if (hull.size() > 1) hull.pop_back();",
		"    return hull;",
		"}",
		"",
		"// 判断点是否在凸多边形内",
		"bool point_in_convex_polygon(const Point& p, const vector<Point>& poly) {",
		"    int n = poly.size();",
		"    for (int i = 0; i < n; i++) {",
		"        if (cross(poly[(i + 1) % n] - poly[i], p - poly[i]) < -EPS) { return false; }",
		"    }",
		"    return true;",
		"}",
		"",
		"// 旋转卡壳求凸包直径",
		"double convex_diameter(const vector<Point>& hull) {",
		"    int n = hull.size();",
		"    if (n <= 1) return 0;",
		"    if (n == 2) return distance(hull[0], hull[1]);",
		"",
		"    double max_dist = 0;",
		"    int j = 1;",
		"    for (int i = 0; i < n; i++) {",
		"        Vector edge = hull[(i + 1) % n] - hull[i];",
		"        while (cross(edge, hull[(j + 1) % n] - hull[i]) > cross(edge, hull[j] - hull[i])) { j = (j + 1) % n; }",
		"        max_dist = max(max_dist, max(distance(hull[i], hull[j]), distance(hull[(i + 1) % n], hull[j])));",
		"    }",
		"    return max_dist;",
		"}",
	})
}),

-- 05_Geometry\2D\HalfPlaneIntersection.h
s("05_geometry_2d_halfplaneintersection_h", {
	t({
		"/*",
		" * 半平面交算法",
		" * 时间复杂度: O(n log n)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 求多个半平面的交集",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double angle() const { return atan2(y, x); }",
		"};",
		"",
		"struct Line {",
		"    Point a, b;    // 直线上两点",
		"    double angle;  // 直线方向角",
		"",
		"    Line() {}",
		"    Line(const Point& a, const Point& b) : a(a), b(b) { angle = (b - a).angle(); }",
		"    Line(const Point& p, double theta) : a(p) {",
		"        b = a + Point(cos(theta), sin(theta));",
		"        angle = theta;",
		"    }",
		"",
		"    // 判断点在直线左侧（半平面内）",
		"    bool on_left(const Point& p) const { return (b - a).cross(p - a) > EPS; }",
		"",
		"    // 两直线交点",
		"    Point intersection(const Line& other) const {",
		"        Point u = a - other.a;",
		"        Point v1 = b - a;",
		"        Point v2 = other.b - other.a;",
		"        double t = (u ^ v2) / (v1 ^ v2);",
		"        return a + v1 * t;",
		"    }",
		"",
		"    // 用于排序的比较函数",
		"    bool operator<(const Line& other) const {",
		"        if (abs(angle - other.angle) < EPS) { return on_left(other.a); }",
		"        return angle < other.angle;",
		"    }",
		"};",
		"",
		"// 半平面交",
		"vector<Point> half_plane_intersection(vector<Line> lines) {",
		"    // 按极角排序",
		"    sort(lines.begin(), lines.end());",
		"",
		"    // 去除重复半平面",
		"    int m = 0;",
		"    for (int i = 0; i < lines.size(); i++) {",
		"        if (i == 0 || abs(lines[i].angle - lines[i - 1].angle) > EPS) {",
		"            lines[m++] = lines[i];",
		"        } else if (lines[i].on_left(lines[i - 1].a)) {",
		"            lines[m - 1] = lines[i];",
		"        }",
		"    }",
		"    lines.resize(m);",
		"",
		"    deque<Line> dq;",
		"    deque<Point> pts;",
		"",
		"    for (const Line& line : lines) {",
		"        // 删除队尾无用半平面",
		"        while (dq.size() >= 2 && !line.on_left(pts.back())) {",
		"            dq.pop_back();",
		"            pts.pop_back();",
		"        }",
		"",
		"        // 删除队首无用半平面",
		"        while (dq.size() >= 2 && !line.on_left(pts.front())) {",
		"            dq.pop_front();",
		"            pts.pop_front();",
		"        }",
		"",
		"        dq.push_back(line);",
		"",
		"        // 计算新的交点",
		"        if (dq.size() >= 2) { pts.push_back(dq[dq.size() - 2].intersection(dq[dq.size() - 1])); }",
		"    }",
		"",
		"    // 最后清理",
		"    while (dq.size() >= 3 && !dq.front().on_left(pts.back())) {",
		"        dq.pop_back();",
		"        pts.pop_back();",
		"    }",
		"",
		"    if (dq.size() >= 3) { pts.push_back(dq.back().intersection(dq.front())); }",
		"",
		"    return vector<Point>(pts.begin(), pts.end());",
		"}",
		"",
		"// 创建半平面（点在直线左侧）",
		"Line make_half_plane(const Point& a, const Point& b) { return Line(a, b); }",
		"",
		"// 多边形的半平面表示",
		"vector<Line> polygon_to_half_planes(const vector<Point>& polygon) {",
		"    vector<Line> lines;",
		"    int n = polygon.size();",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int j = (i + 1) % n;",
		"        lines.push_back(Line(polygon[i], polygon[j]));",
		"    }",
		"",
		"    return lines;",
		"}",
		"",
		"// 求凸多边形的核",
		"vector<Point> convex_polygon_kernel(const vector<Point>& polygon) {",
		"    vector<Line> lines = polygon_to_half_planes(polygon);",
		"    return half_plane_intersection(lines);",
		"}",
	})
}),

-- 05_Geometry\2D\Line.h
s("05_geometry_2d_line_h", {
	t({
		"/**",
		" * 二维直线类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：直线相关的几何计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 使用Point类（需要包含Point.h）",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"};",
		"",
		"// 直线类",
		"struct Line {",
		"    Point a, b;  // 直线上的两点",
		"",
		"    // 构造函数",
		"    Line() {}",
		"    Line(const Point& a, const Point& b) : a(a), b(b) {}",
		"    Line(double x1, double y1, double x2, double y2) : a(x1, y1), b(x2, y2) {}",
		"",
		"    // 从点和方向向量构造",
		"    Line(const Point& p, const Point& dir, bool is_direction) {",
		"        a = p;",
		"        b = p + dir;",
		"    }",
		"",
		"    // 从一般式方程 ax + by + c = 0 构造",
		"    Line(double A, double B, double C) {",
		"        if (abs(A) < EPS) {",
		"            // B != 0",
		"            a = Point(0, -C / B);",
		"            b = Point(1, -C / B);",
		"        } else if (abs(B) < EPS) {",
		"            // A != 0",
		"            a = Point(-C / A, 0);",
		"            b = Point(-C / A, 1);",
		"        } else {",
		"            a = Point(0, -C / B);",
		"            b = Point(1, (-C - A) / B);",
		"        }",
		"    }",
		"",
		"    // 获取方向向量",
		"    Point direction() const { return b - a; }",
		"",
		"    // 获取单位方向向量",
		"    Point unit_direction() const {",
		"        Point dir = direction();",
		"        return dir / dir.norm();",
		"    }",
		"",
		"    // 获取法向量",
		"    Point normal() const {",
		"        Point dir = direction();",
		"        return Point(-dir.y, dir.x);  // 逆时针旋转90度",
		"    }",
		"",
		"    // 获取单位法向量",
		"    Point unit_normal() const {",
		"        Point n = normal();",
		"        return n / n.norm();",
		"    }",
		"",
		"    // 直线参数方程：a + t * (b - a)",
		"    Point point_at(double t) const { return a + direction() * t; }",
		"",
		"    // 获取一般式方程系数 Ax + By + C = 0",
		"    struct LineEquation {",
		"        double A, B, C;",
		"        LineEquation(double A, double B, double C) : A(A), B(B), C(C) {}",
		"    };",
		"",
		"    LineEquation get_equation() const {",
		"        Point dir = direction();",
		"        Point norm = normal();",
		"        double len = norm.norm();",
		"        norm = norm / len;",
		"        double C = -norm.dot(a);",
		"        return LineEquation(norm.x, norm.y, C);",
		"    }",
		"",
		"    // 点到直线的距离",
		"    double distance_to_point(const Point& p) const {",
		"        Point ap = p - a;",
		"        Point ab = direction();",
		"        return abs(ap.cross(ab)) / ab.norm();",
		"    }",
		"",
		"    // 点到直线的有向距离（正数表示在法向量方向一侧）",
		"    double signed_distance_to_point(const Point& p) const {",
		"        Point ap = p - a;",
		"        Point ab = direction();",
		"        return ap.cross(ab) / ab.norm();",
		"    }",
		"",
		"    // 点在直线上的投影",
		"    Point project_point(const Point& p) const {",
		"        Point ap = p - a;",
		"        Point ab = direction();",
		"        double t = ap.dot(ab) / ab.norm2();",
		"        return a + ab * t;",
		"    }",
		"",
		"    // 点关于直线的对称点",
		"    Point reflect_point(const Point& p) const {",
		"        Point proj = project_point(p);",
		"        return proj * 2 - p;",
		"    }",
		"",
		"    // 判断点是否在直线上",
		"    bool contains_point(const Point& p) const { return abs(distance_to_point(p)) < EPS; }",
		"",
		"    // 判断两直线是否平行",
		"    bool is_parallel(const Line& other) const { return abs(direction().cross(other.direction())) < EPS; }",
		"",
		"    // 判断两直线是否垂直",
		"    bool is_perpendicular(const Line& other) const { return abs(direction().dot(other.direction())) < EPS; }",
		"",
		"    // 直线交点（平行时返回无穷远点）",
		"    Point intersection(const Line& other) const {",
		"        Point d1 = direction(), d2 = other.direction();",
		"        double det = d1.cross(d2);",
		"        if (abs(det) < EPS) return Point(1e18, 1e18);  // 平行",
		"",
		"        double t = (other.a - a).cross(d2) / det;",
		"        return point_at(t);",
		"    }",
		"};",
		"",
		"// 全局函数",
		"double point_to_line_distance(const Point& p, const Line& l) { return l.distance_to_point(p); }",
	})
}),

-- 05_Geometry\2D\Point.h
s("05_geometry_2d_point_h", {
	t({
		"/**",
		" * 二维点/向量类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：二维几何计算的基础类",
		" */",
		"",
		"const double EPS = 1e-9;  // 精度控制",
		"const double PI = acos(-1.0);",
		"",
		"struct Point {",
		"    double x, y;",
		"",
		"    // 构造函数",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"",
		"    // 基本运算符重载",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    Point operator-() const { return Point(-x, -y); }",
		"",
		"    Point& operator+=(const Point& p) {",
		"        x += p.x;",
		"        y += p.y;",
		"        return *this;",
		"    }",
		"    Point& operator-=(const Point& p) {",
		"        x -= p.x;",
		"        y -= p.y;",
		"        return *this;",
		"    }",
		"    Point& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        return *this;",
		"    }",
		"    Point& operator/=(double t) {",
		"        x /= t;",
		"        y /= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算符",
		"    bool operator<(const Point& p) const { return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    bool operator!=(const Point& p) const { return !(*this == p); }   // 向量基本运算",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }    // 点积",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }  // 叉积",
		"",
		"    // 运算符重载：点乘和叉乘",
		"    double operator*(const Point& p) const { return dot(p); }    // 点乘重载",
		"    double operator^(const Point& p) const { return cross(p); }  // 叉乘重载",
		"",
		"    // 长度相关",
		"    double norm() const { return sqrt(x * x + y * y); }  // 向量长度",
		"    double norm2() const { return x * x + y * y; }       // 长度平方",
		"",
		"    // 单位化",
		"    Point normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point(0, 0) : Point(x / len, y / len);",
		"    }",
		"",
		"    // 旋转变换",
		"    Point rotate(double theta) const {",
		"        double c = cos(theta), s = sin(theta);",
		"        return Point(x * c - y * s, x * s + y * c);",
		"    }",
		"",
		"    Point rotate90() const { return Point(-y, x); }   // 逆时针旋转90度",
		"    Point rotate270() const { return Point(y, -x); }  // 顺时针旋转90度",
		"",
		"    // 角度相关",
		"    double angle() const { return atan2(y, x); }                            // 极角",
		"    double angle(const Point& p) const { return atan2(cross(p), dot(p)); }  // 与向量p的夹角",
		"",
		"    // 距离相关",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point& p) const { return (*this - p).norm2(); }",
		"",
		"    // 输出",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \"\\n\"; }",
		"};",
		"",
		"// 类型别名",
		"using Vector = Point;",
		"",
		"// 全局函数",
		"double dot(const Point& a, const Point& b) { return a.dot(b); }",
		"double cross(const Point& a, const Point& b) { return a.cross(b); }",
		"double distance(const Point& a, const Point& b) { return a.distance(b); }",
		"double distance2(const Point& a, const Point& b) { return a.distance2(b); }",
		"",
		"// 三点构成的三角形面积（有向面积）",
		"double triangle_area(const Point& a, const Point& b, const Point& c) { return cross(b - a, c - a) / 2.0; }",
		"",
		"// 判断三点的方向关系 (>0:逆时针, <0:顺时针, =0:共线)",
		"double orientation(const Point& a, const Point& b, const Point& c) { return cross(b - a, c - a); }",
		"",
		"// 判断点是否在线段上",
		"bool point_on_segment(const Point& p, const Point& a, const Point& b) {",
		"    return abs(cross(p - a, b - a)) < EPS && dot(p - a, p - b) <= EPS;",
		"}",
		"",
		"// 判断四边形是否为凸四边形",
		"bool is_convex_quadrilateral(const Point& a, const Point& b, const Point& c, const Point& d) {",
		"    double s1 = orientation(a, b, c);",
		"    double s2 = orientation(b, c, d);",
		"    double s3 = orientation(c, d, a);",
		"    double s4 = orientation(d, a, b);",
		"",
		"    return (s1 > EPS && s2 > EPS && s3 > EPS && s4 > EPS) || (s1 < -EPS && s2 < -EPS && s3 < -EPS && s4 < -EPS);",
		"}",
	})
}),

-- 05_Geometry\2D\Polygon.h
s("05_geometry_2d_polygon_h", {
	t({
		"/*",
		" * 二维多边形类模板",
		" * 时间复杂度: 面积计算O(n), 包含判断O(n), 凸包判断O(n)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 多边形相关的几何计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"struct Polygon {",
		"    vector<Point> vertices;",
		"",
		"    // 构造函数",
		"    Polygon() {}",
		"    Polygon(const vector<Point>& points) : vertices(points) {}",
		"",
		"    // 添加顶点",
		"    void add_vertex(const Point& p) { vertices.push_back(p); }",
		"    void add_vertex(double x, double y) { vertices.push_back(Point(x, y)); }",
		"",
		"    // 基本属性",
		"    int size() const { return vertices.size(); }",
		"    bool empty() const { return vertices.empty(); }",
		"",
		"    // 多边形面积（有向面积）",
		"    double area() const {",
		"        if (size() < 3) return 0;",
		"        double area = 0;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            area += vertices[i] ^ vertices[j];",
		"        }",
		"        return area / 2.0;",
		"    }",
		"",
		"    // 多边形周长",
		"    double perimeter() const {",
		"        if (size() < 2) return 0;",
		"        double perim = 0;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            perim += vertices[i].distance(vertices[j]);",
		"        }",
		"        return perim;",
		"    }",
		"",
		"    // 判断多边形方向（逆时针为正）",
		"    bool is_counter_clockwise() const { return area() > EPS; }",
		"",
		"    // 使多边形逆时针",
		"    void make_counter_clockwise() {",
		"        if (area() < -EPS) { reverse(vertices.begin(), vertices.end()); }",
		"    }",
		"",
		"    // 判断是否为凸多边形",
		"    bool is_convex() const {",
		"        if (size() < 3) return false;",
		"",
		"        bool has_pos = false, has_neg = false;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            int k = (i + 2) % size();",
		"",
		"            double cross = (vertices[j] - vertices[i]) ^ (vertices[k] - vertices[j]);",
		"            if (cross > EPS) has_pos = true;",
		"            if (cross < -EPS) has_neg = true;",
		"",
		"            if (has_pos && has_neg) return false;",
		"        }",
		"        return true;",
		"    }",
		"",
		"    // 点与多边形关系（射线法）",
		"    // 返回: -1内部, 0边界, 1外部",
		"    int point_relation(const Point& p) const {",
		"        if (size() < 3) return 1;",
		"",
		"        int winding = 0;",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"",
		"            // 检查点是否在边上",
		"            Point edge = vertices[j] - vertices[i];",
		"            Point to_p = p - vertices[i];",
		"            if (abs(edge ^ to_p) < EPS && (to_p * edge) >= -EPS && (to_p * edge) <= (edge * edge) + EPS) {",
		"                return 0;  // 在边界上",
		"            }",
		"",
		"            // 射线相交判断",
		"            if (vertices[i].y <= p.y) {",
		"                if (vertices[j].y > p.y && ((vertices[j] - vertices[i]) ^ (p - vertices[i])) > EPS) { winding++; }",
		"            } else {",
		"                if (vertices[j].y <= p.y && ((vertices[j] - vertices[i]) ^ (p - vertices[i])) < -EPS) { winding--; }",
		"            }",
		"        }",
		"",
		"        return winding == 0 ? 1 : -1;",
		"    }",
		"",
		"    bool contains(const Point& p) const { return point_relation(p) <= 0; }",
		"    bool contains_strictly(const Point& p) const { return point_relation(p) < 0; }",
		"",
		"    // 多边形重心",
		"    Point centroid() const {",
		"        if (empty()) return Point();",
		"        if (size() == 1) return vertices[0];",
		"        if (size() == 2) return (vertices[0] + vertices[1]) * 0.5;",
		"",
		"        Point center(0, 0);",
		"        double area_sum = 0;",
		"",
		"        for (int i = 0; i < size(); i++) {",
		"            int j = (i + 1) % size();",
		"            double cross = vertices[i] ^ vertices[j];",
		"            area_sum += cross;",
		"            center = center + (vertices[i] + vertices[j]) * cross;",
		"        }",
		"",
		"        if (abs(area_sum) < EPS) {",
		"            // 退化情况，返回几何中心",
		"            for (const Point& p : vertices) { center = center + p; }",
		"            return center / (double)size();",
		"        }",
		"",
		"        return center / (3.0 * area_sum);",
		"    }",
		"",
		"    // 多边形最小外接矩形",
		"    struct Rectangle {",
		"        Point bottom_left, top_right;",
		"        Rectangle(const Point& bl, const Point& tr) : bottom_left(bl), top_right(tr) {}",
		"    };",
		"",
		"    Rectangle bounding_box() const {",
		"        if (empty()) return Rectangle(Point(), Point());",
		"",
		"        double min_x = vertices[0].x, max_x = vertices[0].x;",
		"        double min_y = vertices[0].y, max_y = vertices[0].y;",
		"",
		"        for (const Point& p : vertices) {",
		"            min_x = min(min_x, p.x);",
		"            max_x = max(max_x, p.x);",
		"            min_y = min(min_y, p.y);",
		"            max_y = max(max_y, p.y);",
		"        }",
		"",
		"        return Rectangle(Point(min_x, min_y), Point(max_x, max_y));",
		"    }",
		"",
		"    // 简单多边形三角剖分（扇形剖分）",
		"    vector<vector<int>> triangulate() const {",
		"        vector<vector<int>> triangles;",
		"        if (size() < 3) return triangles;",
		"",
		"        for (int i = 1; i < size() - 1; i++) { triangles.push_back({0, i, i + 1}); }",
		"",
		"        return triangles;",
		"    }",
		"};",
	})
}),

-- 05_Geometry\2D\RotatingCalipers.h
s("05_geometry_2d_rotatingcalipers_h", {
	t({
		"/*",
		" * 旋转卡壳算法",
		" * 时间复杂度: O(n)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 凸包上点对的最值问题",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }  // 添加除法运算符",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    bool operator<(const Point& p) const { return x < p.x - EPS || (abs(x - p.x) < EPS && y < p.y - EPS); }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point& p) const { return (*this - p).norm2(); }",
		"};",
		"",
		"// 凸包直径（最远点对距离）",
		"double convex_diameter(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n <= 1) return 0;",
		"    if (n == 2) return convex_hull[0].distance(convex_hull[1]);",
		"",
		"    double max_dist = 0;",
		"    int j = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int next_i = (i + 1) % n;",
		"        Point edge_i = convex_hull[next_i] - convex_hull[i];",
		"",
		"        // 找到距离边i最远的点",
		"        while (true) {",
		"            int next_j = (j + 1) % n;",
		"            Point to_j = convex_hull[j] - convex_hull[i];",
		"            Point to_next_j = convex_hull[next_j] - convex_hull[i];",
		"",
		"            if ((edge_i ^ to_j) < (edge_i ^ to_next_j)) {",
		"                j = next_j;",
		"            } else {",
		"                break;",
		"            }",
		"        }",
		"",
		"        max_dist = max(max_dist, convex_hull[i].distance(convex_hull[j]));",
		"        max_dist = max(max_dist, convex_hull[next_i].distance(convex_hull[j]));",
		"    }",
		"",
		"    return max_dist;",
		"}",
		"",
		"// 凸包最小宽度（最近平行线距离）",
		"double convex_width(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n <= 2) return 0;",
		"",
		"    double min_width = 1e18;",
		"    int j = 1;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int next_i = (i + 1) % n;",
		"        Point edge = convex_hull[next_i] - convex_hull[i];",
		"",
		"        // 找到距离边i最远的点",
		"        while (true) {",
		"            int next_j = (j + 1) % n;",
		"            Point to_j = convex_hull[j] - convex_hull[i];",
		"            Point to_next_j = convex_hull[next_j] - convex_hull[i];",
		"",
		"            if (abs(edge ^ to_j) < abs(edge ^ to_next_j)) {",
		"                j = next_j;",
		"            } else {",
		"                break;",
		"            }",
		"        }",
		"",
		"        double width = abs(edge ^ (convex_hull[j] - convex_hull[i])) / edge.norm();",
		"        min_width = min(min_width, width);",
		"    }",
		"",
		"    return min_width;",
		"}",
		"",
		"// 凸包最小面积外接矩形",
		"struct Rectangle {",
		"    Point vertices[4];  // 矩形四个顶点",
		"    double area;        // 矩形面积",
		"",
		"    Rectangle() : area(1e18) {}",
		"    Rectangle(const Point& center, const Point& u, const Point& v, double w, double h) {",
		"        Point half_u = u * (w / 2);",
		"        Point half_v = v * (h / 2);",
		"        vertices[0] = center - half_u - half_v;",
		"        vertices[1] = center + half_u - half_v;",
		"        vertices[2] = center + half_u + half_v;",
		"        vertices[3] = center - half_u + half_v;",
		"        area = w * h;",
		"    }",
		"};",
		"",
		"Rectangle min_area_rectangle(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n < 3) return Rectangle();",
		"",
		"    Rectangle min_rect;",
		"    int l = 0, r = 0, u = 0;  // 左右上边界点索引",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int next_i = (i + 1) % n;",
		"        Point edge = convex_hull[next_i] - convex_hull[i];",
		"        Point unit_edge = edge / edge.norm();",
		"        Point unit_normal(-unit_edge.y, unit_edge.x);  // 法向量",
		"",
		"        // 更新边界点",
		"        while ((convex_hull[(l + 1) % n] - convex_hull[i]) * unit_edge <",
		"               (convex_hull[l] - convex_hull[i]) * unit_edge) {",
		"            l = (l + 1) % n;",
		"        }",
		"        while ((convex_hull[(r + 1) % n] - convex_hull[i]) * unit_edge >",
		"               (convex_hull[r] - convex_hull[i]) * unit_edge) {",
		"            r = (r + 1) % n;",
		"        }",
		"        while ((convex_hull[(u + 1) % n] - convex_hull[i]) * unit_normal >",
		"               (convex_hull[u] - convex_hull[i]) * unit_normal) {",
		"            u = (u + 1) % n;",
		"        }",
		"",
		"        // 计算矩形",
		"        double width = (convex_hull[r] - convex_hull[l]) * unit_edge;",
		"        double height = (convex_hull[u] - convex_hull[i]) * unit_normal;",
		"        double area = width * height;",
		"",
		"        if (area < min_rect.area) {",
		"            Point center = (convex_hull[l] + convex_hull[r]) * 0.5 + unit_normal * (height / 2);",
		"            min_rect = Rectangle(center, unit_edge, unit_normal, width, height);",
		"        }",
		"    }",
		"",
		"    return min_rect;",
		"}",
		"",
		"// 凸包中的最大三角形面积",
		"double max_triangle_area(vector<Point>& convex_hull) {",
		"    int n = convex_hull.size();",
		"    if (n < 3) return 0;",
		"",
		"    double max_area = 0;",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        int j = (i + 1) % n;",
		"        int k = (i + 2) % n;",
		"",
		"        for (int l = i; l < n; l++) {",
		"            // 对于边ij，找到使三角形面积最大的点k",
		"            while (true) {",
		"                int next_k = (k + 1) % n;",
		"                Point to_k = convex_hull[k] - convex_hull[i];",
		"                Point to_next_k = convex_hull[next_k] - convex_hull[i];",
		"                Point edge = convex_hull[j] - convex_hull[i];",
		"",
		"                if (abs(edge ^ to_k) < abs(edge ^ to_next_k)) {",
		"                    k = next_k;",
		"                } else {",
		"                    break;",
		"                }",
		"            }",
		"",
		"            double area = abs((convex_hull[j] - convex_hull[i]) ^ (convex_hull[k] - convex_hull[i])) / 2.0;",
		"            max_area = max(max_area, area);",
		"",
		"            j = (j + 1) % n;",
		"            if (j == i) break;",
		"        }",
		"    }",
		"",
		"    return max_area;",
		"}",
	})
}),

-- 05_Geometry\2D\Segment.h
s("05_geometry_2d_segment_h", {
	t({
		"/*",
		" * 二维线段类模板",
		" * 时间复杂度: 各操作均为 O(1)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 线段相关的几何计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 需要包含Point.h",
		"struct Point {",
		"    double x, y;",
		"    Point() : x(0), y(0) {}",
		"    Point(double x, double y) : x(x), y(y) {}",
		"    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }",
		"    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }",
		"    Point operator*(double t) const { return Point(x * t, y * t); }",
		"    Point operator/(double t) const { return Point(x / t, y / t); }",
		"    bool operator==(const Point& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS; }",
		"    double dot(const Point& p) const { return x * p.x + y * p.y; }",
		"    double cross(const Point& p) const { return x * p.y - y * p.x; }",
		"    double operator*(const Point& p) const { return dot(p); }",
		"    double operator^(const Point& p) const { return cross(p); }",
		"    double norm() const { return sqrt(x * x + y * y); }",
		"    double norm2() const { return x * x + y * y; }",
		"    double distance(const Point& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"struct Segment {",
		"    Point a, b;  // 线段端点",
		"",
		"    // 构造函数",
		"    Segment() {}",
		"    Segment(const Point& a, const Point& b) : a(a), b(b) {}",
		"    Segment(double x1, double y1, double x2, double y2) : a(Point(x1, y1)), b(Point(x2, y2)) {}",
		"",
		"    // 线段基本属性",
		"    double length() const { return a.distance(b); }",
		"    double length2() const { return (b - a).norm2(); }",
		"    Point direction() const { return b - a; }",
		"    Point midpoint() const { return (a + b) * 0.5; }",
		"",
		"    // 线段上的点",
		"    Point point_at(double t) const { return a + (b - a) * t; }  // t∈[0,1]",
		"",
		"    // 点到线段的距离",
		"    double distance_to_point(const Point& p) const {",
		"        Point ap = p - a, ab = b - a;",
		"        double t = ap * ab / ab.norm2();",
		"        t = max(0.0, min(1.0, t));  // 限制在[0,1]",
		"        Point closest = a + ab * t;",
		"        return p.distance(closest);",
		"    }",
		"",
		"    // 点在线段上的投影",
		"    Point project(const Point& p) const {",
		"        Point ap = p - a, ab = b - a;",
		"        double t = ap * ab / ab.norm2();",
		"        t = max(0.0, min(1.0, t));",
		"        return a + ab * t;",
		"    }",
		"",
		"    // 判断点是否在线段上",
		"    bool contains(const Point& p) const { return abs((p - a) ^ (b - a)) < EPS && (p - a) * (p - b) <= EPS; }",
		"",
		"    // 判断两线段是否相交",
		"    bool intersects(const Segment& other) const {",
		"        Point ab = b - a, cd = other.b - other.a;",
		"        Point ac = other.a - a, ad = other.b - a;",
		"        Point ca = a - other.a, cb = b - other.a;",
		"",
		"        // 快速排斥实验",
		"        if (max(a.x, b.x) < min(other.a.x, other.b.x) - EPS || max(other.a.x, other.b.x) < min(a.x, b.x) - EPS ||",
		"            max(a.y, b.y) < min(other.a.y, other.b.y) - EPS || max(other.a.y, other.b.y) < min(a.y, b.y) - EPS) {",
		"            return false;",
		"        }",
		"",
		"        // 跨立实验",
		"        double d1 = ab ^ ac;",
		"        double d2 = ab ^ ad;",
		"        double d3 = cd ^ ca;",
		"        double d4 = cd ^ cb;",
		"",
		"        if (d1 * d2 < -EPS && d3 * d4 < -EPS) return true;",
		"",
		"        // 特殊情况：端点在对方线段上",
		"        if (abs(d1) < EPS && contains(other.a)) return true;",
		"        if (abs(d2) < EPS && contains(other.b)) return true;",
		"        if (abs(d3) < EPS && other.contains(a)) return true;",
		"        if (abs(d4) < EPS && other.contains(b)) return true;",
		"",
		"        return false;",
		"    }",
		"",
		"    // 两线段交点",
		"    vector<Point> intersection(const Segment& other) const {",
		"        vector<Point> result;",
		"",
		"        Point ab = b - a, cd = other.b - other.a;",
		"        Point ac = other.a - a;",
		"",
		"        double d = ab ^ cd;",
		"        if (abs(d) < EPS) {",
		"            // 平行或共线",
		"            if (abs(ab ^ ac) < EPS) {",
		"                // 共线，可能有重叠",
		"                double t1 = 0, t2 = 1;",
		"                double s1 = (other.a - a) * ab / ab.norm2();",
		"                double s2 = (other.b - a) * ab / ab.norm2();",
		"                if (s1 > s2) swap(s1, s2);",
		"",
		"                double left = max(t1, s1);",
		"                double right = min(t2, s2);",
		"",
		"                if (left <= right + EPS) {",
		"                    if (abs(left - right) < EPS) {",
		"                        // 一个交点",
		"                        result.push_back(point_at(left));",
		"                    } else {",
		"                        // 线段重叠",
		"                        result.push_back(point_at(left));",
		"                        result.push_back(point_at(right));",
		"                    }",
		"                }",
		"            }",
		"            return result;",
		"        }",
		"",
		"        double t = (ac ^ cd) / d;",
		"        double s = (ac ^ ab) / d;",
		"",
		"        if (t >= -EPS && t <= 1 + EPS && s >= -EPS && s <= 1 + EPS) { result.push_back(point_at(t)); }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 两线段间的最短距离",
		"    double distance_to_segment(const Segment& other) const {",
		"        if (intersects(other)) return 0;",
		"",
		"        return min({distance_to_point(other.a),",
		"                    distance_to_point(other.b),",
		"                    other.distance_to_point(a),",
		"                    other.distance_to_point(b)});",
		"    }",
		"};",
	})
}),

-- 05_Geometry\3D\ConvexHull3D.h
s("05_geometry_3d_convexhull3d_h", {
	t({
		"/*",
		" * 三维凸包算法（增量法）",
		" * 时间复杂度: O(n^2)",
		" * 空间复杂度: O(n)",
		" * 适用场景: 求三维点集的凸包",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 需要包含Point3D.h或Vector3D.h",
		"struct Point3D {",
		"    double x, y, z;",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    bool operator<(const Point3D& p) const {",
		"        if (abs(x - p.x) > EPS) return x < p.x;",
		"        if (abs(y - p.y) > EPS) return y < p.y;",
		"        return z < p.z;",
		"    }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double distance(const Point3D& p) const { return (*this - p).norm(); }",
		"};",
		"",
		"struct Face {",
		"    int a, b, c;     // 面的三个顶点索引",
		"    Point3D normal;  // 面的法向量",
		"",
		"    Face() {}",
		"    Face(int a, int b, int c) : a(a), b(b), c(c) {}",
		"",
		"    // 计算面的法向量",
		"    void compute_normal(const vector<Point3D>& points) {",
		"        Point3D v1 = points[b] - points[a];",
		"        Point3D v2 = points[c] - points[a];",
		"        normal = v1.cross(v2);",
		"        if (normal.norm() > EPS) { normal = normal * (1.0 / normal.norm()); }",
		"    }",
		"",
		"    // 判断点是否在面的正侧",
		"    bool visible_from(const Point3D& p, const vector<Point3D>& points) const {",
		"        Point3D to_p = p - points[a];",
		"        return to_p.dot(normal) > EPS;",
		"    }",
		"};",
		"",
		"class ConvexHull3D {",
		"   private:",
		"    vector<Point3D> points;",
		"    vector<Face> faces;",
		"    vector<vector<int>> adj;  // 邻接表：adj[i]存储包含点i的面",
		"",
		"    // 判断四点是否共面",
		"    bool coplanar(int a, int b, int c, int d) const {",
		"        Point3D v1 = points[b] - points[a];",
		"        Point3D v2 = points[c] - points[a];",
		"        Point3D v3 = points[d] - points[a];",
		"        return abs(v1.dot(v2.cross(v3))) < EPS;",
		"    }",
		"",
		"    // 找到初始四面体",
		"    bool find_initial_tetrahedron() {",
		"        int n = points.size();",
		"        if (n < 4) return false;",
		"",
		"        // 找到不共线的三点",
		"        int p0 = 0, p1 = 1, p2 = 2;",
		"        for (p2 = 2; p2 < n; p2++) {",
		"            Point3D v1 = points[p1] - points[p0];",
		"            Point3D v2 = points[p2] - points[p0];",
		"            if (v1.cross(v2).norm() > EPS) break;",
		"        }",
		"        if (p2 == n) return false;",
		"",
		"        // 找到不共面的第四点",
		"        int p3 = p2 + 1;",
		"        for (; p3 < n; p3++) {",
		"            if (!coplanar(p0, p1, p2, p3)) break;",
		"        }",
		"        if (p3 == n) return false;",
		"",
		"        // 确保正确的方向",
		"        Point3D v1 = points[p1] - points[p0];",
		"        Point3D v2 = points[p2] - points[p0];",
		"        Point3D v3 = points[p3] - points[p0];",
		"        if (v1.dot(v2.cross(v3)) < 0) { swap(p1, p2); }",
		"",
		"        // 创建初始四面体的四个面",
		"        faces.clear();",
		"        faces.push_back(Face(p0, p1, p2));",
		"        faces.push_back(Face(p0, p2, p3));",
		"        faces.push_back(Face(p0, p3, p1));",
		"        faces.push_back(Face(p1, p3, p2));",
		"",
		"        // 计算法向量（指向外部）",
		"        for (Face& face : faces) {",
		"            face.compute_normal(points);",
		"            // 确保法向量指向外部",
		"            Point3D center = (points[face.a] + points[face.b] + points[face.c]) * (1.0 / 3.0);",
		"            Point3D other_point;",
		"            bool found = false;",
		"            for (int i = 0; i < 4; i++) {",
		"                if (i != face.a && i != face.b && i != face.c) {",
		"                    other_point = points[i];",
		"                    found = true;",
		"                    break;",
		"                }",
		"            }",
		"            if (found && (other_point - center).dot(face.normal) > 0) { face.normal = face.normal * (-1); }",
		"        }",
		"",
		"        return true;",
		"    }",
		"",
		"   public:",
		"    ConvexHull3D(vector<Point3D> pts) : points(pts) {",
		"        // 去重",
		"        sort(points.begin(), points.end());",
		"        points.erase(unique(points.begin(), points.end()), points.end());",
		"    }",
		"",
		"    bool build() {",
		"        int n = points.size();",
		"        if (n < 4) return false;",
		"",
		"        if (!find_initial_tetrahedron()) return false;",
		"",
		"        // 增量添加剩余点",
		"        for (int i = 4; i < n; i++) {",
		"            vector<int> visible_faces;",
		"",
		"            // 找到可见面",
		"            for (int j = 0; j < faces.size(); j++) {",
		"                if (faces[j].visible_from(points[i], points)) { visible_faces.push_back(j); }",
		"            }",
		"",
		"            if (visible_faces.empty()) continue;",
		"",
		"            // 收集边界边",
		"            set<pair<int, int>> boundary_edges;",
		"            for (int face_idx : visible_faces) {",
		"                Face& face = faces[face_idx];",
		"                boundary_edges.insert({min(face.a, face.b), max(face.a, face.b)});",
		"                boundary_edges.insert({min(face.b, face.c), max(face.b, face.c)});",
		"                boundary_edges.insert({min(face.c, face.a), max(face.c, face.a)});",
		"            }",
		"",
		"            // 移除内部边",
		"            set<pair<int, int>> real_boundary;",
		"            for (const auto& edge : boundary_edges) {",
		"                bool is_boundary = true;",
		"                for (int face_idx : visible_faces) {",
		"                    Face& face = faces[face_idx];",
		"                    int count = 0;",
		"                    if ((face.a == edge.first || face.a == edge.second)) count++;",
		"                    if ((face.b == edge.first || face.b == edge.second)) count++;",
		"                    if ((face.c == edge.first || face.c == edge.second)) count++;",
		"                    if (count == 2) {",
		"                        // 这条边在这个面上",
		"                        is_boundary = !is_boundary;",
		"                    }",
		"                }",
		"                if (is_boundary) { real_boundary.insert(edge); }",
		"            }",
		"",
		"            // 删除可见面",
		"            vector<Face> new_faces;",
		"            for (int j = 0; j < faces.size(); j++) {",
		"                bool visible = find(visible_faces.begin(), visible_faces.end(), j) != visible_faces.end();",
		"                if (!visible) { new_faces.push_back(faces[j]); }",
		"            }",
		"            faces = new_faces;",
		"",
		"            // 添加新面",
		"            for (const auto& edge : real_boundary) {",
		"                Face new_face(edge.first, edge.second, i);",
		"                new_face.compute_normal(points);",
		"                faces.push_back(new_face);",
		"            }",
		"        }",
		"",
		"        return true;",
		"    }",
		"",
		"    vector<Face> get_faces() const { return faces; }",
		"    vector<Point3D> get_vertices() const {",
		"        set<int> vertex_set;",
		"        for (const Face& face : faces) {",
		"            vertex_set.insert(face.a);",
		"            vertex_set.insert(face.b);",
		"            vertex_set.insert(face.c);",
		"        }",
		"        vector<Point3D> vertices;",
		"        for (int idx : vertex_set) { vertices.push_back(points[idx]); }",
		"        return vertices;",
		"    }",
		"",
		"    double volume() const {",
		"        double vol = 0;",
		"        Point3D origin(0, 0, 0);",
		"        for (const Face& face : faces) {",
		"            Point3D v1 = points[face.a];",
		"            Point3D v2 = points[face.b];",
		"            Point3D v3 = points[face.c];",
		"            vol += v1.dot(v2.cross(v3));",
		"        }",
		"        return abs(vol) / 6.0;",
		"    }",
		"};",
		"",
		"// 简化接口",
		"vector<vector<int>> convex_hull_3d(vector<Point3D> points) {",
		"    ConvexHull3D hull(points);",
		"    if (!hull.build()) return {};",
		"",
		"    vector<Face> faces = hull.get_faces();",
		"    vector<vector<int>> result;",
		"    for (const Face& face : faces) { result.push_back({face.a, face.b, face.c}); }",
		"    return result;",
		"}",
	})
}),

-- 05_Geometry\3D\Plane3D.h
s("05_geometry_3d_plane3d_h", {
	t({
		"/**",
		" * 三维平面类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：三维空间中的平面相关计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 使用Point3D类（需要包含Point3D.h）",
		"struct Point3D {",
		"    double x, y, z;",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    Point3D operator/(double t) const { return Point3D(x / t, y / t, z / t); }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double norm2() const { return x * x + y * y + z * z; }",
		"    Point3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point3D() : *this / len;",
		"    }",
		"};",
		"",
		"// 三维平面类",
		"struct Plane3D {",
		"    Point3D normal;  // 法向量",
		"    double d;        // 平面方程：normal·x + d = 0",
		"",
		"    // 构造函数",
		"    Plane3D() : d(0) {}",
		"",
		"    // 从法向量和平面上一点构造",
		"    Plane3D(const Point3D& n, const Point3D& point) : normal(n.normalize()) { d = -normal.dot(point); }",
		"",
		"    // 从三点构造平面",
		"    Plane3D(const Point3D& a, const Point3D& b, const Point3D& c) {",
		"        normal = (b - a).cross(c - a).normalize();",
		"        d = -normal.dot(a);",
		"    }",
		"",
		"    // 从平面方程 ax + by + cz + d = 0 构造",
		"    Plane3D(double a, double b, double c, double D) {",
		"        normal = Point3D(a, b, c);",
		"        double len = normal.norm();",
		"        if (len > EPS) {",
		"            normal = normal / len;",
		"            d = D / len;",
		"        } else {",
		"            normal = Point3D(0, 0, 1);",
		"            d = 0;",
		"        }",
		"    }",
		"",
		"    // 点到平面的距离（有向距离）",
		"    double distance_to_point(const Point3D& p) const { return normal.dot(p) + d; }",
		"",
		"    // 点到平面的距离（绝对距离）",
		"    double abs_distance_to_point(const Point3D& p) const { return abs(distance_to_point(p)); }",
		"",
		"    // 判断点是否在平面上",
		"    bool contains_point(const Point3D& p) const { return abs(distance_to_point(p)) < EPS; }",
		"",
		"    // 点在平面上的投影",
		"    Point3D project_point(const Point3D& p) const {",
		"        double dist = distance_to_point(p);",
		"        return p - normal * dist;",
		"    }",
		"",
		"    // 点关于平面的对称点",
		"    Point3D reflect_point(const Point3D& p) const {",
		"        double dist = distance_to_point(p);",
		"        return p - normal * (2 * dist);",
		"    }",
		"",
		"    // 判断两平面是否平行",
		"    bool is_parallel(const Plane3D& other) const { return abs(abs(normal.dot(other.normal)) - 1.0) < EPS; }",
		"",
		"    // 判断两平面是否垂直",
		"    bool is_perpendicular(const Plane3D& other) const { return abs(normal.dot(other.normal)) < EPS; }",
		"",
		"    // 两平面的交线（如果存在）",
		"    struct Line3D {",
		"        Point3D point;      // 直线上一点",
		"        Point3D direction;  // 方向向量",
		"",
		"        Line3D() {}",
		"        Line3D(const Point3D& p, const Point3D& dir) : point(p), direction(dir.normalize()) {}",
		"    };",
		"",
		"    Line3D intersection_line(const Plane3D& other) const {",
		"        if (is_parallel(other)) {",
		"            return Line3D();  // 平行，无交线或重合",
		"        }",
		"",
		"        Point3D dir = normal.cross(other.normal);",
		"",
		"        // 找交线上的一点",
		"        Point3D p;",
		"        double max_coord = max({abs(dir.x), abs(dir.y), abs(dir.z)});",
		"",
		"        if (abs(dir.x - max_coord) < EPS) {",
		"            // 在 yz 平面上求解",
		"            double det = normal.y * other.normal.z - normal.z * other.normal.y;",
		"            if (abs(det) > EPS) {",
		"                p.x = 0;",
		"                p.y = (-d * other.normal.z + other.d * normal.z) / det;",
		"                p.z = (d * other.normal.y - other.d * normal.y) / det;",
		"            }",
		"        } else if (abs(dir.y - max_coord) < EPS) {",
		"            // 在 xz 平面上求解",
		"            double det = normal.x * other.normal.z - normal.z * other.normal.x;",
		"            if (abs(det) > EPS) {",
		"                p.y = 0;",
		"                p.x = (-d * other.normal.z + other.d * normal.z) / det;",
		"                p.z = (d * other.normal.x - other.d * normal.x) / det;",
		"            }",
		"        } else {",
		"            // 在 xy 平面上求解",
		"            double det = normal.x * other.normal.y - normal.y * other.normal.x;",
		"            if (abs(det) > EPS) {",
		"                p.z = 0;",
		"                p.x = (-d * other.normal.y + other.d * normal.y) / det;",
		"                p.y = (d * other.normal.x - other.d * normal.x) / det;",
		"            }",
		"        }",
		"",
		"        return Line3D(p, dir);",
		"    }",
		"",
		"    // 三平面的交点",
		"    static Point3D intersection_point(const Plane3D& p1, const Plane3D& p2, const Plane3D& p3) {",
		"        // 求解线性方程组",
		"        // n1·x + d1 = 0",
		"        // n2·x + d2 = 0",
		"        // n3·x + d3 = 0",
		"",
		"        Point3D n1 = p1.normal, n2 = p2.normal, n3 = p3.normal;",
		"        double d1 = p1.d, d2 = p2.d, d3 = p3.d;",
		"",
		"        double det = n1.dot(n2.cross(n3));",
		"        if (abs(det) < EPS) {",
		"            return Point3D(1e18, 1e18, 1e18);  // 无唯一解",
		"        }",
		"",
		"        Point3D result = n2.cross(n3) * (-d1) + n3.cross(n1) * (-d2) + n1.cross(n2) * (-d3);",
		"        return result / det;",
		"    }",
		"};",
		"",
		"// 三维直线类",
		"struct Line3D {",
		"    Point3D point;      // 直线上一点",
		"    Point3D direction;  // 方向向量",
		"",
		"    Line3D() {}",
		"    Line3D(const Point3D& p, const Point3D& dir) : point(p), direction(dir.normalize()) {}",
		"    Line3D(const Point3D& a, const Point3D& b) : point(a), direction((b - a).normalize()) {}",
		"",
		"    // 直线上的参数方程点",
		"    Point3D point_at(double t) const { return point + direction * t; }",
		"",
		"    // 点到直线的距离",
		"    double distance_to_point(const Point3D& p) const {",
		"        Point3D to_p = p - point;",
		"        return to_p.cross(direction).norm();",
		"    }",
		"",
		"    // 点在直线上的投影",
		"    Point3D project_point(const Point3D& p) const {",
		"        Point3D to_p = p - point;",
		"        double t = to_p.dot(direction);",
		"        return point_at(t);",
		"    }",
		"",
		"    // 判断点是否在直线上",
		"    bool contains_point(const Point3D& p) const { return distance_to_point(p) < EPS; }",
		"",
		"    // 两直线的最短距离",
		"    double distance_to_line(const Line3D& other) const {",
		"        Point3D w = point - other.point;",
		"        Point3D cross_dir = direction.cross(other.direction);",
		"",
		"        if (cross_dir.norm() < EPS) {",
		"            // 平行或重合",
		"            return distance_to_point(other.point);",
		"        }",
		"",
		"        return abs(w.dot(cross_dir)) / cross_dir.norm();",
		"    }",
		"",
		"    // 两直线的交点（如果相交）",
		"    Point3D intersection_point(const Line3D& other) const {",
		"        Point3D w = point - other.point;",
		"        Point3D cross_dir = direction.cross(other.direction);",
		"",
		"        if (cross_dir.norm() < EPS) {",
		"            // 平行或重合",
		"            return Point3D(1e18, 1e18, 1e18);",
		"        }",
		"",
		"        double t = w.cross(other.direction).dot(cross_dir) / cross_dir.norm2();",
		"        return point_at(t);",
		"    }",
		"",
		"    // 直线与平面的交点",
		"    Point3D intersection_with_plane(const Plane3D& plane) const {",
		"        double denom = direction.dot(plane.normal);",
		"        if (abs(denom) < EPS) {",
		"            // 平行或在平面内",
		"            return Point3D(1e18, 1e18, 1e18);",
		"        }",
		"",
		"        double t = -(plane.normal.dot(point) + plane.d) / denom;",
		"        return point_at(t);",
		"    }",
		"",
		"    // 判断直线是否与平面平行",
		"    bool is_parallel_to_plane(const Plane3D& plane) const { return abs(direction.dot(plane.normal)) < EPS; }",
		"",
		"    // 判断直线是否在平面内",
		"    bool is_in_plane(const Plane3D& plane) const { return is_parallel_to_plane(plane) && plane.contains_point(point); }",
		"};",
		"",
		"// 全局函数",
		"double point_to_plane_distance(const Point3D& p, const Plane3D& plane) { return plane.abs_distance_to_point(p); }",
		"",
		"double point_to_line_distance(const Point3D& p, const Line3D& line) { return line.distance_to_point(p); }",
		"",
		"double line_to_line_distance(const Line3D& l1, const Line3D& l2) { return l1.distance_to_line(l2); }",
	})
}),

-- 05_Geometry\3D\Point3D.h
s("05_geometry_3d_point3d_h", {
	t({
		"/**",
		" * 三维点/向量类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：三维几何计算的基础类",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"struct Point3D {",
		"    double x, y, z;",
		"",
		"    // 构造函数",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"",
		"    // 基本运算符重载",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    Point3D operator/(double t) const { return Point3D(x / t, y / t, z / t); }",
		"    Point3D operator-() const { return Point3D(-x, -y, -z); }",
		"",
		"    Point3D& operator+=(const Point3D& p) {",
		"        x += p.x;",
		"        y += p.y;",
		"        z += p.z;",
		"        return *this;",
		"    }",
		"    Point3D& operator-=(const Point3D& p) {",
		"        x -= p.x;",
		"        y -= p.y;",
		"        z -= p.z;",
		"        return *this;",
		"    }",
		"    Point3D& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        z *= t;",
		"        return *this;",
		"    }",
		"    Point3D& operator/=(double t) {",
		"        x /= t;",
		"        y /= t;",
		"        z /= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算符",
		"    bool operator<(const Point3D& p) const {",
		"        if (abs(x - p.x) > EPS) return x < p.x;",
		"        if (abs(y - p.y) > EPS) return y < p.y;",
		"        return z < p.z - EPS;",
		"    }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    bool operator!=(const Point3D& p) const { return !(*this == p); }",
		"",
		"    // 向量基本运算",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }  // 点积",
		"",
		"    // 叉积（返回向量）",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"",
		"    // 长度相关",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }  // 向量长度",
		"    double norm2() const { return x * x + y * y + z * z; }       // 长度平方",
		"",
		"    // 单位化",
		"    Point3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point3D(0, 0, 0) : Point3D(x / len, y / len, z / len);",
		"    }",
		"",
		"    // 距离相关",
		"    double distance(const Point3D& p) const { return (*this - p).norm(); }",
		"    double distance2(const Point3D& p) const { return (*this - p).norm2(); }",
		"",
		"    // 投影到平面（沿给定法向量方向）",
		"    Point3D project_to_plane(const Point3D& normal, const Point3D& point_on_plane) const {",
		"        Point3D n = normal.normalize();",
		"        double d = (*this - point_on_plane).dot(n);",
		"        return *this - n * d;",
		"    }",
		"",
		"    // 绕轴旋转（Rodrigues旋转公式）",
		"    Point3D rotate_around_axis(const Point3D& axis, double angle) const {",
		"        Point3D k = axis.normalize();",
		"        double cos_theta = cos(angle);",
		"        double sin_theta = sin(angle);",
		"        return *this * cos_theta + k.cross(*this) * sin_theta + k * (k.dot(*this)) * (1 - cos_theta);",
		"    }",
		"",
		"    // 输出",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \" \" << z << \"\\n\"; }",
		"};",
		"",
		"// 类型别名",
		"using Vector3D = Point3D;",
		"",
		"// 全局函数",
		"double dot(const Point3D& a, const Point3D& b) { return a.dot(b); }",
		"Point3D cross(const Point3D& a, const Point3D& b) { return a.cross(b); }",
		"double distance(const Point3D& a, const Point3D& b) { return a.distance(b); }",
		"double distance2(const Point3D& a, const Point3D& b) { return a.distance2(b); }",
		"",
		"// 三点构成的三角形面积",
		"double triangle_area(const Point3D& a, const Point3D& b, const Point3D& c) { return cross(b - a, c - a).norm() / 2.0; }",
		"",
		"// 四点构成的四面体体积（有向体积）",
		"double tetrahedron_volume(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return dot(b - a, cross(c - a, d - a)) / 6.0;",
		"}",
		"",
		"// 判断四点是否共面",
		"bool are_coplanar(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return abs(tetrahedron_volume(a, b, c, d)) < EPS;",
		"}",
		"",
		"// 三点确定平面的法向量",
		"Point3D plane_normal(const Point3D& a, const Point3D& b, const Point3D& c) { return cross(b - a, c - a).normalize(); }",
		"",
		"// 求两向量的夹角（弧度）",
		"double angle_between_vectors(const Point3D& a, const Point3D& b) {",
		"    double cos_theta = dot(a, b) / (a.norm() * b.norm());",
		"    cos_theta = max(-1.0, min(1.0, cos_theta));  // 避免精度误差",
		"    return acos(cos_theta);",
		"}",
	})
}),

-- 05_Geometry\3D\Sphere3D.h
s("05_geometry_3d_sphere3d_h", {
	t({
		"/**",
		" * 三维球体类模板",
		" * 时间复杂度：各操作均为 O(1)",
		" * 空间复杂度：O(1)",
		" * 适用场景：三维空间中的球体相关计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 使用Point3D类（需要包含Point3D.h）",
		"struct Point3D {",
		"    double x, y, z;",
		"    Point3D() : x(0), y(0), z(0) {}",
		"    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"    Point3D operator+(const Point3D& p) const { return Point3D(x + p.x, y + p.y, z + p.z); }",
		"    Point3D operator-(const Point3D& p) const { return Point3D(x - p.x, y - p.y, z - p.z); }",
		"    Point3D operator*(double t) const { return Point3D(x * t, y * t, z * t); }",
		"    Point3D operator/(double t) const { return Point3D(x / t, y / t, z / t); }",
		"    bool operator==(const Point3D& p) const { return abs(x - p.x) < EPS && abs(y - p.y) < EPS && abs(z - p.z) < EPS; }",
		"    double dot(const Point3D& p) const { return x * p.x + y * p.y + z * p.z; }",
		"    Point3D cross(const Point3D& p) const { return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x); }",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double norm2() const { return x * x + y * y + z * z; }",
		"    double distance(const Point3D& p) const { return (*this - p).norm(); }",
		"    Point3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Point3D() : *this / len;",
		"    }",
		"};",
		"",
		"struct Plane3D {",
		"    Point3D normal;",
		"    double d;",
		"    Plane3D() : d(0) {}",
		"    Plane3D(const Point3D& n, const Point3D& point) : normal(n.normalize()) { d = -normal.dot(point); }",
		"    double distance_to_point(const Point3D& p) const { return normal.dot(p) + d; }",
		"    double abs_distance_to_point(const Point3D& p) const { return abs(distance_to_point(p)); }",
		"    bool contains_point(const Point3D& p) const { return abs(distance_to_point(p)) < EPS; }",
		"};",
		"",
		"struct Line3D {",
		"    Point3D point, direction;",
		"    Line3D() {}",
		"    Line3D(const Point3D& p, const Point3D& dir) : point(p), direction(dir.normalize()) {}",
		"    Point3D point_at(double t) const { return point + direction * t; }",
		"    double distance_to_point(const Point3D& p) const {",
		"        Point3D to_p = p - point;",
		"        return to_p.cross(direction).norm();",
		"    }",
		"};",
		"",
		"// 三维球体类",
		"struct Sphere3D {",
		"    Point3D center;  // 球心",
		"    double radius;   // 半径",
		"",
		"    // 构造函数",
		"    Sphere3D() : radius(0) {}",
		"    Sphere3D(const Point3D& c, double r) : center(c), radius(r) {}",
		"    Sphere3D(double x, double y, double z, double r) : center(x, y, z), radius(r) {}",
		"",
		"    // 比较运算符",
		"    bool operator==(const Sphere3D& other) const { return center == other.center && abs(radius - other.radius) < EPS; }",
		"",
		"    // 球体的基本属性",
		"    double volume() const { return 4.0 * PI * radius * radius * radius / 3.0; }",
		"    double surface_area() const { return 4.0 * PI * radius * radius; }",
		"    double diameter() const { return 2 * radius; }",
		"",
		"    // 点与球的关系",
		"    // 返回值：-1内部，0边界，1外部",
		"    int point_relation(const Point3D& p) const {",
		"        double d = center.distance(p);",
		"        if (d < radius - EPS) return -1;  // 内部",
		"        if (d > radius + EPS) return 1;   // 外部",
		"        return 0;                         // 边界",
		"    }",
		"",
		"    bool contains(const Point3D& p) const { return point_relation(p) <= 0; }",
		"    bool contains_strictly(const Point3D& p) const { return point_relation(p) < 0; }",
		"    bool on_sphere(const Point3D& p) const { return point_relation(p) == 0; }",
		"",
		"    // 点到球面的最近距离",
		"    double distance_to_point(const Point3D& p) const { return max(0.0, center.distance(p) - radius); }",
		"",
		"    // 直线与球的关系",
		"    // 返回值：-1相离，0相切，1相交",
		"    int line_relation(const Line3D& line) const {",
		"        double d = line.distance_to_point(center);",
		"",
		"        if (d > radius + EPS) return -1;  // 相离",
		"        if (d < radius - EPS) return 1;   // 相交",
		"        return 0;                         // 相切",
		"    }",
		"",
		"    // 直线与球的交点",
		"    vector<Point3D> line_intersection(const Line3D& line) const {",
		"        vector<Point3D> result;",
		"",
		"        // 计算球心到直线的距离",
		"        Point3D to_center = center - line.point;",
		"        double t0 = to_center.dot(line.direction);",
		"        Point3D closest = line.point_at(t0);",
		"        double d = center.distance(closest);",
		"",
		"        if (d > radius + EPS) return result;  // 无交点",
		"",
		"        if (abs(d - radius) < EPS) {",
		"            // 相切，一个交点",
		"            result.push_back(closest);",
		"        } else {",
		"            // 相交，两个交点",
		"            double delta = sqrt(radius * radius - d * d);",
		"            result.push_back(line.point_at(t0 + delta));",
		"            result.push_back(line.point_at(t0 - delta));",
		"        }",
		"",
		"        return result;",
		"    }",
		"",
		"    // 平面与球的关系",
		"    // 返回值：-1相离，0相切，1相交",
		"    int plane_relation(const Plane3D& plane) const {",
		"        double d = plane.abs_distance_to_point(center);",
		"",
		"        if (d > radius + EPS) return -1;  // 相离",
		"        if (d < radius - EPS) return 1;   // 相交",
		"        return 0;                         // 相切",
		"    }",
		"",
		"    // 平面与球的交线（圆）",
		"    struct Circle3D {",
		"        Point3D center;",
		"        double radius;",
		"        Point3D normal;  // 圆所在平面的法向量",
		"",
		"        Circle3D() : radius(0) {}",
		"        Circle3D(const Point3D& c, double r, const Point3D& n) : center(c), radius(r), normal(n) {}",
		"",
		"        double area() const { return PI * radius * radius; }",
		"        double circumference() const { return 2 * PI * radius; }",
		"    };",
		"",
		"    Circle3D plane_intersection(const Plane3D& plane) const {",
		"        double d = plane.abs_distance_to_point(center);",
		"        if (d > radius + EPS) return Circle3D();  // 无交线",
		"",
		"        // 球心在平面上的投影",
		"        Point3D proj_center = center - plane.normal * plane.distance_to_point(center);",
		"",
		"        if (abs(d - radius) < EPS) {",
		"            // 相切，交点为一个点（半径为0的圆）",
		"            return Circle3D(proj_center, 0, plane.normal);",
		"        } else {",
		"            // 相交，交线为圆",
		"            double circle_radius = sqrt(radius * radius - d * d);",
		"            return Circle3D(proj_center, circle_radius, plane.normal);",
		"        }",
		"    }",
		"",
		"    // 两球关系",
		"    // 返回值：-1外离，0外切，1相交，2内切，3内含",
		"    int sphere_relation(const Sphere3D& other) const {",
		"        double d = center.distance(other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        if (d > r1 + r2 + EPS) return -1;           // 外离",
		"        if (abs(d - r1 - r2) < EPS) return 0;       // 外切",
		"        if (abs(d - abs(r1 - r2)) < EPS) return 2;  // 内切",
		"        if (d < abs(r1 - r2) - EPS) return 3;       // 内含",
		"        return 1;                                   // 相交",
		"    }",
		"",
		"    // 两球交线（圆）",
		"    Circle3D sphere_intersection(const Sphere3D& other) const {",
		"        double d = center.distance(other.center);",
		"        double r1 = radius, r2 = other.radius;",
		"",
		"        // 无交线的情况",
		"        if (d > r1 + r2 + EPS || d < abs(r1 - r2) - EPS || d < EPS) { return Circle3D(); }",
		"",
		"        // 计算交圆",
		"        double a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);",
		"        double h = sqrt(r1 * r1 - a * a);",
		"",
		"        Point3D circle_center = center + (other.center - center) * (a / d);",
		"        Point3D normal = (other.center - center).normalize();",
		"",
		"        if (abs(h) < EPS) {",
		"            // 一个交点（相切）",
		"            return Circle3D(circle_center, 0, normal);",
		"        } else {",
		"            // 交圆",
		"            return Circle3D(circle_center, h, normal);",
		"        }",
		"    }",
		"",
		"    // 过球外一点的切平面的切点圆",
		"    Circle3D tangent_circle(const Point3D& p) const {",
		"        if (contains_strictly(p)) return Circle3D();  // 点在球内无切平面",
		"",
		"        double d = center.distance(p);",
		"        if (on_sphere(p)) {",
		"            // 点在球面上，切平面为过该点且垂直于半径的平面",
		"            Point3D normal = (p - center).normalize();",
		"            return Circle3D(p, 0, normal);",
		"        }",
		"",
		"        // 点在球外，切点构成一个圆",
		"        double cos_theta = radius / d;",
		"        double sin_theta = sqrt(1 - cos_theta * cos_theta);",
		"        double circle_radius = radius * sin_theta;",
		"        double dist_to_circle = radius * cos_theta;",
		"",
		"        Point3D direction = (p - center).normalize();",
		"        Point3D circle_center = center + direction * dist_to_circle;",
		"",
		"        return Circle3D(circle_center, circle_radius, direction);",
		"    }",
		"};",
		"",
		"// 四点确定球（外接球）",
		"Sphere3D circumsphere(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    // 建立线性方程组求解球心",
		"    Point3D ba = b - a, ca = c - a, da = d - a;",
		"    double ba2 = ba.norm2(), ca2 = ca.norm2(), da2 = da.norm2();",
		"",
		"    // 计算行列式",
		"    double det = ba.dot(ca.cross(da)) * 2;",
		"    if (abs(det) < EPS) return Sphere3D(Point3D(0, 0, 0), -1);  // 四点共面",
		"",
		"    Point3D center = a + (ca.cross(da) * ba2 + da.cross(ba) * ca2 + ba.cross(ca) * da2) / det;",
		"    double radius = center.distance(a);",
		"",
		"    return Sphere3D(center, radius);",
		"}",
		"",
		"// 最小球覆盖（Welzl算法的三维版本）",
		"Sphere3D min_enclosing_sphere(vector<Point3D> points) {",
		"    if (points.empty()) return Sphere3D();",
		"    if (points.size() == 1) return Sphere3D(points[0], 0);",
		"",
		"    random_shuffle(points.begin(), points.end());",
		"",
		"    Sphere3D sphere;",
		"    int n = points.size();",
		"",
		"    for (int i = 0; i < n; i++) {",
		"        if (!sphere.contains(points[i])) {",
		"            sphere = Sphere3D((points[0] + points[i]) * 0.5, points[0].distance(points[i]) * 0.5);",
		"            for (int j = 1; j < i; j++) {",
		"                if (!sphere.contains(points[j])) {",
		"                    // 两点确定直径",
		"                    sphere = Sphere3D((points[i] + points[j]) * 0.5, points[i].distance(points[j]) * 0.5);",
		"                    for (int k = 0; k < j; k++) {",
		"                        if (!sphere.contains(points[k])) {",
		"                            // 三点确定圆，球心在垂直于三点平面的直线上",
		"                            Point3D normal = (points[j] - points[i]).cross(points[k] - points[i]).normalize();",
		"                            Point3D mid = (points[i] + points[j] + points[k]) / 3;",
		"",
		"                            // 寻找最优球心（简化处理）",
		"                            for (int l = 0; l < k; l++) {",
		"                                if (!sphere.contains(points[l])) {",
		"                                    sphere = circumsphere(points[i], points[j], points[k], points[l]);",
		"                                    break;",
		"                                }",
		"                            }",
		"                        }",
		"                    }",
		"                }",
		"            }",
		"        }",
		"    }",
		"",
		"    return sphere;",
		"}",
	})
}),

-- 05_Geometry\3D\Vector3D.h
s("05_geometry_3d_vector3d_h", {
	t({
		"/*",
		" * 三维向量类模板",
		" * 时间复杂度: 各操作均为 O(1)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 三维几何计算的基础类",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"struct Vector3D {",
		"    double x, y, z;",
		"",
		"    // 构造函数",
		"    Vector3D() : x(0), y(0), z(0) {}",
		"    Vector3D(double x, double y, double z) : x(x), y(y), z(z) {}",
		"",
		"    // 基本运算符重载",
		"    Vector3D operator+(const Vector3D& v) const { return Vector3D(x + v.x, y + v.y, z + v.z); }",
		"    Vector3D operator-(const Vector3D& v) const { return Vector3D(x - v.x, y - v.y, z - v.z); }",
		"    Vector3D operator*(double t) const { return Vector3D(x * t, y * t, z * t); }",
		"    Vector3D operator/(double t) const { return Vector3D(x / t, y / t, z / t); }",
		"    Vector3D operator-() const { return Vector3D(-x, -y, -z); }",
		"",
		"    Vector3D& operator+=(const Vector3D& v) {",
		"        x += v.x;",
		"        y += v.y;",
		"        z += v.z;",
		"        return *this;",
		"    }",
		"    Vector3D& operator-=(const Vector3D& v) {",
		"        x -= v.x;",
		"        y -= v.y;",
		"        z -= v.z;",
		"        return *this;",
		"    }",
		"    Vector3D& operator*=(double t) {",
		"        x *= t;",
		"        y *= t;",
		"        z *= t;",
		"        return *this;",
		"    }",
		"",
		"    // 比较运算符",
		"    bool operator==(const Vector3D& v) const { return abs(x - v.x) < EPS && abs(y - v.y) < EPS && abs(z - v.z) < EPS; }",
		"    bool operator!=(const Vector3D& v) const { return !(*this == v); }",
		"",
		"    // 向量运算",
		"    double dot(const Vector3D& v) const { return x * v.x + y * v.y + z * v.z; }",
		"    Vector3D cross(const Vector3D& v) const {",
		"        return Vector3D(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);",
		"    }",
		"",
		"    // 运算符重载：点乘和叉乘",
		"    double operator*(const Vector3D& v) const { return dot(v); }",
		"    Vector3D operator^(const Vector3D& v) const { return cross(v); }",
		"",
		"    // 长度相关",
		"    double norm() const { return sqrt(x * x + y * y + z * z); }",
		"    double norm2() const { return x * x + y * y + z * z; }",
		"",
		"    // 单位化",
		"    Vector3D normalize() const {",
		"        double len = norm();",
		"        return len < EPS ? Vector3D(0, 0, 0) : Vector3D(x / len, y / len, z / len);",
		"    }",
		"",
		"    // 距离",
		"    double distance(const Vector3D& v) const { return (*this - v).norm(); }",
		"    double distance2(const Vector3D& v) const { return (*this - v).norm2(); }",
		"",
		"    // 角度",
		"    double angle(const Vector3D& v) const {",
		"        double cos_theta = dot(v) / (norm() * v.norm());",
		"        cos_theta = max(-1.0, min(1.0, cos_theta));  // 防止数值误差",
		"        return acos(cos_theta);",
		"    }",
		"",
		"    // 投影",
		"    Vector3D project(const Vector3D& v) const { return v * (dot(v) / v.norm2()); }",
		"",
		"    // 判断是否平行",
		"    bool parallel(const Vector3D& v) const { return cross(v).norm() < EPS; }",
		"",
		"    // 判断是否垂直",
		"    bool perpendicular(const Vector3D& v) const { return abs(dot(v)) < EPS; }",
		"",
		"    // 输出",
		"    void print() const { cout << fixed << setprecision(10) << x << \" \" << y << \" \" << z << \"\\n\"; }",
		"};",
		"",
		"// 类型别名",
		"using Point3D = Vector3D;",
		"",
		"// 全局函数",
		"double dot(const Vector3D& a, const Vector3D& b) { return a.dot(b); }",
		"Vector3D cross(const Vector3D& a, const Vector3D& b) { return a.cross(b); }",
		"double distance(const Vector3D& a, const Vector3D& b) { return a.distance(b); }",
		"double distance2(const Vector3D& a, const Vector3D& b) { return a.distance2(b); }",
		"",
		"// 混合积（标量三重积）",
		"double scalar_triple_product(const Vector3D& a, const Vector3D& b, const Vector3D& c) { return a * (b ^ c); }",
		"",
		"// 向量三重积",
		"Vector3D vector_triple_product(const Vector3D& a, const Vector3D& b, const Vector3D& c) {",
		"    return b * (a * c) - c * (a * b);",
		"}",
		"",
		"// 四面体体积",
		"double tetrahedron_volume(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return abs(scalar_triple_product(b - a, c - a, d - a)) / 6.0;",
		"}",
		"",
		"// 判断四点共面",
		"bool coplanar(const Point3D& a, const Point3D& b, const Point3D& c, const Point3D& d) {",
		"    return abs(scalar_triple_product(b - a, c - a, d - a)) < EPS;",
		"}",
	})
}),

-- 05_Geometry\Utils\Intersection.h
s("05_geometry_utils_intersection_h", {
	t({
		"/*",
		" * 几何相交和数值计算工具",
		" * 时间复杂度: 各函数不同",
		" * 空间复杂度: O(1) - O(n)",
		" * 适用场景: 几何相交判断和数值计算",
		" */",
		"",
		"const double EPS = 1e-9;",
		"",
		"// 高斯消元法求解线性方程组",
		"class LinearSolver {",
		"   private:",
		"    vector<vector<double>> matrix;",
		"    vector<double> result;",
		"    int n;",
		"",
		"   public:",
		"    LinearSolver(int size) : n(size) {",
		"        matrix.assign(n, vector<double>(n + 1, 0));",
		"        result.assign(n, 0);",
		"    }",
		"",
		"    void set_coeff(int row, int col, double val) { matrix[row][col] = val; }",
		"    void set_const(int row, double val) { matrix[row][n] = val; }",
		"",
		"    bool solve() {",
		"        for (int i = 0; i < n; i++) {",
		"            // 选主元",
		"            int pivot = i;",
		"            for (int j = i + 1; j < n; j++) {",
		"                if (fabs(matrix[j][i]) > fabs(matrix[pivot][i])) { pivot = j; }",
		"            }",
		"",
		"            if (fabs(matrix[pivot][i]) < EPS) return false;",
		"",
		"            if (pivot != i) swap(matrix[i], matrix[pivot]);",
		"",
		"            // 消元",
		"            for (int j = i + 1; j < n; j++) {",
		"                double factor = matrix[j][i] / matrix[i][i];",
		"                for (int k = i; k <= n; k++) { matrix[j][k] -= factor * matrix[i][k]; }",
		"            }",
		"        }",
		"",
		"        // 回代",
		"        for (int i = n - 1; i >= 0; i--) {",
		"            result[i] = matrix[i][n];",
		"            for (int j = i + 1; j < n; j++) { result[i] -= matrix[i][j] * result[j]; }",
		"            result[i] /= matrix[i][i];",
		"        }",
		"        return true;",
		"    }",
		"",
		"    double get_result(int i) { return result[i]; }",
		"};",
		"",
		"// 二分法求方程根",
		"template <typename F>",
		"double bisection_method(F f, double a, double b, double eps = EPS) {",
		"    if (f(a) * f(b) > 0) return NAN;",
		"",
		"    while (b - a > eps) {",
		"        double mid = (a + b) / 2;",
		"        if (f(a) * f(mid) <= 0) {",
		"            b = mid;",
		"        } else {",
		"            a = mid;",
		"        }",
		"    }",
		"    return (a + b) / 2;",
		"}",
		"",
		"// 牛顿法求方程根",
		"template <typename F, typename DF>",
		"double newton_method(F f, DF df, double x0, int max_iter = 100) {",
		"    double x = x0;",
		"    for (int i = 0; i < max_iter; i++) {",
		"        double fx = f(x);",
		"        double dfx = df(x);",
		"        if (fabs(dfx) < EPS) break;",
		"        double new_x = x - fx / dfx;",
		"        if (fabs(new_x - x) < EPS) break;",
		"        x = new_x;",
		"    }",
		"    return x;",
		"}",
		"",
		"// 三分法求单峰函数极值",
		"template <typename F>",
		"double ternary_search(F f, double left, double right, bool find_max = true) {",
		"    for (int iter = 0; iter < 100; iter++) {",
		"        double m1 = left + (right - left) / 3;",
		"        double m2 = right - (right - left) / 3;",
		"        if ((f(m1) > f(m2)) == find_max) {",
		"            right = m2;",
		"        } else {",
		"            left = m1;",
		"        }",
		"    }",
		"    return (left + right) / 2;",
		"}",
		"",
		"// Simpson积分",
		"template <typename F>",
		"double simpson_integral(F f, double a, double b, int n = 1000) {",
		"    double h = (b - a) / n;",
		"    double sum = f(a) + f(b);",
		"    for (int i = 1; i < n; i++) {",
		"        double x = a + i * h;",
		"        sum += (i % 2 == 1 ? 4 : 2) * f(x);",
		"    }",
		"    return sum * h / 3;",
		"}",
		"",
		"// 自适应Simpson积分",
		"template <typename F>",
		"double adaptive_simpson(F f, double a, double b, double eps = EPS, int max_depth = 15) {",
		"    function<double(double, double, int)> simpson15 = [&](double l, double r, int depth) -> double {",
		"        double mid = (l + r) / 2;",
		"        double left = (l + mid) / 2;",
		"        double right = (mid + r) / 2;",
		"",
		"        double s1 = (r - l) / 6 * (f(l) + 4 * f(mid) + f(r));",
		"        double s2 = (mid - l) / 6 * (f(l) + 4 * f(left) + f(mid)) + (r - mid) / 6 * (f(mid) + 4 * f(right) + f(r));",
		"",
		"        if (depth <= 0 || fabs(s1 - s2) <= 15 * eps) { return s2 + (s2 - s1) / 15; }",
		"",
		"        return simpson15(l, mid, depth - 1) + simpson15(mid, r, depth - 1);",
		"    };",
		"",
		"    return simpson15(a, b, max_depth);",
		"}",
		"",
		"// 拉格朗日插值",
		"class LagrangeInterpolation {",
		"   private:",
		"    vector<pair<double, double>> points;",
		"",
		"   public:",
		"    void add_point(double x, double y) { points.push_back({x, y}); }",
		"",
		"    double interpolate(double x) {",
		"        double result = 0;",
		"        int n = points.size();",
		"",
		"        for (int i = 0; i < n; i++) {",
		"            double term = points[i].second;",
		"            for (int j = 0; j < n; j++) {",
		"                if (i != j) { term *= (x - points[j].first) / (points[i].first - points[j].first); }",
		"            }",
		"            result += term;",
		"        }",
		"        return result;",
		"    }",
		"};",
		"",
		"// 格点相关函数",
		"long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }",
		"",
		"// Pick定理：求多边形内部格点数",
		"long long pick_theorem(double area, long long boundary_points) {",
		"    return (long long)(area + 0.5) - boundary_points / 2 + 1;",
		"}",
		"",
		"// 线段上的格点数（不包括端点）",
		"long long lattice_points_on_segment(long long x1, long long y1, long long x2, long long y2) {",
		"    return gcd(abs(x2 - x1), abs(y2 - y1)) - 1;",
		"}",
		"",
		"// FFT快速傅里叶变换",
		"void fft(vector<complex<double>>& a, bool invert = false) {",
		"    int n = a.size();",
		"",
		"    for (int i = 1, j = 0; i < n; i++) {",
		"        int bit = n >> 1;",
		"        for (; j & bit; bit >>= 1) j ^= bit;",
		"        j ^= bit;",
		"        if (i < j) swap(a[i], a[j]);",
		"    }",
		"",
		"    for (int len = 2; len <= n; len <<= 1) {",
		"        double ang = 2 * M_PI / len * (invert ? -1 : 1);",
		"        complex<double> wlen(cos(ang), sin(ang));",
		"",
		"        for (int i = 0; i < n; i += len) {",
		"            complex<double> w(1);",
		"            for (int j = 0; j < len / 2; j++) {",
		"                complex<double> u = a[i + j];",
		"                complex<double> v = a[i + j + len / 2] * w;",
		"                a[i + j] = u + v;",
		"                a[i + j + len / 2] = u - v;",
		"                w *= wlen;",
		"            }",
		"        }",
		"    }",
		"",
		"    if (invert) {",
		"        for (auto& x : a) x /= n;",
		"    }",
		"}",
		"",
		"// 多项式求值（Horner方法）",
		"double polynomial_eval(const vector<double>& coeffs, double x) {",
		"    double result = 0;",
		"    for (int i = coeffs.size() - 1; i >= 0; i--) { result = result * x + coeffs[i]; }",
		"    return result;",
		"}",
		"",
		"// 数值微分（中心差分）",
		"template <typename F>",
		"double numerical_derivative(F f, double x, double h = 1e-6) {",
		"    return (f(x + h) - f(x - h)) / (2 * h);",
		"}",
		"",
		"// 随机点生成器",
		"struct RandomPointGenerator {",
		"    mt19937 gen;",
		"    uniform_real_distribution<double> dis;",
		"",
		"    RandomPointGenerator(double min_val = -100, double max_val = 100) : gen(random_device{}()), dis(min_val, max_val) {}",
		"",
		"    pair<double, double> random_point() { return make_pair(dis(gen), dis(gen)); }",
		"",
		"    // 在圆内生成随机点",
		"    pair<double, double> random_point_in_circle(double cx, double cy, double r) {",
		"        double theta = dis(gen) * 2 * M_PI / 200.0;",
		"        double radius = sqrt(dis(gen) / 200.0) * r;",
		"        return make_pair(cx + radius * cos(theta), cy + radius * sin(theta));",
		"    }",
		"};",
	})
}),

-- 05_Geometry\Utils\Precision.h
s("05_geometry_utils_precision_h", {
	t({
		"/*",
		" * 几何精度处理工具",
		" * 时间复杂度: O(1)",
		" * 空间复杂度: O(1)",
		" * 适用场景: 几何计算中的精度控制和浮点数比较",
		" */",
		"",
		"const double EPS = 1e-9;",
		"const double PI = acos(-1.0);",
		"",
		"// 浮点数比较函数",
		"int dcmp(double x) {",
		"    if (fabs(x) < EPS) return 0;",
		"    return x < 0 ? -1 : 1;",
		"}",
		"",
		"bool equal(double a, double b) { return fabs(a - b) < EPS; }",
		"bool less(double a, double b) { return a < b - EPS; }",
		"bool less_equal(double a, double b) { return a < b + EPS; }",
		"bool greater(double a, double b) { return a > b + EPS; }",
		"bool greater_equal(double a, double b) { return a > b - EPS; }",
		"",
		"// 角度标准化",
		"double normalize_angle(double angle) {",
		"    while (angle < 0) angle += 2 * PI;",
		"    while (angle >= 2 * PI) angle -= 2 * PI;",
		"    return angle;",
		"}",
		"",
		"double normalize_angle_pm_pi(double angle) {",
		"    while (angle < -PI) angle += 2 * PI;",
		"    while (angle > PI) angle -= 2 * PI;",
		"    return angle;",
		"}",
		"",
		"// 安全的数学函数",
		"double safe_acos(double x) { return acos(max(-1.0, min(1.0, x))); }",
		"double safe_asin(double x) { return asin(max(-1.0, min(1.0, x))); }",
		"double safe_sqrt(double x) { return sqrt(max(0.0, x)); }",
		"",
		"// 数值稳定的二次方程求解",
		"pair<double, double> solve_quadratic(double a, double b, double c) {",
		"    if (fabs(a) < EPS) {",
		"        if (fabs(b) < EPS) return {NAN, NAN};",
		"        return {-c / b, NAN};",
		"    }",
		"",
		"    double discriminant = b * b - 4 * a * c;",
		"    if (discriminant < -EPS) return {NAN, NAN};",
		"",
		"    discriminant = max(0.0, discriminant);",
		"    double sqrt_d = sqrt(discriminant);",
		"",
		"    double x1, x2;",
		"    if (b >= 0) {",
		"        x1 = (-b - sqrt_d) / (2 * a);",
		"        x2 = c / (a * x1);",
		"    } else {",
		"        x2 = (-b + sqrt_d) / (2 * a);",
		"        x1 = c / (a * x2);",
		"    }",
		"",
		"    if (x1 > x2) swap(x1, x2);",
		"    return {x1, x2};",
		"}",
		"",
		"// 高精度距离计算",
		"double distance2_stable(double x1, double y1, double x2, double y2) {",
		"    double dx = x2 - x1;",
		"    double dy = y2 - y1;",
		"    return dx * dx + dy * dy;",
		"}",
		"",
		"// 高精度三角形面积计算（海伦公式的数值稳定版本）",
		"double triangle_area_stable(double x1, double y1, double x2, double y2, double x3, double y3) {",
		"    double a = safe_sqrt(distance2_stable(x2, y2, x3, y3));",
		"    double b = safe_sqrt(distance2_stable(x1, y1, x3, y3));",
		"    double c = safe_sqrt(distance2_stable(x1, y1, x2, y2));",
		"",
		"    if (a > b) swap(a, b);",
		"    if (b > c) swap(b, c);",
		"    if (a > b) swap(a, b);",
		"",
		"    double s = (a + b + c) / 2;",
		"    double area_sq = s * (s - a) * (s - b) * (s - c);",
		"    return safe_sqrt(area_sq);",
		"}",
		"",
		"// 自适应精度处理",
		"class AdaptivePrecision {",
		"   private:",
		"    double base_eps;",
		"    double scale_factor;",
		"",
		"   public:",
		"    AdaptivePrecision(double eps = EPS, double scale = 1e6) : base_eps(eps), scale_factor(scale) {}",
		"",
		"    double get_eps(double magnitude) const { return base_eps * max(1.0, magnitude / scale_factor); }",
		"",
		"    bool equal(double a, double b) const {",
		"        double mag = max(fabs(a), fabs(b));",
		"        return fabs(a - b) < get_eps(mag);",
		"    }",
		"",
		"    int sign(double x) const {",
		"        double eps = get_eps(fabs(x));",
		"        if (fabs(x) < eps) return 0;",
		"        return x < 0 ? -1 : 1;",
		"    }",
		"};",
		"",
		"// 有理数近似",
		"struct Fraction {",
		"    long long num, den;",
		"",
		"    Fraction(long long n = 0, long long d = 1) : num(n), den(d) {",
		"        if (den < 0) {",
		"            num = -num;",
		"            den = -den;",
		"        }",
		"        long long g = __gcd(abs(num), abs(den));",
		"        num /= g;",
		"        den /= g;",
		"    }",
		"",
		"    Fraction(double x, long long max_den = 1000000) {",
		"        num = 0;",
		"        den = 1;",
		"        long long a = (long long)floor(x);",
		"        long long p0 = 1, p1 = a, q0 = 0, q1 = 1;",
		"",
		"        double r = x - a;",
		"        while (fabs(r) > EPS && q1 <= max_den) {",
		"            r = 1.0 / r;",
		"            a = (long long)floor(r);",
		"            long long p2 = a * p1 + p0;",
		"            long long q2 = a * q1 + q0;",
		"",
		"            if (q2 > max_den) break;",
		"",
		"            p0 = p1;",
		"            p1 = p2;",
		"            q0 = q1;",
		"            q1 = q2;",
		"            r = r - a;",
		"        }",
		"",
		"        num = p1;",
		"        den = q1;",
		"        if (den < 0) {",
		"            num = -num;",
		"            den = -den;",
		"        }",
		"        long long g = __gcd(abs(num), abs(den));",
		"        num /= g;",
		"        den /= g;",
		"    }",
		"",
		"    double to_double() const { return (double)num / den; }",
		"",
		"    Fraction operator+(const Fraction& f) const { return Fraction(num * f.den + f.num * den, den * f.den); }",
		"    Fraction operator-(const Fraction& f) const { return Fraction(num * f.den - f.num * den, den * f.den); }",
		"    Fraction operator*(const Fraction& f) const { return Fraction(num * f.num, den * f.den); }",
		"    Fraction operator/(const Fraction& f) const { return Fraction(num * f.den, den * f.num); }",
		"",
		"    bool operator==(const Fraction& f) const { return num * f.den == f.num * den; }",
		"    bool operator<(const Fraction& f) const { return num * f.den < f.num * den; }",
		"};",
	})
}),

}
